/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const NT = $root.NT = (() => {

    /**
     * Namespace NT.
     * @exports NT
     * @namespace
     */
    const NT = {};

    NT.Envelope = (function() {

        /**
         * Properties of an Envelope.
         * @memberof NT
         * @interface IEnvelope
         * @property {NT.IGameAction|null} [gameAction] Envelope gameAction
         * @property {NT.ILobbyAction|null} [lobbyAction] Envelope lobbyAction
         */

        /**
         * Constructs a new Envelope.
         * @memberof NT
         * @classdesc Represents an Envelope.
         * @implements IEnvelope
         * @constructor
         * @param {NT.IEnvelope=} [properties] Properties to set
         */
        function Envelope(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Envelope gameAction.
         * @member {NT.IGameAction|null|undefined} gameAction
         * @memberof NT.Envelope
         * @instance
         */
        Envelope.prototype.gameAction = null;

        /**
         * Envelope lobbyAction.
         * @member {NT.ILobbyAction|null|undefined} lobbyAction
         * @memberof NT.Envelope
         * @instance
         */
        Envelope.prototype.lobbyAction = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Envelope kind.
         * @member {"gameAction"|"lobbyAction"|undefined} kind
         * @memberof NT.Envelope
         * @instance
         */
        Object.defineProperty(Envelope.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["gameAction", "lobbyAction"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Envelope instance using the specified properties.
         * @function create
         * @memberof NT.Envelope
         * @static
         * @param {NT.IEnvelope=} [properties] Properties to set
         * @returns {NT.Envelope} Envelope instance
         */
        Envelope.create = function create(properties) {
            return new Envelope(properties);
        };

        /**
         * Encodes the specified Envelope message. Does not implicitly {@link NT.Envelope.verify|verify} messages.
         * @function encode
         * @memberof NT.Envelope
         * @static
         * @param {NT.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameAction != null && Object.hasOwnProperty.call(message, "gameAction"))
                $root.NT.GameAction.encode(message.gameAction, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lobbyAction != null && Object.hasOwnProperty.call(message, "lobbyAction"))
                $root.NT.LobbyAction.encode(message.lobbyAction, writer.uint32(/* id 50, wireType 2 =*/402).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Envelope message, length delimited. Does not implicitly {@link NT.Envelope.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.Envelope
         * @static
         * @param {NT.IEnvelope} message Envelope message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Envelope.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer.
         * @function decode
         * @memberof NT.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Envelope();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gameAction = $root.NT.GameAction.decode(reader, reader.uint32());
                        break;
                    }
                case 50: {
                        message.lobbyAction = $root.NT.LobbyAction.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Envelope message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.Envelope
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.Envelope} Envelope
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Envelope.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Envelope message.
         * @function verify
         * @memberof NT.Envelope
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Envelope.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.gameAction != null && message.hasOwnProperty("gameAction")) {
                properties.kind = 1;
                {
                    let error = $root.NT.GameAction.verify(message.gameAction);
                    if (error)
                        return "gameAction." + error;
                }
            }
            if (message.lobbyAction != null && message.hasOwnProperty("lobbyAction")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.NT.LobbyAction.verify(message.lobbyAction);
                    if (error)
                        return "lobbyAction." + error;
                }
            }
            return null;
        };

        /**
         * Creates an Envelope message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.Envelope
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.Envelope} Envelope
         */
        Envelope.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.Envelope)
                return object;
            let message = new $root.NT.Envelope();
            if (object.gameAction != null) {
                if (typeof object.gameAction !== "object")
                    throw TypeError(".NT.Envelope.gameAction: object expected");
                message.gameAction = $root.NT.GameAction.fromObject(object.gameAction);
            }
            if (object.lobbyAction != null) {
                if (typeof object.lobbyAction !== "object")
                    throw TypeError(".NT.Envelope.lobbyAction: object expected");
                message.lobbyAction = $root.NT.LobbyAction.fromObject(object.lobbyAction);
            }
            return message;
        };

        /**
         * Creates a plain object from an Envelope message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.Envelope
         * @static
         * @param {NT.Envelope} message Envelope
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Envelope.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.gameAction != null && message.hasOwnProperty("gameAction")) {
                object.gameAction = $root.NT.GameAction.toObject(message.gameAction, options);
                if (options.oneofs)
                    object.kind = "gameAction";
            }
            if (message.lobbyAction != null && message.hasOwnProperty("lobbyAction")) {
                object.lobbyAction = $root.NT.LobbyAction.toObject(message.lobbyAction, options);
                if (options.oneofs)
                    object.kind = "lobbyAction";
            }
            return object;
        };

        /**
         * Converts this Envelope to JSON.
         * @function toJSON
         * @memberof NT.Envelope
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Envelope.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Envelope
         * @function getTypeUrl
         * @memberof NT.Envelope
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Envelope.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.Envelope";
        };

        return Envelope;
    })();

    NT.GameAction = (function() {

        /**
         * Properties of a GameAction.
         * @memberof NT
         * @interface IGameAction
         * @property {NT.ICompactPlayerFrames|null} [cPlayerMove] GameAction cPlayerMove
         * @property {NT.IServerPlayerMoves|null} [sPlayerMoves] GameAction sPlayerMoves
         * @property {NT.IClientPlayerUpdate|null} [cPlayerUpdate] GameAction cPlayerUpdate
         * @property {NT.IServerPlayerUpdate|null} [sPlayerUpdate] GameAction sPlayerUpdate
         * @property {NT.IClientPlayerUpdateInventory|null} [cPlayerUpdateInventory] GameAction cPlayerUpdateInventory
         * @property {NT.IServerPlayerUpdateInventory|null} [sPlayerUpdateInventory] GameAction sPlayerUpdateInventory
         * @property {NT.IClientHostItemBank|null} [cHostItemBank] GameAction cHostItemBank
         * @property {NT.IServerHostItemBank|null} [sHostItemBank] GameAction sHostItemBank
         * @property {NT.IClientHostUserTake|null} [cHostUserTake] GameAction cHostUserTake
         * @property {NT.IServerHostUserTake|null} [sHostUserTake] GameAction sHostUserTake
         * @property {NT.IClientHostUserTakeGold|null} [cHostUserTakeGold] GameAction cHostUserTakeGold
         * @property {NT.IServerHostUserTakeGold|null} [sHostUserTakeGold] GameAction sHostUserTakeGold
         * @property {NT.IClientPlayerAddGold|null} [cPlayerAddGold] GameAction cPlayerAddGold
         * @property {NT.IServerPlayerAddGold|null} [sPlayerAddGold] GameAction sPlayerAddGold
         * @property {NT.IClientPlayerTakeGold|null} [cPlayerTakeGold] GameAction cPlayerTakeGold
         * @property {NT.IServerPlayerTakeGold|null} [sPlayerTakeGold] GameAction sPlayerTakeGold
         * @property {NT.IClientPlayerAddItem|null} [cPlayerAddItem] GameAction cPlayerAddItem
         * @property {NT.IServerPlayerAddItem|null} [sPlayerAddItem] GameAction sPlayerAddItem
         * @property {NT.IClientPlayerTakeItem|null} [cPlayerTakeItem] GameAction cPlayerTakeItem
         * @property {NT.IServerPlayerTakeItem|null} [sPlayerTakeItem] GameAction sPlayerTakeItem
         * @property {NT.IClientPlayerPickup|null} [cPlayerPickup] GameAction cPlayerPickup
         * @property {NT.IServerPlayerPickup|null} [sPlayerPickup] GameAction sPlayerPickup
         * @property {NT.IClientNemesisAbility|null} [cNemesisAbility] GameAction cNemesisAbility
         * @property {NT.IServerNemesisAbility|null} [sNemesisAbility] GameAction sNemesisAbility
         * @property {NT.IClientNemesisPickupItem|null} [cNemesisPickupItem] GameAction cNemesisPickupItem
         * @property {NT.IServerNemesisPickupItem|null} [sNemesisPickupItem] GameAction sNemesisPickupItem
         * @property {NT.IClientChat|null} [cChat] GameAction cChat
         * @property {NT.IServerChat|null} [sChat] GameAction sChat
         * @property {NT.IClientPlayerDeath|null} [cPlayerDeath] GameAction cPlayerDeath
         * @property {NT.IServerPlayerDeath|null} [sPlayerDeath] GameAction sPlayerDeath
         * @property {NT.IClientPlayerNewGamePlus|null} [cPlayerNewGamePlus] GameAction cPlayerNewGamePlus
         * @property {NT.IServerPlayerNewGamePlus|null} [sPlayerNewGamePlus] GameAction sPlayerNewGamePlus
         * @property {NT.IClientPlayerSecretHourglass|null} [cPlayerSecretHourglass] GameAction cPlayerSecretHourglass
         * @property {NT.IServerPlayerSecretHourglass|null} [sPlayerSecretHourglass] GameAction sPlayerSecretHourglass
         * @property {NT.IClientCustomModEvent|null} [cCustomModEvent] GameAction cCustomModEvent
         * @property {NT.IServerCustomModEvent|null} [sCustomModEvent] GameAction sCustomModEvent
         * @property {NT.IClientRespawnPenalty|null} [cRespawnPenalty] GameAction cRespawnPenalty
         * @property {NT.IServerRespawnPenalty|null} [sRespawnPenalty] GameAction sRespawnPenalty
         * @property {NT.IClientAngerySteve|null} [cAngerySteve] GameAction cAngerySteve
         * @property {NT.IServerAngerySteve|null} [sAngerySteve] GameAction sAngerySteve
         * @property {NT.IServerStatsUpdate|null} [sStatUpdate] GameAction sStatUpdate
         */

        /**
         * Constructs a new GameAction.
         * @memberof NT
         * @classdesc Represents a GameAction.
         * @implements IGameAction
         * @constructor
         * @param {NT.IGameAction=} [properties] Properties to set
         */
        function GameAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GameAction cPlayerMove.
         * @member {NT.ICompactPlayerFrames|null|undefined} cPlayerMove
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerMove = null;

        /**
         * GameAction sPlayerMoves.
         * @member {NT.IServerPlayerMoves|null|undefined} sPlayerMoves
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerMoves = null;

        /**
         * GameAction cPlayerUpdate.
         * @member {NT.IClientPlayerUpdate|null|undefined} cPlayerUpdate
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerUpdate = null;

        /**
         * GameAction sPlayerUpdate.
         * @member {NT.IServerPlayerUpdate|null|undefined} sPlayerUpdate
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerUpdate = null;

        /**
         * GameAction cPlayerUpdateInventory.
         * @member {NT.IClientPlayerUpdateInventory|null|undefined} cPlayerUpdateInventory
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerUpdateInventory = null;

        /**
         * GameAction sPlayerUpdateInventory.
         * @member {NT.IServerPlayerUpdateInventory|null|undefined} sPlayerUpdateInventory
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerUpdateInventory = null;

        /**
         * GameAction cHostItemBank.
         * @member {NT.IClientHostItemBank|null|undefined} cHostItemBank
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cHostItemBank = null;

        /**
         * GameAction sHostItemBank.
         * @member {NT.IServerHostItemBank|null|undefined} sHostItemBank
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sHostItemBank = null;

        /**
         * GameAction cHostUserTake.
         * @member {NT.IClientHostUserTake|null|undefined} cHostUserTake
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cHostUserTake = null;

        /**
         * GameAction sHostUserTake.
         * @member {NT.IServerHostUserTake|null|undefined} sHostUserTake
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sHostUserTake = null;

        /**
         * GameAction cHostUserTakeGold.
         * @member {NT.IClientHostUserTakeGold|null|undefined} cHostUserTakeGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cHostUserTakeGold = null;

        /**
         * GameAction sHostUserTakeGold.
         * @member {NT.IServerHostUserTakeGold|null|undefined} sHostUserTakeGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sHostUserTakeGold = null;

        /**
         * GameAction cPlayerAddGold.
         * @member {NT.IClientPlayerAddGold|null|undefined} cPlayerAddGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerAddGold = null;

        /**
         * GameAction sPlayerAddGold.
         * @member {NT.IServerPlayerAddGold|null|undefined} sPlayerAddGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerAddGold = null;

        /**
         * GameAction cPlayerTakeGold.
         * @member {NT.IClientPlayerTakeGold|null|undefined} cPlayerTakeGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerTakeGold = null;

        /**
         * GameAction sPlayerTakeGold.
         * @member {NT.IServerPlayerTakeGold|null|undefined} sPlayerTakeGold
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerTakeGold = null;

        /**
         * GameAction cPlayerAddItem.
         * @member {NT.IClientPlayerAddItem|null|undefined} cPlayerAddItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerAddItem = null;

        /**
         * GameAction sPlayerAddItem.
         * @member {NT.IServerPlayerAddItem|null|undefined} sPlayerAddItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerAddItem = null;

        /**
         * GameAction cPlayerTakeItem.
         * @member {NT.IClientPlayerTakeItem|null|undefined} cPlayerTakeItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerTakeItem = null;

        /**
         * GameAction sPlayerTakeItem.
         * @member {NT.IServerPlayerTakeItem|null|undefined} sPlayerTakeItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerTakeItem = null;

        /**
         * GameAction cPlayerPickup.
         * @member {NT.IClientPlayerPickup|null|undefined} cPlayerPickup
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerPickup = null;

        /**
         * GameAction sPlayerPickup.
         * @member {NT.IServerPlayerPickup|null|undefined} sPlayerPickup
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerPickup = null;

        /**
         * GameAction cNemesisAbility.
         * @member {NT.IClientNemesisAbility|null|undefined} cNemesisAbility
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cNemesisAbility = null;

        /**
         * GameAction sNemesisAbility.
         * @member {NT.IServerNemesisAbility|null|undefined} sNemesisAbility
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sNemesisAbility = null;

        /**
         * GameAction cNemesisPickupItem.
         * @member {NT.IClientNemesisPickupItem|null|undefined} cNemesisPickupItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cNemesisPickupItem = null;

        /**
         * GameAction sNemesisPickupItem.
         * @member {NT.IServerNemesisPickupItem|null|undefined} sNemesisPickupItem
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sNemesisPickupItem = null;

        /**
         * GameAction cChat.
         * @member {NT.IClientChat|null|undefined} cChat
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cChat = null;

        /**
         * GameAction sChat.
         * @member {NT.IServerChat|null|undefined} sChat
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sChat = null;

        /**
         * GameAction cPlayerDeath.
         * @member {NT.IClientPlayerDeath|null|undefined} cPlayerDeath
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerDeath = null;

        /**
         * GameAction sPlayerDeath.
         * @member {NT.IServerPlayerDeath|null|undefined} sPlayerDeath
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerDeath = null;

        /**
         * GameAction cPlayerNewGamePlus.
         * @member {NT.IClientPlayerNewGamePlus|null|undefined} cPlayerNewGamePlus
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerNewGamePlus = null;

        /**
         * GameAction sPlayerNewGamePlus.
         * @member {NT.IServerPlayerNewGamePlus|null|undefined} sPlayerNewGamePlus
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerNewGamePlus = null;

        /**
         * GameAction cPlayerSecretHourglass.
         * @member {NT.IClientPlayerSecretHourglass|null|undefined} cPlayerSecretHourglass
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cPlayerSecretHourglass = null;

        /**
         * GameAction sPlayerSecretHourglass.
         * @member {NT.IServerPlayerSecretHourglass|null|undefined} sPlayerSecretHourglass
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sPlayerSecretHourglass = null;

        /**
         * GameAction cCustomModEvent.
         * @member {NT.IClientCustomModEvent|null|undefined} cCustomModEvent
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cCustomModEvent = null;

        /**
         * GameAction sCustomModEvent.
         * @member {NT.IServerCustomModEvent|null|undefined} sCustomModEvent
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sCustomModEvent = null;

        /**
         * GameAction cRespawnPenalty.
         * @member {NT.IClientRespawnPenalty|null|undefined} cRespawnPenalty
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cRespawnPenalty = null;

        /**
         * GameAction sRespawnPenalty.
         * @member {NT.IServerRespawnPenalty|null|undefined} sRespawnPenalty
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sRespawnPenalty = null;

        /**
         * GameAction cAngerySteve.
         * @member {NT.IClientAngerySteve|null|undefined} cAngerySteve
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.cAngerySteve = null;

        /**
         * GameAction sAngerySteve.
         * @member {NT.IServerAngerySteve|null|undefined} sAngerySteve
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sAngerySteve = null;

        /**
         * GameAction sStatUpdate.
         * @member {NT.IServerStatsUpdate|null|undefined} sStatUpdate
         * @memberof NT.GameAction
         * @instance
         */
        GameAction.prototype.sStatUpdate = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * GameAction action.
         * @member {"cPlayerMove"|"sPlayerMoves"|"cPlayerUpdate"|"sPlayerUpdate"|"cPlayerUpdateInventory"|"sPlayerUpdateInventory"|"cHostItemBank"|"sHostItemBank"|"cHostUserTake"|"sHostUserTake"|"cHostUserTakeGold"|"sHostUserTakeGold"|"cPlayerAddGold"|"sPlayerAddGold"|"cPlayerTakeGold"|"sPlayerTakeGold"|"cPlayerAddItem"|"sPlayerAddItem"|"cPlayerTakeItem"|"sPlayerTakeItem"|"cPlayerPickup"|"sPlayerPickup"|"cNemesisAbility"|"sNemesisAbility"|"cNemesisPickupItem"|"sNemesisPickupItem"|"cChat"|"sChat"|"cPlayerDeath"|"sPlayerDeath"|"cPlayerNewGamePlus"|"sPlayerNewGamePlus"|"cPlayerSecretHourglass"|"sPlayerSecretHourglass"|"cCustomModEvent"|"sCustomModEvent"|"cRespawnPenalty"|"sRespawnPenalty"|"cAngerySteve"|"sAngerySteve"|"sStatUpdate"|undefined} action
         * @memberof NT.GameAction
         * @instance
         */
        Object.defineProperty(GameAction.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["cPlayerMove", "sPlayerMoves", "cPlayerUpdate", "sPlayerUpdate", "cPlayerUpdateInventory", "sPlayerUpdateInventory", "cHostItemBank", "sHostItemBank", "cHostUserTake", "sHostUserTake", "cHostUserTakeGold", "sHostUserTakeGold", "cPlayerAddGold", "sPlayerAddGold", "cPlayerTakeGold", "sPlayerTakeGold", "cPlayerAddItem", "sPlayerAddItem", "cPlayerTakeItem", "sPlayerTakeItem", "cPlayerPickup", "sPlayerPickup", "cNemesisAbility", "sNemesisAbility", "cNemesisPickupItem", "sNemesisPickupItem", "cChat", "sChat", "cPlayerDeath", "sPlayerDeath", "cPlayerNewGamePlus", "sPlayerNewGamePlus", "cPlayerSecretHourglass", "sPlayerSecretHourglass", "cCustomModEvent", "sCustomModEvent", "cRespawnPenalty", "sRespawnPenalty", "cAngerySteve", "sAngerySteve", "sStatUpdate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new GameAction instance using the specified properties.
         * @function create
         * @memberof NT.GameAction
         * @static
         * @param {NT.IGameAction=} [properties] Properties to set
         * @returns {NT.GameAction} GameAction instance
         */
        GameAction.create = function create(properties) {
            return new GameAction(properties);
        };

        /**
         * Encodes the specified GameAction message. Does not implicitly {@link NT.GameAction.verify|verify} messages.
         * @function encode
         * @memberof NT.GameAction
         * @static
         * @param {NT.IGameAction} message GameAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cPlayerMove != null && Object.hasOwnProperty.call(message, "cPlayerMove"))
                $root.NT.CompactPlayerFrames.encode(message.cPlayerMove, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sPlayerMoves != null && Object.hasOwnProperty.call(message, "sPlayerMoves"))
                $root.NT.ServerPlayerMoves.encode(message.sPlayerMoves, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.cPlayerUpdate != null && Object.hasOwnProperty.call(message, "cPlayerUpdate"))
                $root.NT.ClientPlayerUpdate.encode(message.cPlayerUpdate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sPlayerUpdate != null && Object.hasOwnProperty.call(message, "sPlayerUpdate"))
                $root.NT.ServerPlayerUpdate.encode(message.sPlayerUpdate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.cPlayerUpdateInventory != null && Object.hasOwnProperty.call(message, "cPlayerUpdateInventory"))
                $root.NT.ClientPlayerUpdateInventory.encode(message.cPlayerUpdateInventory, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.sPlayerUpdateInventory != null && Object.hasOwnProperty.call(message, "sPlayerUpdateInventory"))
                $root.NT.ServerPlayerUpdateInventory.encode(message.sPlayerUpdateInventory, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.cHostItemBank != null && Object.hasOwnProperty.call(message, "cHostItemBank"))
                $root.NT.ClientHostItemBank.encode(message.cHostItemBank, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sHostItemBank != null && Object.hasOwnProperty.call(message, "sHostItemBank"))
                $root.NT.ServerHostItemBank.encode(message.sHostItemBank, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.cHostUserTake != null && Object.hasOwnProperty.call(message, "cHostUserTake"))
                $root.NT.ClientHostUserTake.encode(message.cHostUserTake, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.sHostUserTake != null && Object.hasOwnProperty.call(message, "sHostUserTake"))
                $root.NT.ServerHostUserTake.encode(message.sHostUserTake, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.cHostUserTakeGold != null && Object.hasOwnProperty.call(message, "cHostUserTakeGold"))
                $root.NT.ClientHostUserTakeGold.encode(message.cHostUserTakeGold, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.sHostUserTakeGold != null && Object.hasOwnProperty.call(message, "sHostUserTakeGold"))
                $root.NT.ServerHostUserTakeGold.encode(message.sHostUserTakeGold, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.cPlayerAddGold != null && Object.hasOwnProperty.call(message, "cPlayerAddGold"))
                $root.NT.ClientPlayerAddGold.encode(message.cPlayerAddGold, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.sPlayerAddGold != null && Object.hasOwnProperty.call(message, "sPlayerAddGold"))
                $root.NT.ServerPlayerAddGold.encode(message.sPlayerAddGold, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.cPlayerTakeGold != null && Object.hasOwnProperty.call(message, "cPlayerTakeGold"))
                $root.NT.ClientPlayerTakeGold.encode(message.cPlayerTakeGold, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.sPlayerTakeGold != null && Object.hasOwnProperty.call(message, "sPlayerTakeGold"))
                $root.NT.ServerPlayerTakeGold.encode(message.sPlayerTakeGold, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.cPlayerAddItem != null && Object.hasOwnProperty.call(message, "cPlayerAddItem"))
                $root.NT.ClientPlayerAddItem.encode(message.cPlayerAddItem, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.sPlayerAddItem != null && Object.hasOwnProperty.call(message, "sPlayerAddItem"))
                $root.NT.ServerPlayerAddItem.encode(message.sPlayerAddItem, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.cPlayerTakeItem != null && Object.hasOwnProperty.call(message, "cPlayerTakeItem"))
                $root.NT.ClientPlayerTakeItem.encode(message.cPlayerTakeItem, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.sPlayerTakeItem != null && Object.hasOwnProperty.call(message, "sPlayerTakeItem"))
                $root.NT.ServerPlayerTakeItem.encode(message.sPlayerTakeItem, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.cPlayerPickup != null && Object.hasOwnProperty.call(message, "cPlayerPickup"))
                $root.NT.ClientPlayerPickup.encode(message.cPlayerPickup, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.sPlayerPickup != null && Object.hasOwnProperty.call(message, "sPlayerPickup"))
                $root.NT.ServerPlayerPickup.encode(message.sPlayerPickup, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.cNemesisAbility != null && Object.hasOwnProperty.call(message, "cNemesisAbility"))
                $root.NT.ClientNemesisAbility.encode(message.cNemesisAbility, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.sNemesisAbility != null && Object.hasOwnProperty.call(message, "sNemesisAbility"))
                $root.NT.ServerNemesisAbility.encode(message.sNemesisAbility, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.cNemesisPickupItem != null && Object.hasOwnProperty.call(message, "cNemesisPickupItem"))
                $root.NT.ClientNemesisPickupItem.encode(message.cNemesisPickupItem, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.sNemesisPickupItem != null && Object.hasOwnProperty.call(message, "sNemesisPickupItem"))
                $root.NT.ServerNemesisPickupItem.encode(message.sNemesisPickupItem, writer.uint32(/* id 26, wireType 2 =*/210).fork()).ldelim();
            if (message.cChat != null && Object.hasOwnProperty.call(message, "cChat"))
                $root.NT.ClientChat.encode(message.cChat, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.sChat != null && Object.hasOwnProperty.call(message, "sChat"))
                $root.NT.ServerChat.encode(message.sChat, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.cPlayerDeath != null && Object.hasOwnProperty.call(message, "cPlayerDeath"))
                $root.NT.ClientPlayerDeath.encode(message.cPlayerDeath, writer.uint32(/* id 29, wireType 2 =*/234).fork()).ldelim();
            if (message.sPlayerDeath != null && Object.hasOwnProperty.call(message, "sPlayerDeath"))
                $root.NT.ServerPlayerDeath.encode(message.sPlayerDeath, writer.uint32(/* id 30, wireType 2 =*/242).fork()).ldelim();
            if (message.cPlayerNewGamePlus != null && Object.hasOwnProperty.call(message, "cPlayerNewGamePlus"))
                $root.NT.ClientPlayerNewGamePlus.encode(message.cPlayerNewGamePlus, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.sPlayerNewGamePlus != null && Object.hasOwnProperty.call(message, "sPlayerNewGamePlus"))
                $root.NT.ServerPlayerNewGamePlus.encode(message.sPlayerNewGamePlus, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.cPlayerSecretHourglass != null && Object.hasOwnProperty.call(message, "cPlayerSecretHourglass"))
                $root.NT.ClientPlayerSecretHourglass.encode(message.cPlayerSecretHourglass, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            if (message.sPlayerSecretHourglass != null && Object.hasOwnProperty.call(message, "sPlayerSecretHourglass"))
                $root.NT.ServerPlayerSecretHourglass.encode(message.sPlayerSecretHourglass, writer.uint32(/* id 34, wireType 2 =*/274).fork()).ldelim();
            if (message.cCustomModEvent != null && Object.hasOwnProperty.call(message, "cCustomModEvent"))
                $root.NT.ClientCustomModEvent.encode(message.cCustomModEvent, writer.uint32(/* id 35, wireType 2 =*/282).fork()).ldelim();
            if (message.sCustomModEvent != null && Object.hasOwnProperty.call(message, "sCustomModEvent"))
                $root.NT.ServerCustomModEvent.encode(message.sCustomModEvent, writer.uint32(/* id 36, wireType 2 =*/290).fork()).ldelim();
            if (message.cRespawnPenalty != null && Object.hasOwnProperty.call(message, "cRespawnPenalty"))
                $root.NT.ClientRespawnPenalty.encode(message.cRespawnPenalty, writer.uint32(/* id 37, wireType 2 =*/298).fork()).ldelim();
            if (message.sRespawnPenalty != null && Object.hasOwnProperty.call(message, "sRespawnPenalty"))
                $root.NT.ServerRespawnPenalty.encode(message.sRespawnPenalty, writer.uint32(/* id 38, wireType 2 =*/306).fork()).ldelim();
            if (message.cAngerySteve != null && Object.hasOwnProperty.call(message, "cAngerySteve"))
                $root.NT.ClientAngerySteve.encode(message.cAngerySteve, writer.uint32(/* id 39, wireType 2 =*/314).fork()).ldelim();
            if (message.sAngerySteve != null && Object.hasOwnProperty.call(message, "sAngerySteve"))
                $root.NT.ServerAngerySteve.encode(message.sAngerySteve, writer.uint32(/* id 40, wireType 2 =*/322).fork()).ldelim();
            if (message.sStatUpdate != null && Object.hasOwnProperty.call(message, "sStatUpdate"))
                $root.NT.ServerStatsUpdate.encode(message.sStatUpdate, writer.uint32(/* id 42, wireType 2 =*/338).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GameAction message, length delimited. Does not implicitly {@link NT.GameAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.GameAction
         * @static
         * @param {NT.IGameAction} message GameAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GameAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GameAction message from the specified reader or buffer.
         * @function decode
         * @memberof NT.GameAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.GameAction} GameAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.GameAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cPlayerMove = $root.NT.CompactPlayerFrames.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.sPlayerMoves = $root.NT.ServerPlayerMoves.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.cPlayerUpdate = $root.NT.ClientPlayerUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.sPlayerUpdate = $root.NT.ServerPlayerUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.cPlayerUpdateInventory = $root.NT.ClientPlayerUpdateInventory.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.sPlayerUpdateInventory = $root.NT.ServerPlayerUpdateInventory.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.cHostItemBank = $root.NT.ClientHostItemBank.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.sHostItemBank = $root.NT.ServerHostItemBank.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.cHostUserTake = $root.NT.ClientHostUserTake.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.sHostUserTake = $root.NT.ServerHostUserTake.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.cHostUserTakeGold = $root.NT.ClientHostUserTakeGold.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.sHostUserTakeGold = $root.NT.ServerHostUserTakeGold.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.cPlayerAddGold = $root.NT.ClientPlayerAddGold.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.sPlayerAddGold = $root.NT.ServerPlayerAddGold.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.cPlayerTakeGold = $root.NT.ClientPlayerTakeGold.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.sPlayerTakeGold = $root.NT.ServerPlayerTakeGold.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.cPlayerAddItem = $root.NT.ClientPlayerAddItem.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.sPlayerAddItem = $root.NT.ServerPlayerAddItem.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.cPlayerTakeItem = $root.NT.ClientPlayerTakeItem.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.sPlayerTakeItem = $root.NT.ServerPlayerTakeItem.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.cPlayerPickup = $root.NT.ClientPlayerPickup.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.sPlayerPickup = $root.NT.ServerPlayerPickup.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.cNemesisAbility = $root.NT.ClientNemesisAbility.decode(reader, reader.uint32());
                        break;
                    }
                case 24: {
                        message.sNemesisAbility = $root.NT.ServerNemesisAbility.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.cNemesisPickupItem = $root.NT.ClientNemesisPickupItem.decode(reader, reader.uint32());
                        break;
                    }
                case 26: {
                        message.sNemesisPickupItem = $root.NT.ServerNemesisPickupItem.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        message.cChat = $root.NT.ClientChat.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.sChat = $root.NT.ServerChat.decode(reader, reader.uint32());
                        break;
                    }
                case 29: {
                        message.cPlayerDeath = $root.NT.ClientPlayerDeath.decode(reader, reader.uint32());
                        break;
                    }
                case 30: {
                        message.sPlayerDeath = $root.NT.ServerPlayerDeath.decode(reader, reader.uint32());
                        break;
                    }
                case 31: {
                        message.cPlayerNewGamePlus = $root.NT.ClientPlayerNewGamePlus.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.sPlayerNewGamePlus = $root.NT.ServerPlayerNewGamePlus.decode(reader, reader.uint32());
                        break;
                    }
                case 33: {
                        message.cPlayerSecretHourglass = $root.NT.ClientPlayerSecretHourglass.decode(reader, reader.uint32());
                        break;
                    }
                case 34: {
                        message.sPlayerSecretHourglass = $root.NT.ServerPlayerSecretHourglass.decode(reader, reader.uint32());
                        break;
                    }
                case 35: {
                        message.cCustomModEvent = $root.NT.ClientCustomModEvent.decode(reader, reader.uint32());
                        break;
                    }
                case 36: {
                        message.sCustomModEvent = $root.NT.ServerCustomModEvent.decode(reader, reader.uint32());
                        break;
                    }
                case 37: {
                        message.cRespawnPenalty = $root.NT.ClientRespawnPenalty.decode(reader, reader.uint32());
                        break;
                    }
                case 38: {
                        message.sRespawnPenalty = $root.NT.ServerRespawnPenalty.decode(reader, reader.uint32());
                        break;
                    }
                case 39: {
                        message.cAngerySteve = $root.NT.ClientAngerySteve.decode(reader, reader.uint32());
                        break;
                    }
                case 40: {
                        message.sAngerySteve = $root.NT.ServerAngerySteve.decode(reader, reader.uint32());
                        break;
                    }
                case 42: {
                        message.sStatUpdate = $root.NT.ServerStatsUpdate.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GameAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.GameAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.GameAction} GameAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GameAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GameAction message.
         * @function verify
         * @memberof NT.GameAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GameAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.cPlayerMove != null && message.hasOwnProperty("cPlayerMove")) {
                properties.action = 1;
                {
                    let error = $root.NT.CompactPlayerFrames.verify(message.cPlayerMove);
                    if (error)
                        return "cPlayerMove." + error;
                }
            }
            if (message.sPlayerMoves != null && message.hasOwnProperty("sPlayerMoves")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerMoves.verify(message.sPlayerMoves);
                    if (error)
                        return "sPlayerMoves." + error;
                }
            }
            if (message.cPlayerUpdate != null && message.hasOwnProperty("cPlayerUpdate")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerUpdate.verify(message.cPlayerUpdate);
                    if (error)
                        return "cPlayerUpdate." + error;
                }
            }
            if (message.sPlayerUpdate != null && message.hasOwnProperty("sPlayerUpdate")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerUpdate.verify(message.sPlayerUpdate);
                    if (error)
                        return "sPlayerUpdate." + error;
                }
            }
            if (message.cPlayerUpdateInventory != null && message.hasOwnProperty("cPlayerUpdateInventory")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerUpdateInventory.verify(message.cPlayerUpdateInventory);
                    if (error)
                        return "cPlayerUpdateInventory." + error;
                }
            }
            if (message.sPlayerUpdateInventory != null && message.hasOwnProperty("sPlayerUpdateInventory")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerUpdateInventory.verify(message.sPlayerUpdateInventory);
                    if (error)
                        return "sPlayerUpdateInventory." + error;
                }
            }
            if (message.cHostItemBank != null && message.hasOwnProperty("cHostItemBank")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientHostItemBank.verify(message.cHostItemBank);
                    if (error)
                        return "cHostItemBank." + error;
                }
            }
            if (message.sHostItemBank != null && message.hasOwnProperty("sHostItemBank")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerHostItemBank.verify(message.sHostItemBank);
                    if (error)
                        return "sHostItemBank." + error;
                }
            }
            if (message.cHostUserTake != null && message.hasOwnProperty("cHostUserTake")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientHostUserTake.verify(message.cHostUserTake);
                    if (error)
                        return "cHostUserTake." + error;
                }
            }
            if (message.sHostUserTake != null && message.hasOwnProperty("sHostUserTake")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerHostUserTake.verify(message.sHostUserTake);
                    if (error)
                        return "sHostUserTake." + error;
                }
            }
            if (message.cHostUserTakeGold != null && message.hasOwnProperty("cHostUserTakeGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientHostUserTakeGold.verify(message.cHostUserTakeGold);
                    if (error)
                        return "cHostUserTakeGold." + error;
                }
            }
            if (message.sHostUserTakeGold != null && message.hasOwnProperty("sHostUserTakeGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerHostUserTakeGold.verify(message.sHostUserTakeGold);
                    if (error)
                        return "sHostUserTakeGold." + error;
                }
            }
            if (message.cPlayerAddGold != null && message.hasOwnProperty("cPlayerAddGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerAddGold.verify(message.cPlayerAddGold);
                    if (error)
                        return "cPlayerAddGold." + error;
                }
            }
            if (message.sPlayerAddGold != null && message.hasOwnProperty("sPlayerAddGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerAddGold.verify(message.sPlayerAddGold);
                    if (error)
                        return "sPlayerAddGold." + error;
                }
            }
            if (message.cPlayerTakeGold != null && message.hasOwnProperty("cPlayerTakeGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerTakeGold.verify(message.cPlayerTakeGold);
                    if (error)
                        return "cPlayerTakeGold." + error;
                }
            }
            if (message.sPlayerTakeGold != null && message.hasOwnProperty("sPlayerTakeGold")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerTakeGold.verify(message.sPlayerTakeGold);
                    if (error)
                        return "sPlayerTakeGold." + error;
                }
            }
            if (message.cPlayerAddItem != null && message.hasOwnProperty("cPlayerAddItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerAddItem.verify(message.cPlayerAddItem);
                    if (error)
                        return "cPlayerAddItem." + error;
                }
            }
            if (message.sPlayerAddItem != null && message.hasOwnProperty("sPlayerAddItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerAddItem.verify(message.sPlayerAddItem);
                    if (error)
                        return "sPlayerAddItem." + error;
                }
            }
            if (message.cPlayerTakeItem != null && message.hasOwnProperty("cPlayerTakeItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerTakeItem.verify(message.cPlayerTakeItem);
                    if (error)
                        return "cPlayerTakeItem." + error;
                }
            }
            if (message.sPlayerTakeItem != null && message.hasOwnProperty("sPlayerTakeItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerTakeItem.verify(message.sPlayerTakeItem);
                    if (error)
                        return "sPlayerTakeItem." + error;
                }
            }
            if (message.cPlayerPickup != null && message.hasOwnProperty("cPlayerPickup")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerPickup.verify(message.cPlayerPickup);
                    if (error)
                        return "cPlayerPickup." + error;
                }
            }
            if (message.sPlayerPickup != null && message.hasOwnProperty("sPlayerPickup")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerPickup.verify(message.sPlayerPickup);
                    if (error)
                        return "sPlayerPickup." + error;
                }
            }
            if (message.cNemesisAbility != null && message.hasOwnProperty("cNemesisAbility")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientNemesisAbility.verify(message.cNemesisAbility);
                    if (error)
                        return "cNemesisAbility." + error;
                }
            }
            if (message.sNemesisAbility != null && message.hasOwnProperty("sNemesisAbility")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerNemesisAbility.verify(message.sNemesisAbility);
                    if (error)
                        return "sNemesisAbility." + error;
                }
            }
            if (message.cNemesisPickupItem != null && message.hasOwnProperty("cNemesisPickupItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientNemesisPickupItem.verify(message.cNemesisPickupItem);
                    if (error)
                        return "cNemesisPickupItem." + error;
                }
            }
            if (message.sNemesisPickupItem != null && message.hasOwnProperty("sNemesisPickupItem")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerNemesisPickupItem.verify(message.sNemesisPickupItem);
                    if (error)
                        return "sNemesisPickupItem." + error;
                }
            }
            if (message.cChat != null && message.hasOwnProperty("cChat")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientChat.verify(message.cChat);
                    if (error)
                        return "cChat." + error;
                }
            }
            if (message.sChat != null && message.hasOwnProperty("sChat")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerChat.verify(message.sChat);
                    if (error)
                        return "sChat." + error;
                }
            }
            if (message.cPlayerDeath != null && message.hasOwnProperty("cPlayerDeath")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerDeath.verify(message.cPlayerDeath);
                    if (error)
                        return "cPlayerDeath." + error;
                }
            }
            if (message.sPlayerDeath != null && message.hasOwnProperty("sPlayerDeath")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerDeath.verify(message.sPlayerDeath);
                    if (error)
                        return "sPlayerDeath." + error;
                }
            }
            if (message.cPlayerNewGamePlus != null && message.hasOwnProperty("cPlayerNewGamePlus")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerNewGamePlus.verify(message.cPlayerNewGamePlus);
                    if (error)
                        return "cPlayerNewGamePlus." + error;
                }
            }
            if (message.sPlayerNewGamePlus != null && message.hasOwnProperty("sPlayerNewGamePlus")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerNewGamePlus.verify(message.sPlayerNewGamePlus);
                    if (error)
                        return "sPlayerNewGamePlus." + error;
                }
            }
            if (message.cPlayerSecretHourglass != null && message.hasOwnProperty("cPlayerSecretHourglass")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientPlayerSecretHourglass.verify(message.cPlayerSecretHourglass);
                    if (error)
                        return "cPlayerSecretHourglass." + error;
                }
            }
            if (message.sPlayerSecretHourglass != null && message.hasOwnProperty("sPlayerSecretHourglass")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerPlayerSecretHourglass.verify(message.sPlayerSecretHourglass);
                    if (error)
                        return "sPlayerSecretHourglass." + error;
                }
            }
            if (message.cCustomModEvent != null && message.hasOwnProperty("cCustomModEvent")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientCustomModEvent.verify(message.cCustomModEvent);
                    if (error)
                        return "cCustomModEvent." + error;
                }
            }
            if (message.sCustomModEvent != null && message.hasOwnProperty("sCustomModEvent")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerCustomModEvent.verify(message.sCustomModEvent);
                    if (error)
                        return "sCustomModEvent." + error;
                }
            }
            if (message.cRespawnPenalty != null && message.hasOwnProperty("cRespawnPenalty")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRespawnPenalty.verify(message.cRespawnPenalty);
                    if (error)
                        return "cRespawnPenalty." + error;
                }
            }
            if (message.sRespawnPenalty != null && message.hasOwnProperty("sRespawnPenalty")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRespawnPenalty.verify(message.sRespawnPenalty);
                    if (error)
                        return "sRespawnPenalty." + error;
                }
            }
            if (message.cAngerySteve != null && message.hasOwnProperty("cAngerySteve")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientAngerySteve.verify(message.cAngerySteve);
                    if (error)
                        return "cAngerySteve." + error;
                }
            }
            if (message.sAngerySteve != null && message.hasOwnProperty("sAngerySteve")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerAngerySteve.verify(message.sAngerySteve);
                    if (error)
                        return "sAngerySteve." + error;
                }
            }
            if (message.sStatUpdate != null && message.hasOwnProperty("sStatUpdate")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerStatsUpdate.verify(message.sStatUpdate);
                    if (error)
                        return "sStatUpdate." + error;
                }
            }
            return null;
        };

        /**
         * Creates a GameAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.GameAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.GameAction} GameAction
         */
        GameAction.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.GameAction)
                return object;
            let message = new $root.NT.GameAction();
            if (object.cPlayerMove != null) {
                if (typeof object.cPlayerMove !== "object")
                    throw TypeError(".NT.GameAction.cPlayerMove: object expected");
                message.cPlayerMove = $root.NT.CompactPlayerFrames.fromObject(object.cPlayerMove);
            }
            if (object.sPlayerMoves != null) {
                if (typeof object.sPlayerMoves !== "object")
                    throw TypeError(".NT.GameAction.sPlayerMoves: object expected");
                message.sPlayerMoves = $root.NT.ServerPlayerMoves.fromObject(object.sPlayerMoves);
            }
            if (object.cPlayerUpdate != null) {
                if (typeof object.cPlayerUpdate !== "object")
                    throw TypeError(".NT.GameAction.cPlayerUpdate: object expected");
                message.cPlayerUpdate = $root.NT.ClientPlayerUpdate.fromObject(object.cPlayerUpdate);
            }
            if (object.sPlayerUpdate != null) {
                if (typeof object.sPlayerUpdate !== "object")
                    throw TypeError(".NT.GameAction.sPlayerUpdate: object expected");
                message.sPlayerUpdate = $root.NT.ServerPlayerUpdate.fromObject(object.sPlayerUpdate);
            }
            if (object.cPlayerUpdateInventory != null) {
                if (typeof object.cPlayerUpdateInventory !== "object")
                    throw TypeError(".NT.GameAction.cPlayerUpdateInventory: object expected");
                message.cPlayerUpdateInventory = $root.NT.ClientPlayerUpdateInventory.fromObject(object.cPlayerUpdateInventory);
            }
            if (object.sPlayerUpdateInventory != null) {
                if (typeof object.sPlayerUpdateInventory !== "object")
                    throw TypeError(".NT.GameAction.sPlayerUpdateInventory: object expected");
                message.sPlayerUpdateInventory = $root.NT.ServerPlayerUpdateInventory.fromObject(object.sPlayerUpdateInventory);
            }
            if (object.cHostItemBank != null) {
                if (typeof object.cHostItemBank !== "object")
                    throw TypeError(".NT.GameAction.cHostItemBank: object expected");
                message.cHostItemBank = $root.NT.ClientHostItemBank.fromObject(object.cHostItemBank);
            }
            if (object.sHostItemBank != null) {
                if (typeof object.sHostItemBank !== "object")
                    throw TypeError(".NT.GameAction.sHostItemBank: object expected");
                message.sHostItemBank = $root.NT.ServerHostItemBank.fromObject(object.sHostItemBank);
            }
            if (object.cHostUserTake != null) {
                if (typeof object.cHostUserTake !== "object")
                    throw TypeError(".NT.GameAction.cHostUserTake: object expected");
                message.cHostUserTake = $root.NT.ClientHostUserTake.fromObject(object.cHostUserTake);
            }
            if (object.sHostUserTake != null) {
                if (typeof object.sHostUserTake !== "object")
                    throw TypeError(".NT.GameAction.sHostUserTake: object expected");
                message.sHostUserTake = $root.NT.ServerHostUserTake.fromObject(object.sHostUserTake);
            }
            if (object.cHostUserTakeGold != null) {
                if (typeof object.cHostUserTakeGold !== "object")
                    throw TypeError(".NT.GameAction.cHostUserTakeGold: object expected");
                message.cHostUserTakeGold = $root.NT.ClientHostUserTakeGold.fromObject(object.cHostUserTakeGold);
            }
            if (object.sHostUserTakeGold != null) {
                if (typeof object.sHostUserTakeGold !== "object")
                    throw TypeError(".NT.GameAction.sHostUserTakeGold: object expected");
                message.sHostUserTakeGold = $root.NT.ServerHostUserTakeGold.fromObject(object.sHostUserTakeGold);
            }
            if (object.cPlayerAddGold != null) {
                if (typeof object.cPlayerAddGold !== "object")
                    throw TypeError(".NT.GameAction.cPlayerAddGold: object expected");
                message.cPlayerAddGold = $root.NT.ClientPlayerAddGold.fromObject(object.cPlayerAddGold);
            }
            if (object.sPlayerAddGold != null) {
                if (typeof object.sPlayerAddGold !== "object")
                    throw TypeError(".NT.GameAction.sPlayerAddGold: object expected");
                message.sPlayerAddGold = $root.NT.ServerPlayerAddGold.fromObject(object.sPlayerAddGold);
            }
            if (object.cPlayerTakeGold != null) {
                if (typeof object.cPlayerTakeGold !== "object")
                    throw TypeError(".NT.GameAction.cPlayerTakeGold: object expected");
                message.cPlayerTakeGold = $root.NT.ClientPlayerTakeGold.fromObject(object.cPlayerTakeGold);
            }
            if (object.sPlayerTakeGold != null) {
                if (typeof object.sPlayerTakeGold !== "object")
                    throw TypeError(".NT.GameAction.sPlayerTakeGold: object expected");
                message.sPlayerTakeGold = $root.NT.ServerPlayerTakeGold.fromObject(object.sPlayerTakeGold);
            }
            if (object.cPlayerAddItem != null) {
                if (typeof object.cPlayerAddItem !== "object")
                    throw TypeError(".NT.GameAction.cPlayerAddItem: object expected");
                message.cPlayerAddItem = $root.NT.ClientPlayerAddItem.fromObject(object.cPlayerAddItem);
            }
            if (object.sPlayerAddItem != null) {
                if (typeof object.sPlayerAddItem !== "object")
                    throw TypeError(".NT.GameAction.sPlayerAddItem: object expected");
                message.sPlayerAddItem = $root.NT.ServerPlayerAddItem.fromObject(object.sPlayerAddItem);
            }
            if (object.cPlayerTakeItem != null) {
                if (typeof object.cPlayerTakeItem !== "object")
                    throw TypeError(".NT.GameAction.cPlayerTakeItem: object expected");
                message.cPlayerTakeItem = $root.NT.ClientPlayerTakeItem.fromObject(object.cPlayerTakeItem);
            }
            if (object.sPlayerTakeItem != null) {
                if (typeof object.sPlayerTakeItem !== "object")
                    throw TypeError(".NT.GameAction.sPlayerTakeItem: object expected");
                message.sPlayerTakeItem = $root.NT.ServerPlayerTakeItem.fromObject(object.sPlayerTakeItem);
            }
            if (object.cPlayerPickup != null) {
                if (typeof object.cPlayerPickup !== "object")
                    throw TypeError(".NT.GameAction.cPlayerPickup: object expected");
                message.cPlayerPickup = $root.NT.ClientPlayerPickup.fromObject(object.cPlayerPickup);
            }
            if (object.sPlayerPickup != null) {
                if (typeof object.sPlayerPickup !== "object")
                    throw TypeError(".NT.GameAction.sPlayerPickup: object expected");
                message.sPlayerPickup = $root.NT.ServerPlayerPickup.fromObject(object.sPlayerPickup);
            }
            if (object.cNemesisAbility != null) {
                if (typeof object.cNemesisAbility !== "object")
                    throw TypeError(".NT.GameAction.cNemesisAbility: object expected");
                message.cNemesisAbility = $root.NT.ClientNemesisAbility.fromObject(object.cNemesisAbility);
            }
            if (object.sNemesisAbility != null) {
                if (typeof object.sNemesisAbility !== "object")
                    throw TypeError(".NT.GameAction.sNemesisAbility: object expected");
                message.sNemesisAbility = $root.NT.ServerNemesisAbility.fromObject(object.sNemesisAbility);
            }
            if (object.cNemesisPickupItem != null) {
                if (typeof object.cNemesisPickupItem !== "object")
                    throw TypeError(".NT.GameAction.cNemesisPickupItem: object expected");
                message.cNemesisPickupItem = $root.NT.ClientNemesisPickupItem.fromObject(object.cNemesisPickupItem);
            }
            if (object.sNemesisPickupItem != null) {
                if (typeof object.sNemesisPickupItem !== "object")
                    throw TypeError(".NT.GameAction.sNemesisPickupItem: object expected");
                message.sNemesisPickupItem = $root.NT.ServerNemesisPickupItem.fromObject(object.sNemesisPickupItem);
            }
            if (object.cChat != null) {
                if (typeof object.cChat !== "object")
                    throw TypeError(".NT.GameAction.cChat: object expected");
                message.cChat = $root.NT.ClientChat.fromObject(object.cChat);
            }
            if (object.sChat != null) {
                if (typeof object.sChat !== "object")
                    throw TypeError(".NT.GameAction.sChat: object expected");
                message.sChat = $root.NT.ServerChat.fromObject(object.sChat);
            }
            if (object.cPlayerDeath != null) {
                if (typeof object.cPlayerDeath !== "object")
                    throw TypeError(".NT.GameAction.cPlayerDeath: object expected");
                message.cPlayerDeath = $root.NT.ClientPlayerDeath.fromObject(object.cPlayerDeath);
            }
            if (object.sPlayerDeath != null) {
                if (typeof object.sPlayerDeath !== "object")
                    throw TypeError(".NT.GameAction.sPlayerDeath: object expected");
                message.sPlayerDeath = $root.NT.ServerPlayerDeath.fromObject(object.sPlayerDeath);
            }
            if (object.cPlayerNewGamePlus != null) {
                if (typeof object.cPlayerNewGamePlus !== "object")
                    throw TypeError(".NT.GameAction.cPlayerNewGamePlus: object expected");
                message.cPlayerNewGamePlus = $root.NT.ClientPlayerNewGamePlus.fromObject(object.cPlayerNewGamePlus);
            }
            if (object.sPlayerNewGamePlus != null) {
                if (typeof object.sPlayerNewGamePlus !== "object")
                    throw TypeError(".NT.GameAction.sPlayerNewGamePlus: object expected");
                message.sPlayerNewGamePlus = $root.NT.ServerPlayerNewGamePlus.fromObject(object.sPlayerNewGamePlus);
            }
            if (object.cPlayerSecretHourglass != null) {
                if (typeof object.cPlayerSecretHourglass !== "object")
                    throw TypeError(".NT.GameAction.cPlayerSecretHourglass: object expected");
                message.cPlayerSecretHourglass = $root.NT.ClientPlayerSecretHourglass.fromObject(object.cPlayerSecretHourglass);
            }
            if (object.sPlayerSecretHourglass != null) {
                if (typeof object.sPlayerSecretHourglass !== "object")
                    throw TypeError(".NT.GameAction.sPlayerSecretHourglass: object expected");
                message.sPlayerSecretHourglass = $root.NT.ServerPlayerSecretHourglass.fromObject(object.sPlayerSecretHourglass);
            }
            if (object.cCustomModEvent != null) {
                if (typeof object.cCustomModEvent !== "object")
                    throw TypeError(".NT.GameAction.cCustomModEvent: object expected");
                message.cCustomModEvent = $root.NT.ClientCustomModEvent.fromObject(object.cCustomModEvent);
            }
            if (object.sCustomModEvent != null) {
                if (typeof object.sCustomModEvent !== "object")
                    throw TypeError(".NT.GameAction.sCustomModEvent: object expected");
                message.sCustomModEvent = $root.NT.ServerCustomModEvent.fromObject(object.sCustomModEvent);
            }
            if (object.cRespawnPenalty != null) {
                if (typeof object.cRespawnPenalty !== "object")
                    throw TypeError(".NT.GameAction.cRespawnPenalty: object expected");
                message.cRespawnPenalty = $root.NT.ClientRespawnPenalty.fromObject(object.cRespawnPenalty);
            }
            if (object.sRespawnPenalty != null) {
                if (typeof object.sRespawnPenalty !== "object")
                    throw TypeError(".NT.GameAction.sRespawnPenalty: object expected");
                message.sRespawnPenalty = $root.NT.ServerRespawnPenalty.fromObject(object.sRespawnPenalty);
            }
            if (object.cAngerySteve != null) {
                if (typeof object.cAngerySteve !== "object")
                    throw TypeError(".NT.GameAction.cAngerySteve: object expected");
                message.cAngerySteve = $root.NT.ClientAngerySteve.fromObject(object.cAngerySteve);
            }
            if (object.sAngerySteve != null) {
                if (typeof object.sAngerySteve !== "object")
                    throw TypeError(".NT.GameAction.sAngerySteve: object expected");
                message.sAngerySteve = $root.NT.ServerAngerySteve.fromObject(object.sAngerySteve);
            }
            if (object.sStatUpdate != null) {
                if (typeof object.sStatUpdate !== "object")
                    throw TypeError(".NT.GameAction.sStatUpdate: object expected");
                message.sStatUpdate = $root.NT.ServerStatsUpdate.fromObject(object.sStatUpdate);
            }
            return message;
        };

        /**
         * Creates a plain object from a GameAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.GameAction
         * @static
         * @param {NT.GameAction} message GameAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        GameAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.cPlayerMove != null && message.hasOwnProperty("cPlayerMove")) {
                object.cPlayerMove = $root.NT.CompactPlayerFrames.toObject(message.cPlayerMove, options);
                if (options.oneofs)
                    object.action = "cPlayerMove";
            }
            if (message.sPlayerMoves != null && message.hasOwnProperty("sPlayerMoves")) {
                object.sPlayerMoves = $root.NT.ServerPlayerMoves.toObject(message.sPlayerMoves, options);
                if (options.oneofs)
                    object.action = "sPlayerMoves";
            }
            if (message.cPlayerUpdate != null && message.hasOwnProperty("cPlayerUpdate")) {
                object.cPlayerUpdate = $root.NT.ClientPlayerUpdate.toObject(message.cPlayerUpdate, options);
                if (options.oneofs)
                    object.action = "cPlayerUpdate";
            }
            if (message.sPlayerUpdate != null && message.hasOwnProperty("sPlayerUpdate")) {
                object.sPlayerUpdate = $root.NT.ServerPlayerUpdate.toObject(message.sPlayerUpdate, options);
                if (options.oneofs)
                    object.action = "sPlayerUpdate";
            }
            if (message.cPlayerUpdateInventory != null && message.hasOwnProperty("cPlayerUpdateInventory")) {
                object.cPlayerUpdateInventory = $root.NT.ClientPlayerUpdateInventory.toObject(message.cPlayerUpdateInventory, options);
                if (options.oneofs)
                    object.action = "cPlayerUpdateInventory";
            }
            if (message.sPlayerUpdateInventory != null && message.hasOwnProperty("sPlayerUpdateInventory")) {
                object.sPlayerUpdateInventory = $root.NT.ServerPlayerUpdateInventory.toObject(message.sPlayerUpdateInventory, options);
                if (options.oneofs)
                    object.action = "sPlayerUpdateInventory";
            }
            if (message.cHostItemBank != null && message.hasOwnProperty("cHostItemBank")) {
                object.cHostItemBank = $root.NT.ClientHostItemBank.toObject(message.cHostItemBank, options);
                if (options.oneofs)
                    object.action = "cHostItemBank";
            }
            if (message.sHostItemBank != null && message.hasOwnProperty("sHostItemBank")) {
                object.sHostItemBank = $root.NT.ServerHostItemBank.toObject(message.sHostItemBank, options);
                if (options.oneofs)
                    object.action = "sHostItemBank";
            }
            if (message.cHostUserTake != null && message.hasOwnProperty("cHostUserTake")) {
                object.cHostUserTake = $root.NT.ClientHostUserTake.toObject(message.cHostUserTake, options);
                if (options.oneofs)
                    object.action = "cHostUserTake";
            }
            if (message.sHostUserTake != null && message.hasOwnProperty("sHostUserTake")) {
                object.sHostUserTake = $root.NT.ServerHostUserTake.toObject(message.sHostUserTake, options);
                if (options.oneofs)
                    object.action = "sHostUserTake";
            }
            if (message.cHostUserTakeGold != null && message.hasOwnProperty("cHostUserTakeGold")) {
                object.cHostUserTakeGold = $root.NT.ClientHostUserTakeGold.toObject(message.cHostUserTakeGold, options);
                if (options.oneofs)
                    object.action = "cHostUserTakeGold";
            }
            if (message.sHostUserTakeGold != null && message.hasOwnProperty("sHostUserTakeGold")) {
                object.sHostUserTakeGold = $root.NT.ServerHostUserTakeGold.toObject(message.sHostUserTakeGold, options);
                if (options.oneofs)
                    object.action = "sHostUserTakeGold";
            }
            if (message.cPlayerAddGold != null && message.hasOwnProperty("cPlayerAddGold")) {
                object.cPlayerAddGold = $root.NT.ClientPlayerAddGold.toObject(message.cPlayerAddGold, options);
                if (options.oneofs)
                    object.action = "cPlayerAddGold";
            }
            if (message.sPlayerAddGold != null && message.hasOwnProperty("sPlayerAddGold")) {
                object.sPlayerAddGold = $root.NT.ServerPlayerAddGold.toObject(message.sPlayerAddGold, options);
                if (options.oneofs)
                    object.action = "sPlayerAddGold";
            }
            if (message.cPlayerTakeGold != null && message.hasOwnProperty("cPlayerTakeGold")) {
                object.cPlayerTakeGold = $root.NT.ClientPlayerTakeGold.toObject(message.cPlayerTakeGold, options);
                if (options.oneofs)
                    object.action = "cPlayerTakeGold";
            }
            if (message.sPlayerTakeGold != null && message.hasOwnProperty("sPlayerTakeGold")) {
                object.sPlayerTakeGold = $root.NT.ServerPlayerTakeGold.toObject(message.sPlayerTakeGold, options);
                if (options.oneofs)
                    object.action = "sPlayerTakeGold";
            }
            if (message.cPlayerAddItem != null && message.hasOwnProperty("cPlayerAddItem")) {
                object.cPlayerAddItem = $root.NT.ClientPlayerAddItem.toObject(message.cPlayerAddItem, options);
                if (options.oneofs)
                    object.action = "cPlayerAddItem";
            }
            if (message.sPlayerAddItem != null && message.hasOwnProperty("sPlayerAddItem")) {
                object.sPlayerAddItem = $root.NT.ServerPlayerAddItem.toObject(message.sPlayerAddItem, options);
                if (options.oneofs)
                    object.action = "sPlayerAddItem";
            }
            if (message.cPlayerTakeItem != null && message.hasOwnProperty("cPlayerTakeItem")) {
                object.cPlayerTakeItem = $root.NT.ClientPlayerTakeItem.toObject(message.cPlayerTakeItem, options);
                if (options.oneofs)
                    object.action = "cPlayerTakeItem";
            }
            if (message.sPlayerTakeItem != null && message.hasOwnProperty("sPlayerTakeItem")) {
                object.sPlayerTakeItem = $root.NT.ServerPlayerTakeItem.toObject(message.sPlayerTakeItem, options);
                if (options.oneofs)
                    object.action = "sPlayerTakeItem";
            }
            if (message.cPlayerPickup != null && message.hasOwnProperty("cPlayerPickup")) {
                object.cPlayerPickup = $root.NT.ClientPlayerPickup.toObject(message.cPlayerPickup, options);
                if (options.oneofs)
                    object.action = "cPlayerPickup";
            }
            if (message.sPlayerPickup != null && message.hasOwnProperty("sPlayerPickup")) {
                object.sPlayerPickup = $root.NT.ServerPlayerPickup.toObject(message.sPlayerPickup, options);
                if (options.oneofs)
                    object.action = "sPlayerPickup";
            }
            if (message.cNemesisAbility != null && message.hasOwnProperty("cNemesisAbility")) {
                object.cNemesisAbility = $root.NT.ClientNemesisAbility.toObject(message.cNemesisAbility, options);
                if (options.oneofs)
                    object.action = "cNemesisAbility";
            }
            if (message.sNemesisAbility != null && message.hasOwnProperty("sNemesisAbility")) {
                object.sNemesisAbility = $root.NT.ServerNemesisAbility.toObject(message.sNemesisAbility, options);
                if (options.oneofs)
                    object.action = "sNemesisAbility";
            }
            if (message.cNemesisPickupItem != null && message.hasOwnProperty("cNemesisPickupItem")) {
                object.cNemesisPickupItem = $root.NT.ClientNemesisPickupItem.toObject(message.cNemesisPickupItem, options);
                if (options.oneofs)
                    object.action = "cNemesisPickupItem";
            }
            if (message.sNemesisPickupItem != null && message.hasOwnProperty("sNemesisPickupItem")) {
                object.sNemesisPickupItem = $root.NT.ServerNemesisPickupItem.toObject(message.sNemesisPickupItem, options);
                if (options.oneofs)
                    object.action = "sNemesisPickupItem";
            }
            if (message.cChat != null && message.hasOwnProperty("cChat")) {
                object.cChat = $root.NT.ClientChat.toObject(message.cChat, options);
                if (options.oneofs)
                    object.action = "cChat";
            }
            if (message.sChat != null && message.hasOwnProperty("sChat")) {
                object.sChat = $root.NT.ServerChat.toObject(message.sChat, options);
                if (options.oneofs)
                    object.action = "sChat";
            }
            if (message.cPlayerDeath != null && message.hasOwnProperty("cPlayerDeath")) {
                object.cPlayerDeath = $root.NT.ClientPlayerDeath.toObject(message.cPlayerDeath, options);
                if (options.oneofs)
                    object.action = "cPlayerDeath";
            }
            if (message.sPlayerDeath != null && message.hasOwnProperty("sPlayerDeath")) {
                object.sPlayerDeath = $root.NT.ServerPlayerDeath.toObject(message.sPlayerDeath, options);
                if (options.oneofs)
                    object.action = "sPlayerDeath";
            }
            if (message.cPlayerNewGamePlus != null && message.hasOwnProperty("cPlayerNewGamePlus")) {
                object.cPlayerNewGamePlus = $root.NT.ClientPlayerNewGamePlus.toObject(message.cPlayerNewGamePlus, options);
                if (options.oneofs)
                    object.action = "cPlayerNewGamePlus";
            }
            if (message.sPlayerNewGamePlus != null && message.hasOwnProperty("sPlayerNewGamePlus")) {
                object.sPlayerNewGamePlus = $root.NT.ServerPlayerNewGamePlus.toObject(message.sPlayerNewGamePlus, options);
                if (options.oneofs)
                    object.action = "sPlayerNewGamePlus";
            }
            if (message.cPlayerSecretHourglass != null && message.hasOwnProperty("cPlayerSecretHourglass")) {
                object.cPlayerSecretHourglass = $root.NT.ClientPlayerSecretHourglass.toObject(message.cPlayerSecretHourglass, options);
                if (options.oneofs)
                    object.action = "cPlayerSecretHourglass";
            }
            if (message.sPlayerSecretHourglass != null && message.hasOwnProperty("sPlayerSecretHourglass")) {
                object.sPlayerSecretHourglass = $root.NT.ServerPlayerSecretHourglass.toObject(message.sPlayerSecretHourglass, options);
                if (options.oneofs)
                    object.action = "sPlayerSecretHourglass";
            }
            if (message.cCustomModEvent != null && message.hasOwnProperty("cCustomModEvent")) {
                object.cCustomModEvent = $root.NT.ClientCustomModEvent.toObject(message.cCustomModEvent, options);
                if (options.oneofs)
                    object.action = "cCustomModEvent";
            }
            if (message.sCustomModEvent != null && message.hasOwnProperty("sCustomModEvent")) {
                object.sCustomModEvent = $root.NT.ServerCustomModEvent.toObject(message.sCustomModEvent, options);
                if (options.oneofs)
                    object.action = "sCustomModEvent";
            }
            if (message.cRespawnPenalty != null && message.hasOwnProperty("cRespawnPenalty")) {
                object.cRespawnPenalty = $root.NT.ClientRespawnPenalty.toObject(message.cRespawnPenalty, options);
                if (options.oneofs)
                    object.action = "cRespawnPenalty";
            }
            if (message.sRespawnPenalty != null && message.hasOwnProperty("sRespawnPenalty")) {
                object.sRespawnPenalty = $root.NT.ServerRespawnPenalty.toObject(message.sRespawnPenalty, options);
                if (options.oneofs)
                    object.action = "sRespawnPenalty";
            }
            if (message.cAngerySteve != null && message.hasOwnProperty("cAngerySteve")) {
                object.cAngerySteve = $root.NT.ClientAngerySteve.toObject(message.cAngerySteve, options);
                if (options.oneofs)
                    object.action = "cAngerySteve";
            }
            if (message.sAngerySteve != null && message.hasOwnProperty("sAngerySteve")) {
                object.sAngerySteve = $root.NT.ServerAngerySteve.toObject(message.sAngerySteve, options);
                if (options.oneofs)
                    object.action = "sAngerySteve";
            }
            if (message.sStatUpdate != null && message.hasOwnProperty("sStatUpdate")) {
                object.sStatUpdate = $root.NT.ServerStatsUpdate.toObject(message.sStatUpdate, options);
                if (options.oneofs)
                    object.action = "sStatUpdate";
            }
            return object;
        };

        /**
         * Converts this GameAction to JSON.
         * @function toJSON
         * @memberof NT.GameAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        GameAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for GameAction
         * @function getTypeUrl
         * @memberof NT.GameAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        GameAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.GameAction";
        };

        return GameAction;
    })();

    NT.PlayerFrame = (function() {

        /**
         * Properties of a PlayerFrame.
         * @memberof NT
         * @interface IPlayerFrame
         * @property {number|null} [x] PlayerFrame x
         * @property {number|null} [y] PlayerFrame y
         * @property {number|null} [armR] PlayerFrame armR
         * @property {number|null} [armScaleY] PlayerFrame armScaleY
         * @property {number|null} [scaleX] PlayerFrame scaleX
         * @property {number|null} [anim] PlayerFrame anim
         * @property {number|null} [held] PlayerFrame held
         */

        /**
         * Constructs a new PlayerFrame.
         * @memberof NT
         * @classdesc Represents a PlayerFrame.
         * @implements IPlayerFrame
         * @constructor
         * @param {NT.IPlayerFrame=} [properties] Properties to set
         */
        function PlayerFrame(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerFrame x.
         * @member {number|null|undefined} x
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.x = null;

        /**
         * PlayerFrame y.
         * @member {number|null|undefined} y
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.y = null;

        /**
         * PlayerFrame armR.
         * @member {number|null|undefined} armR
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.armR = null;

        /**
         * PlayerFrame armScaleY.
         * @member {number|null|undefined} armScaleY
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.armScaleY = null;

        /**
         * PlayerFrame scaleX.
         * @member {number|null|undefined} scaleX
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.scaleX = null;

        /**
         * PlayerFrame anim.
         * @member {number|null|undefined} anim
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.anim = null;

        /**
         * PlayerFrame held.
         * @member {number|null|undefined} held
         * @memberof NT.PlayerFrame
         * @instance
         */
        PlayerFrame.prototype.held = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * PlayerFrame _x.
         * @member {"x"|undefined} _x
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_x", {
            get: $util.oneOfGetter($oneOfFields = ["x"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _y.
         * @member {"y"|undefined} _y
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_y", {
            get: $util.oneOfGetter($oneOfFields = ["y"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _armR.
         * @member {"armR"|undefined} _armR
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_armR", {
            get: $util.oneOfGetter($oneOfFields = ["armR"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _armScaleY.
         * @member {"armScaleY"|undefined} _armScaleY
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_armScaleY", {
            get: $util.oneOfGetter($oneOfFields = ["armScaleY"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _scaleX.
         * @member {"scaleX"|undefined} _scaleX
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_scaleX", {
            get: $util.oneOfGetter($oneOfFields = ["scaleX"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _anim.
         * @member {"anim"|undefined} _anim
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_anim", {
            get: $util.oneOfGetter($oneOfFields = ["anim"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * PlayerFrame _held.
         * @member {"held"|undefined} _held
         * @memberof NT.PlayerFrame
         * @instance
         */
        Object.defineProperty(PlayerFrame.prototype, "_held", {
            get: $util.oneOfGetter($oneOfFields = ["held"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new PlayerFrame instance using the specified properties.
         * @function create
         * @memberof NT.PlayerFrame
         * @static
         * @param {NT.IPlayerFrame=} [properties] Properties to set
         * @returns {NT.PlayerFrame} PlayerFrame instance
         */
        PlayerFrame.create = function create(properties) {
            return new PlayerFrame(properties);
        };

        /**
         * Encodes the specified PlayerFrame message. Does not implicitly {@link NT.PlayerFrame.verify|verify} messages.
         * @function encode
         * @memberof NT.PlayerFrame
         * @static
         * @param {NT.IPlayerFrame} message PlayerFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerFrame.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
            if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
            if (message.armR != null && Object.hasOwnProperty.call(message, "armR"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.armR);
            if (message.armScaleY != null && Object.hasOwnProperty.call(message, "armScaleY"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.armScaleY);
            if (message.scaleX != null && Object.hasOwnProperty.call(message, "scaleX"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.scaleX);
            if (message.anim != null && Object.hasOwnProperty.call(message, "anim"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.anim);
            if (message.held != null && Object.hasOwnProperty.call(message, "held"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.held);
            return writer;
        };

        /**
         * Encodes the specified PlayerFrame message, length delimited. Does not implicitly {@link NT.PlayerFrame.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.PlayerFrame
         * @static
         * @param {NT.IPlayerFrame} message PlayerFrame message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerFrame.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerFrame message from the specified reader or buffer.
         * @function decode
         * @memberof NT.PlayerFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.PlayerFrame} PlayerFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerFrame.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.PlayerFrame();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.x = reader.float();
                        break;
                    }
                case 2: {
                        message.y = reader.float();
                        break;
                    }
                case 3: {
                        message.armR = reader.float();
                        break;
                    }
                case 4: {
                        message.armScaleY = reader.float();
                        break;
                    }
                case 5: {
                        message.scaleX = reader.float();
                        break;
                    }
                case 6: {
                        message.anim = reader.int32();
                        break;
                    }
                case 7: {
                        message.held = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerFrame message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.PlayerFrame
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.PlayerFrame} PlayerFrame
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerFrame.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerFrame message.
         * @function verify
         * @memberof NT.PlayerFrame
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerFrame.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.x != null && message.hasOwnProperty("x")) {
                properties._x = 1;
                if (typeof message.x !== "number")
                    return "x: number expected";
            }
            if (message.y != null && message.hasOwnProperty("y")) {
                properties._y = 1;
                if (typeof message.y !== "number")
                    return "y: number expected";
            }
            if (message.armR != null && message.hasOwnProperty("armR")) {
                properties._armR = 1;
                if (typeof message.armR !== "number")
                    return "armR: number expected";
            }
            if (message.armScaleY != null && message.hasOwnProperty("armScaleY")) {
                properties._armScaleY = 1;
                if (typeof message.armScaleY !== "number")
                    return "armScaleY: number expected";
            }
            if (message.scaleX != null && message.hasOwnProperty("scaleX")) {
                properties._scaleX = 1;
                if (typeof message.scaleX !== "number")
                    return "scaleX: number expected";
            }
            if (message.anim != null && message.hasOwnProperty("anim")) {
                properties._anim = 1;
                if (!$util.isInteger(message.anim))
                    return "anim: integer expected";
            }
            if (message.held != null && message.hasOwnProperty("held")) {
                properties._held = 1;
                if (!$util.isInteger(message.held))
                    return "held: integer expected";
            }
            return null;
        };

        /**
         * Creates a PlayerFrame message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.PlayerFrame
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.PlayerFrame} PlayerFrame
         */
        PlayerFrame.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.PlayerFrame)
                return object;
            let message = new $root.NT.PlayerFrame();
            if (object.x != null)
                message.x = Number(object.x);
            if (object.y != null)
                message.y = Number(object.y);
            if (object.armR != null)
                message.armR = Number(object.armR);
            if (object.armScaleY != null)
                message.armScaleY = Number(object.armScaleY);
            if (object.scaleX != null)
                message.scaleX = Number(object.scaleX);
            if (object.anim != null)
                message.anim = object.anim | 0;
            if (object.held != null)
                message.held = object.held | 0;
            return message;
        };

        /**
         * Creates a plain object from a PlayerFrame message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.PlayerFrame
         * @static
         * @param {NT.PlayerFrame} message PlayerFrame
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        PlayerFrame.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.x != null && message.hasOwnProperty("x")) {
                object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (options.oneofs)
                    object._x = "x";
            }
            if (message.y != null && message.hasOwnProperty("y")) {
                object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                if (options.oneofs)
                    object._y = "y";
            }
            if (message.armR != null && message.hasOwnProperty("armR")) {
                object.armR = options.json && !isFinite(message.armR) ? String(message.armR) : message.armR;
                if (options.oneofs)
                    object._armR = "armR";
            }
            if (message.armScaleY != null && message.hasOwnProperty("armScaleY")) {
                object.armScaleY = options.json && !isFinite(message.armScaleY) ? String(message.armScaleY) : message.armScaleY;
                if (options.oneofs)
                    object._armScaleY = "armScaleY";
            }
            if (message.scaleX != null && message.hasOwnProperty("scaleX")) {
                object.scaleX = options.json && !isFinite(message.scaleX) ? String(message.scaleX) : message.scaleX;
                if (options.oneofs)
                    object._scaleX = "scaleX";
            }
            if (message.anim != null && message.hasOwnProperty("anim")) {
                object.anim = message.anim;
                if (options.oneofs)
                    object._anim = "anim";
            }
            if (message.held != null && message.hasOwnProperty("held")) {
                object.held = message.held;
                if (options.oneofs)
                    object._held = "held";
            }
            return object;
        };

        /**
         * Converts this PlayerFrame to JSON.
         * @function toJSON
         * @memberof NT.PlayerFrame
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        PlayerFrame.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for PlayerFrame
         * @function getTypeUrl
         * @memberof NT.PlayerFrame
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        PlayerFrame.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.PlayerFrame";
        };

        return PlayerFrame;
    })();

    NT.OldClientPlayerMove = (function() {

        /**
         * Properties of an OldClientPlayerMove.
         * @memberof NT
         * @interface IOldClientPlayerMove
         * @property {Array.<NT.IPlayerFrame>|null} [frames] OldClientPlayerMove frames
         */

        /**
         * Constructs a new OldClientPlayerMove.
         * @memberof NT
         * @classdesc Represents an OldClientPlayerMove.
         * @implements IOldClientPlayerMove
         * @constructor
         * @param {NT.IOldClientPlayerMove=} [properties] Properties to set
         */
        function OldClientPlayerMove(properties) {
            this.frames = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OldClientPlayerMove frames.
         * @member {Array.<NT.IPlayerFrame>} frames
         * @memberof NT.OldClientPlayerMove
         * @instance
         */
        OldClientPlayerMove.prototype.frames = $util.emptyArray;

        /**
         * Creates a new OldClientPlayerMove instance using the specified properties.
         * @function create
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {NT.IOldClientPlayerMove=} [properties] Properties to set
         * @returns {NT.OldClientPlayerMove} OldClientPlayerMove instance
         */
        OldClientPlayerMove.create = function create(properties) {
            return new OldClientPlayerMove(properties);
        };

        /**
         * Encodes the specified OldClientPlayerMove message. Does not implicitly {@link NT.OldClientPlayerMove.verify|verify} messages.
         * @function encode
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {NT.IOldClientPlayerMove} message OldClientPlayerMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OldClientPlayerMove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frames != null && message.frames.length)
                for (let i = 0; i < message.frames.length; ++i)
                    $root.NT.PlayerFrame.encode(message.frames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OldClientPlayerMove message, length delimited. Does not implicitly {@link NT.OldClientPlayerMove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {NT.IOldClientPlayerMove} message OldClientPlayerMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OldClientPlayerMove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OldClientPlayerMove message from the specified reader or buffer.
         * @function decode
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.OldClientPlayerMove} OldClientPlayerMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OldClientPlayerMove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.OldClientPlayerMove();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.NT.PlayerFrame.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OldClientPlayerMove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.OldClientPlayerMove} OldClientPlayerMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OldClientPlayerMove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OldClientPlayerMove message.
         * @function verify
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OldClientPlayerMove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (let i = 0; i < message.frames.length; ++i) {
                    let error = $root.NT.PlayerFrame.verify(message.frames[i]);
                    if (error)
                        return "frames." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OldClientPlayerMove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.OldClientPlayerMove} OldClientPlayerMove
         */
        OldClientPlayerMove.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.OldClientPlayerMove)
                return object;
            let message = new $root.NT.OldClientPlayerMove();
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".NT.OldClientPlayerMove.frames: array expected");
                message.frames = [];
                for (let i = 0; i < object.frames.length; ++i) {
                    if (typeof object.frames[i] !== "object")
                        throw TypeError(".NT.OldClientPlayerMove.frames: object expected");
                    message.frames[i] = $root.NT.PlayerFrame.fromObject(object.frames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OldClientPlayerMove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {NT.OldClientPlayerMove} message OldClientPlayerMove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OldClientPlayerMove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.frames = [];
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (let j = 0; j < message.frames.length; ++j)
                    object.frames[j] = $root.NT.PlayerFrame.toObject(message.frames[j], options);
            }
            return object;
        };

        /**
         * Converts this OldClientPlayerMove to JSON.
         * @function toJSON
         * @memberof NT.OldClientPlayerMove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OldClientPlayerMove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OldClientPlayerMove
         * @function getTypeUrl
         * @memberof NT.OldClientPlayerMove
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OldClientPlayerMove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.OldClientPlayerMove";
        };

        return OldClientPlayerMove;
    })();

    NT.OldServerPlayerMove = (function() {

        /**
         * Properties of an OldServerPlayerMove.
         * @memberof NT
         * @interface IOldServerPlayerMove
         * @property {string|null} [userId] OldServerPlayerMove userId
         * @property {Array.<NT.IPlayerFrame>|null} [frames] OldServerPlayerMove frames
         */

        /**
         * Constructs a new OldServerPlayerMove.
         * @memberof NT
         * @classdesc Represents an OldServerPlayerMove.
         * @implements IOldServerPlayerMove
         * @constructor
         * @param {NT.IOldServerPlayerMove=} [properties] Properties to set
         */
        function OldServerPlayerMove(properties) {
            this.frames = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OldServerPlayerMove userId.
         * @member {string} userId
         * @memberof NT.OldServerPlayerMove
         * @instance
         */
        OldServerPlayerMove.prototype.userId = "";

        /**
         * OldServerPlayerMove frames.
         * @member {Array.<NT.IPlayerFrame>} frames
         * @memberof NT.OldServerPlayerMove
         * @instance
         */
        OldServerPlayerMove.prototype.frames = $util.emptyArray;

        /**
         * Creates a new OldServerPlayerMove instance using the specified properties.
         * @function create
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {NT.IOldServerPlayerMove=} [properties] Properties to set
         * @returns {NT.OldServerPlayerMove} OldServerPlayerMove instance
         */
        OldServerPlayerMove.create = function create(properties) {
            return new OldServerPlayerMove(properties);
        };

        /**
         * Encodes the specified OldServerPlayerMove message. Does not implicitly {@link NT.OldServerPlayerMove.verify|verify} messages.
         * @function encode
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {NT.IOldServerPlayerMove} message OldServerPlayerMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OldServerPlayerMove.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.frames != null && message.frames.length)
                for (let i = 0; i < message.frames.length; ++i)
                    $root.NT.PlayerFrame.encode(message.frames[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OldServerPlayerMove message, length delimited. Does not implicitly {@link NT.OldServerPlayerMove.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {NT.IOldServerPlayerMove} message OldServerPlayerMove message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OldServerPlayerMove.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OldServerPlayerMove message from the specified reader or buffer.
         * @function decode
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.OldServerPlayerMove} OldServerPlayerMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OldServerPlayerMove.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.OldServerPlayerMove();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.frames && message.frames.length))
                            message.frames = [];
                        message.frames.push($root.NT.PlayerFrame.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OldServerPlayerMove message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.OldServerPlayerMove} OldServerPlayerMove
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OldServerPlayerMove.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OldServerPlayerMove message.
         * @function verify
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OldServerPlayerMove.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.frames != null && message.hasOwnProperty("frames")) {
                if (!Array.isArray(message.frames))
                    return "frames: array expected";
                for (let i = 0; i < message.frames.length; ++i) {
                    let error = $root.NT.PlayerFrame.verify(message.frames[i]);
                    if (error)
                        return "frames." + error;
                }
            }
            return null;
        };

        /**
         * Creates an OldServerPlayerMove message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.OldServerPlayerMove} OldServerPlayerMove
         */
        OldServerPlayerMove.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.OldServerPlayerMove)
                return object;
            let message = new $root.NT.OldServerPlayerMove();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.frames) {
                if (!Array.isArray(object.frames))
                    throw TypeError(".NT.OldServerPlayerMove.frames: array expected");
                message.frames = [];
                for (let i = 0; i < object.frames.length; ++i) {
                    if (typeof object.frames[i] !== "object")
                        throw TypeError(".NT.OldServerPlayerMove.frames: object expected");
                    message.frames[i] = $root.NT.PlayerFrame.fromObject(object.frames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an OldServerPlayerMove message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {NT.OldServerPlayerMove} message OldServerPlayerMove
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OldServerPlayerMove.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.frames = [];
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.frames && message.frames.length) {
                object.frames = [];
                for (let j = 0; j < message.frames.length; ++j)
                    object.frames[j] = $root.NT.PlayerFrame.toObject(message.frames[j], options);
            }
            return object;
        };

        /**
         * Converts this OldServerPlayerMove to JSON.
         * @function toJSON
         * @memberof NT.OldServerPlayerMove
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OldServerPlayerMove.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OldServerPlayerMove
         * @function getTypeUrl
         * @memberof NT.OldServerPlayerMove
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OldServerPlayerMove.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.OldServerPlayerMove";
        };

        return OldServerPlayerMove;
    })();

    NT.CompactPlayerFrames = (function() {

        /**
         * Properties of a CompactPlayerFrames.
         * @memberof NT
         * @interface ICompactPlayerFrames
         * @property {number|null} [xInit] CompactPlayerFrames xInit
         * @property {number|null} [yInit] CompactPlayerFrames yInit
         * @property {Array.<number>|null} [xDeltas] CompactPlayerFrames xDeltas
         * @property {Array.<number>|null} [yDeltas] CompactPlayerFrames yDeltas
         * @property {Array.<number>|null} [armR] CompactPlayerFrames armR
         * @property {number|null} [armScaleY] CompactPlayerFrames armScaleY
         * @property {number|null} [scaleX] CompactPlayerFrames scaleX
         * @property {Array.<number>|null} [animIdx] CompactPlayerFrames animIdx
         * @property {Array.<number>|null} [animVal] CompactPlayerFrames animVal
         * @property {Array.<number>|null} [heldIdx] CompactPlayerFrames heldIdx
         * @property {Array.<number>|null} [heldVal] CompactPlayerFrames heldVal
         * @property {string|null} [userId] CompactPlayerFrames userId
         */

        /**
         * Constructs a new CompactPlayerFrames.
         * @memberof NT
         * @classdesc Represents a CompactPlayerFrames.
         * @implements ICompactPlayerFrames
         * @constructor
         * @param {NT.ICompactPlayerFrames=} [properties] Properties to set
         */
        function CompactPlayerFrames(properties) {
            this.xDeltas = [];
            this.yDeltas = [];
            this.armR = [];
            this.animIdx = [];
            this.animVal = [];
            this.heldIdx = [];
            this.heldVal = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CompactPlayerFrames xInit.
         * @member {number} xInit
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.xInit = 0;

        /**
         * CompactPlayerFrames yInit.
         * @member {number} yInit
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.yInit = 0;

        /**
         * CompactPlayerFrames xDeltas.
         * @member {Array.<number>} xDeltas
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.xDeltas = $util.emptyArray;

        /**
         * CompactPlayerFrames yDeltas.
         * @member {Array.<number>} yDeltas
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.yDeltas = $util.emptyArray;

        /**
         * CompactPlayerFrames armR.
         * @member {Array.<number>} armR
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.armR = $util.emptyArray;

        /**
         * CompactPlayerFrames armScaleY.
         * @member {number} armScaleY
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.armScaleY = 0;

        /**
         * CompactPlayerFrames scaleX.
         * @member {number} scaleX
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.scaleX = 0;

        /**
         * CompactPlayerFrames animIdx.
         * @member {Array.<number>} animIdx
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.animIdx = $util.emptyArray;

        /**
         * CompactPlayerFrames animVal.
         * @member {Array.<number>} animVal
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.animVal = $util.emptyArray;

        /**
         * CompactPlayerFrames heldIdx.
         * @member {Array.<number>} heldIdx
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.heldIdx = $util.emptyArray;

        /**
         * CompactPlayerFrames heldVal.
         * @member {Array.<number>} heldVal
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.heldVal = $util.emptyArray;

        /**
         * CompactPlayerFrames userId.
         * @member {string} userId
         * @memberof NT.CompactPlayerFrames
         * @instance
         */
        CompactPlayerFrames.prototype.userId = "";

        /**
         * Creates a new CompactPlayerFrames instance using the specified properties.
         * @function create
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {NT.ICompactPlayerFrames=} [properties] Properties to set
         * @returns {NT.CompactPlayerFrames} CompactPlayerFrames instance
         */
        CompactPlayerFrames.create = function create(properties) {
            return new CompactPlayerFrames(properties);
        };

        /**
         * Encodes the specified CompactPlayerFrames message. Does not implicitly {@link NT.CompactPlayerFrames.verify|verify} messages.
         * @function encode
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {NT.ICompactPlayerFrames} message CompactPlayerFrames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompactPlayerFrames.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.xInit != null && Object.hasOwnProperty.call(message, "xInit"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.xInit);
            if (message.yInit != null && Object.hasOwnProperty.call(message, "yInit"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.yInit);
            if (message.xDeltas != null && message.xDeltas.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (let i = 0; i < message.xDeltas.length; ++i)
                    writer.sint32(message.xDeltas[i]);
                writer.ldelim();
            }
            if (message.yDeltas != null && message.yDeltas.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (let i = 0; i < message.yDeltas.length; ++i)
                    writer.sint32(message.yDeltas[i]);
                writer.ldelim();
            }
            if (message.armR != null && message.armR.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (let i = 0; i < message.armR.length; ++i)
                    writer.int32(message.armR[i]);
                writer.ldelim();
            }
            if (message.armScaleY != null && Object.hasOwnProperty.call(message, "armScaleY"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.armScaleY);
            if (message.scaleX != null && Object.hasOwnProperty.call(message, "scaleX"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.scaleX);
            if (message.animIdx != null && message.animIdx.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (let i = 0; i < message.animIdx.length; ++i)
                    writer.int32(message.animIdx[i]);
                writer.ldelim();
            }
            if (message.animVal != null && message.animVal.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (let i = 0; i < message.animVal.length; ++i)
                    writer.int32(message.animVal[i]);
                writer.ldelim();
            }
            if (message.heldIdx != null && message.heldIdx.length) {
                writer.uint32(/* id 10, wireType 2 =*/82).fork();
                for (let i = 0; i < message.heldIdx.length; ++i)
                    writer.int32(message.heldIdx[i]);
                writer.ldelim();
            }
            if (message.heldVal != null && message.heldVal.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (let i = 0; i < message.heldVal.length; ++i)
                    writer.int32(message.heldVal[i]);
                writer.ldelim();
            }
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified CompactPlayerFrames message, length delimited. Does not implicitly {@link NT.CompactPlayerFrames.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {NT.ICompactPlayerFrames} message CompactPlayerFrames message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CompactPlayerFrames.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CompactPlayerFrames message from the specified reader or buffer.
         * @function decode
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.CompactPlayerFrames} CompactPlayerFrames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompactPlayerFrames.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.CompactPlayerFrames();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.xInit = reader.float();
                        break;
                    }
                case 2: {
                        message.yInit = reader.float();
                        break;
                    }
                case 3: {
                        if (!(message.xDeltas && message.xDeltas.length))
                            message.xDeltas = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.xDeltas.push(reader.sint32());
                        } else
                            message.xDeltas.push(reader.sint32());
                        break;
                    }
                case 4: {
                        if (!(message.yDeltas && message.yDeltas.length))
                            message.yDeltas = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.yDeltas.push(reader.sint32());
                        } else
                            message.yDeltas.push(reader.sint32());
                        break;
                    }
                case 5: {
                        if (!(message.armR && message.armR.length))
                            message.armR = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.armR.push(reader.int32());
                        } else
                            message.armR.push(reader.int32());
                        break;
                    }
                case 6: {
                        message.armScaleY = reader.int32();
                        break;
                    }
                case 7: {
                        message.scaleX = reader.int32();
                        break;
                    }
                case 8: {
                        if (!(message.animIdx && message.animIdx.length))
                            message.animIdx = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.animIdx.push(reader.int32());
                        } else
                            message.animIdx.push(reader.int32());
                        break;
                    }
                case 9: {
                        if (!(message.animVal && message.animVal.length))
                            message.animVal = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.animVal.push(reader.int32());
                        } else
                            message.animVal.push(reader.int32());
                        break;
                    }
                case 10: {
                        if (!(message.heldIdx && message.heldIdx.length))
                            message.heldIdx = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heldIdx.push(reader.int32());
                        } else
                            message.heldIdx.push(reader.int32());
                        break;
                    }
                case 11: {
                        if (!(message.heldVal && message.heldVal.length))
                            message.heldVal = [];
                        if ((tag & 7) === 2) {
                            let end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.heldVal.push(reader.int32());
                        } else
                            message.heldVal.push(reader.int32());
                        break;
                    }
                case 15: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CompactPlayerFrames message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.CompactPlayerFrames} CompactPlayerFrames
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CompactPlayerFrames.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CompactPlayerFrames message.
         * @function verify
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CompactPlayerFrames.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.xInit != null && message.hasOwnProperty("xInit"))
                if (typeof message.xInit !== "number")
                    return "xInit: number expected";
            if (message.yInit != null && message.hasOwnProperty("yInit"))
                if (typeof message.yInit !== "number")
                    return "yInit: number expected";
            if (message.xDeltas != null && message.hasOwnProperty("xDeltas")) {
                if (!Array.isArray(message.xDeltas))
                    return "xDeltas: array expected";
                for (let i = 0; i < message.xDeltas.length; ++i)
                    if (!$util.isInteger(message.xDeltas[i]))
                        return "xDeltas: integer[] expected";
            }
            if (message.yDeltas != null && message.hasOwnProperty("yDeltas")) {
                if (!Array.isArray(message.yDeltas))
                    return "yDeltas: array expected";
                for (let i = 0; i < message.yDeltas.length; ++i)
                    if (!$util.isInteger(message.yDeltas[i]))
                        return "yDeltas: integer[] expected";
            }
            if (message.armR != null && message.hasOwnProperty("armR")) {
                if (!Array.isArray(message.armR))
                    return "armR: array expected";
                for (let i = 0; i < message.armR.length; ++i)
                    if (!$util.isInteger(message.armR[i]))
                        return "armR: integer[] expected";
            }
            if (message.armScaleY != null && message.hasOwnProperty("armScaleY"))
                if (!$util.isInteger(message.armScaleY))
                    return "armScaleY: integer expected";
            if (message.scaleX != null && message.hasOwnProperty("scaleX"))
                if (!$util.isInteger(message.scaleX))
                    return "scaleX: integer expected";
            if (message.animIdx != null && message.hasOwnProperty("animIdx")) {
                if (!Array.isArray(message.animIdx))
                    return "animIdx: array expected";
                for (let i = 0; i < message.animIdx.length; ++i)
                    if (!$util.isInteger(message.animIdx[i]))
                        return "animIdx: integer[] expected";
            }
            if (message.animVal != null && message.hasOwnProperty("animVal")) {
                if (!Array.isArray(message.animVal))
                    return "animVal: array expected";
                for (let i = 0; i < message.animVal.length; ++i)
                    if (!$util.isInteger(message.animVal[i]))
                        return "animVal: integer[] expected";
            }
            if (message.heldIdx != null && message.hasOwnProperty("heldIdx")) {
                if (!Array.isArray(message.heldIdx))
                    return "heldIdx: array expected";
                for (let i = 0; i < message.heldIdx.length; ++i)
                    if (!$util.isInteger(message.heldIdx[i]))
                        return "heldIdx: integer[] expected";
            }
            if (message.heldVal != null && message.hasOwnProperty("heldVal")) {
                if (!Array.isArray(message.heldVal))
                    return "heldVal: array expected";
                for (let i = 0; i < message.heldVal.length; ++i)
                    if (!$util.isInteger(message.heldVal[i]))
                        return "heldVal: integer[] expected";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a CompactPlayerFrames message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.CompactPlayerFrames} CompactPlayerFrames
         */
        CompactPlayerFrames.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.CompactPlayerFrames)
                return object;
            let message = new $root.NT.CompactPlayerFrames();
            if (object.xInit != null)
                message.xInit = Number(object.xInit);
            if (object.yInit != null)
                message.yInit = Number(object.yInit);
            if (object.xDeltas) {
                if (!Array.isArray(object.xDeltas))
                    throw TypeError(".NT.CompactPlayerFrames.xDeltas: array expected");
                message.xDeltas = [];
                for (let i = 0; i < object.xDeltas.length; ++i)
                    message.xDeltas[i] = object.xDeltas[i] | 0;
            }
            if (object.yDeltas) {
                if (!Array.isArray(object.yDeltas))
                    throw TypeError(".NT.CompactPlayerFrames.yDeltas: array expected");
                message.yDeltas = [];
                for (let i = 0; i < object.yDeltas.length; ++i)
                    message.yDeltas[i] = object.yDeltas[i] | 0;
            }
            if (object.armR) {
                if (!Array.isArray(object.armR))
                    throw TypeError(".NT.CompactPlayerFrames.armR: array expected");
                message.armR = [];
                for (let i = 0; i < object.armR.length; ++i)
                    message.armR[i] = object.armR[i] | 0;
            }
            if (object.armScaleY != null)
                message.armScaleY = object.armScaleY | 0;
            if (object.scaleX != null)
                message.scaleX = object.scaleX | 0;
            if (object.animIdx) {
                if (!Array.isArray(object.animIdx))
                    throw TypeError(".NT.CompactPlayerFrames.animIdx: array expected");
                message.animIdx = [];
                for (let i = 0; i < object.animIdx.length; ++i)
                    message.animIdx[i] = object.animIdx[i] | 0;
            }
            if (object.animVal) {
                if (!Array.isArray(object.animVal))
                    throw TypeError(".NT.CompactPlayerFrames.animVal: array expected");
                message.animVal = [];
                for (let i = 0; i < object.animVal.length; ++i)
                    message.animVal[i] = object.animVal[i] | 0;
            }
            if (object.heldIdx) {
                if (!Array.isArray(object.heldIdx))
                    throw TypeError(".NT.CompactPlayerFrames.heldIdx: array expected");
                message.heldIdx = [];
                for (let i = 0; i < object.heldIdx.length; ++i)
                    message.heldIdx[i] = object.heldIdx[i] | 0;
            }
            if (object.heldVal) {
                if (!Array.isArray(object.heldVal))
                    throw TypeError(".NT.CompactPlayerFrames.heldVal: array expected");
                message.heldVal = [];
                for (let i = 0; i < object.heldVal.length; ++i)
                    message.heldVal[i] = object.heldVal[i] | 0;
            }
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a CompactPlayerFrames message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {NT.CompactPlayerFrames} message CompactPlayerFrames
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CompactPlayerFrames.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.xDeltas = [];
                object.yDeltas = [];
                object.armR = [];
                object.animIdx = [];
                object.animVal = [];
                object.heldIdx = [];
                object.heldVal = [];
            }
            if (options.defaults) {
                object.xInit = 0;
                object.yInit = 0;
                object.armScaleY = 0;
                object.scaleX = 0;
                object.userId = "";
            }
            if (message.xInit != null && message.hasOwnProperty("xInit"))
                object.xInit = options.json && !isFinite(message.xInit) ? String(message.xInit) : message.xInit;
            if (message.yInit != null && message.hasOwnProperty("yInit"))
                object.yInit = options.json && !isFinite(message.yInit) ? String(message.yInit) : message.yInit;
            if (message.xDeltas && message.xDeltas.length) {
                object.xDeltas = [];
                for (let j = 0; j < message.xDeltas.length; ++j)
                    object.xDeltas[j] = message.xDeltas[j];
            }
            if (message.yDeltas && message.yDeltas.length) {
                object.yDeltas = [];
                for (let j = 0; j < message.yDeltas.length; ++j)
                    object.yDeltas[j] = message.yDeltas[j];
            }
            if (message.armR && message.armR.length) {
                object.armR = [];
                for (let j = 0; j < message.armR.length; ++j)
                    object.armR[j] = message.armR[j];
            }
            if (message.armScaleY != null && message.hasOwnProperty("armScaleY"))
                object.armScaleY = message.armScaleY;
            if (message.scaleX != null && message.hasOwnProperty("scaleX"))
                object.scaleX = message.scaleX;
            if (message.animIdx && message.animIdx.length) {
                object.animIdx = [];
                for (let j = 0; j < message.animIdx.length; ++j)
                    object.animIdx[j] = message.animIdx[j];
            }
            if (message.animVal && message.animVal.length) {
                object.animVal = [];
                for (let j = 0; j < message.animVal.length; ++j)
                    object.animVal[j] = message.animVal[j];
            }
            if (message.heldIdx && message.heldIdx.length) {
                object.heldIdx = [];
                for (let j = 0; j < message.heldIdx.length; ++j)
                    object.heldIdx[j] = message.heldIdx[j];
            }
            if (message.heldVal && message.heldVal.length) {
                object.heldVal = [];
                for (let j = 0; j < message.heldVal.length; ++j)
                    object.heldVal[j] = message.heldVal[j];
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this CompactPlayerFrames to JSON.
         * @function toJSON
         * @memberof NT.CompactPlayerFrames
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CompactPlayerFrames.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CompactPlayerFrames
         * @function getTypeUrl
         * @memberof NT.CompactPlayerFrames
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CompactPlayerFrames.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.CompactPlayerFrames";
        };

        return CompactPlayerFrames;
    })();

    NT.ServerPlayerMoves = (function() {

        /**
         * Properties of a ServerPlayerMoves.
         * @memberof NT
         * @interface IServerPlayerMoves
         * @property {Array.<NT.ICompactPlayerFrames>|null} [userFrames] ServerPlayerMoves userFrames
         */

        /**
         * Constructs a new ServerPlayerMoves.
         * @memberof NT
         * @classdesc Represents a ServerPlayerMoves.
         * @implements IServerPlayerMoves
         * @constructor
         * @param {NT.IServerPlayerMoves=} [properties] Properties to set
         */
        function ServerPlayerMoves(properties) {
            this.userFrames = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerMoves userFrames.
         * @member {Array.<NT.ICompactPlayerFrames>} userFrames
         * @memberof NT.ServerPlayerMoves
         * @instance
         */
        ServerPlayerMoves.prototype.userFrames = $util.emptyArray;

        /**
         * Creates a new ServerPlayerMoves instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {NT.IServerPlayerMoves=} [properties] Properties to set
         * @returns {NT.ServerPlayerMoves} ServerPlayerMoves instance
         */
        ServerPlayerMoves.create = function create(properties) {
            return new ServerPlayerMoves(properties);
        };

        /**
         * Encodes the specified ServerPlayerMoves message. Does not implicitly {@link NT.ServerPlayerMoves.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {NT.IServerPlayerMoves} message ServerPlayerMoves message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerMoves.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userFrames != null && message.userFrames.length)
                for (let i = 0; i < message.userFrames.length; ++i)
                    $root.NT.CompactPlayerFrames.encode(message.userFrames[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerMoves message, length delimited. Does not implicitly {@link NT.ServerPlayerMoves.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {NT.IServerPlayerMoves} message ServerPlayerMoves message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerMoves.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerMoves message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerMoves} ServerPlayerMoves
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerMoves.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerMoves();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.userFrames && message.userFrames.length))
                            message.userFrames = [];
                        message.userFrames.push($root.NT.CompactPlayerFrames.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerMoves message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerMoves} ServerPlayerMoves
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerMoves.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerMoves message.
         * @function verify
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerMoves.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userFrames != null && message.hasOwnProperty("userFrames")) {
                if (!Array.isArray(message.userFrames))
                    return "userFrames: array expected";
                for (let i = 0; i < message.userFrames.length; ++i) {
                    let error = $root.NT.CompactPlayerFrames.verify(message.userFrames[i]);
                    if (error)
                        return "userFrames." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerPlayerMoves message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerMoves} ServerPlayerMoves
         */
        ServerPlayerMoves.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerMoves)
                return object;
            let message = new $root.NT.ServerPlayerMoves();
            if (object.userFrames) {
                if (!Array.isArray(object.userFrames))
                    throw TypeError(".NT.ServerPlayerMoves.userFrames: array expected");
                message.userFrames = [];
                for (let i = 0; i < object.userFrames.length; ++i) {
                    if (typeof object.userFrames[i] !== "object")
                        throw TypeError(".NT.ServerPlayerMoves.userFrames: object expected");
                    message.userFrames[i] = $root.NT.CompactPlayerFrames.fromObject(object.userFrames[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerMoves message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {NT.ServerPlayerMoves} message ServerPlayerMoves
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerMoves.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.userFrames = [];
            if (message.userFrames && message.userFrames.length) {
                object.userFrames = [];
                for (let j = 0; j < message.userFrames.length; ++j)
                    object.userFrames[j] = $root.NT.CompactPlayerFrames.toObject(message.userFrames[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerPlayerMoves to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerMoves
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerMoves.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerMoves
         * @function getTypeUrl
         * @memberof NT.ServerPlayerMoves
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerMoves.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerMoves";
        };

        return ServerPlayerMoves;
    })();

    NT.ClientPlayerUpdate = (function() {

        /**
         * Properties of a ClientPlayerUpdate.
         * @memberof NT
         * @interface IClientPlayerUpdate
         * @property {number|null} [curHp] ClientPlayerUpdate curHp
         * @property {number|null} [maxHp] ClientPlayerUpdate maxHp
         * @property {string|null} [location] ClientPlayerUpdate location
         * @property {boolean|null} [sampo] ClientPlayerUpdate sampo
         */

        /**
         * Constructs a new ClientPlayerUpdate.
         * @memberof NT
         * @classdesc Represents a ClientPlayerUpdate.
         * @implements IClientPlayerUpdate
         * @constructor
         * @param {NT.IClientPlayerUpdate=} [properties] Properties to set
         */
        function ClientPlayerUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerUpdate curHp.
         * @member {number|null|undefined} curHp
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        ClientPlayerUpdate.prototype.curHp = null;

        /**
         * ClientPlayerUpdate maxHp.
         * @member {number|null|undefined} maxHp
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        ClientPlayerUpdate.prototype.maxHp = null;

        /**
         * ClientPlayerUpdate location.
         * @member {string|null|undefined} location
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        ClientPlayerUpdate.prototype.location = null;

        /**
         * ClientPlayerUpdate sampo.
         * @member {boolean|null|undefined} sampo
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        ClientPlayerUpdate.prototype.sampo = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientPlayerUpdate _curHp.
         * @member {"curHp"|undefined} _curHp
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        Object.defineProperty(ClientPlayerUpdate.prototype, "_curHp", {
            get: $util.oneOfGetter($oneOfFields = ["curHp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientPlayerUpdate _maxHp.
         * @member {"maxHp"|undefined} _maxHp
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        Object.defineProperty(ClientPlayerUpdate.prototype, "_maxHp", {
            get: $util.oneOfGetter($oneOfFields = ["maxHp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientPlayerUpdate _location.
         * @member {"location"|undefined} _location
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        Object.defineProperty(ClientPlayerUpdate.prototype, "_location", {
            get: $util.oneOfGetter($oneOfFields = ["location"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientPlayerUpdate _sampo.
         * @member {"sampo"|undefined} _sampo
         * @memberof NT.ClientPlayerUpdate
         * @instance
         */
        Object.defineProperty(ClientPlayerUpdate.prototype, "_sampo", {
            get: $util.oneOfGetter($oneOfFields = ["sampo"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientPlayerUpdate instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {NT.IClientPlayerUpdate=} [properties] Properties to set
         * @returns {NT.ClientPlayerUpdate} ClientPlayerUpdate instance
         */
        ClientPlayerUpdate.create = function create(properties) {
            return new ClientPlayerUpdate(properties);
        };

        /**
         * Encodes the specified ClientPlayerUpdate message. Does not implicitly {@link NT.ClientPlayerUpdate.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {NT.IClientPlayerUpdate} message ClientPlayerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.curHp != null && Object.hasOwnProperty.call(message, "curHp"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.curHp);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.maxHp);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.location);
            if (message.sampo != null && Object.hasOwnProperty.call(message, "sampo"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.sampo);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerUpdate message, length delimited. Does not implicitly {@link NT.ClientPlayerUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {NT.IClientPlayerUpdate} message ClientPlayerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerUpdate} ClientPlayerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.curHp = reader.float();
                        break;
                    }
                case 2: {
                        message.maxHp = reader.float();
                        break;
                    }
                case 3: {
                        message.location = reader.string();
                        break;
                    }
                case 4: {
                        message.sampo = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerUpdate} ClientPlayerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerUpdate message.
         * @function verify
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.curHp != null && message.hasOwnProperty("curHp")) {
                properties._curHp = 1;
                if (typeof message.curHp !== "number")
                    return "curHp: number expected";
            }
            if (message.maxHp != null && message.hasOwnProperty("maxHp")) {
                properties._maxHp = 1;
                if (typeof message.maxHp !== "number")
                    return "maxHp: number expected";
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                properties._location = 1;
                if (!$util.isString(message.location))
                    return "location: string expected";
            }
            if (message.sampo != null && message.hasOwnProperty("sampo")) {
                properties._sampo = 1;
                if (typeof message.sampo !== "boolean")
                    return "sampo: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ClientPlayerUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerUpdate} ClientPlayerUpdate
         */
        ClientPlayerUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerUpdate)
                return object;
            let message = new $root.NT.ClientPlayerUpdate();
            if (object.curHp != null)
                message.curHp = Number(object.curHp);
            if (object.maxHp != null)
                message.maxHp = Number(object.maxHp);
            if (object.location != null)
                message.location = String(object.location);
            if (object.sampo != null)
                message.sampo = Boolean(object.sampo);
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {NT.ClientPlayerUpdate} message ClientPlayerUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.curHp != null && message.hasOwnProperty("curHp")) {
                object.curHp = options.json && !isFinite(message.curHp) ? String(message.curHp) : message.curHp;
                if (options.oneofs)
                    object._curHp = "curHp";
            }
            if (message.maxHp != null && message.hasOwnProperty("maxHp")) {
                object.maxHp = options.json && !isFinite(message.maxHp) ? String(message.maxHp) : message.maxHp;
                if (options.oneofs)
                    object._maxHp = "maxHp";
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                object.location = message.location;
                if (options.oneofs)
                    object._location = "location";
            }
            if (message.sampo != null && message.hasOwnProperty("sampo")) {
                object.sampo = message.sampo;
                if (options.oneofs)
                    object._sampo = "sampo";
            }
            return object;
        };

        /**
         * Converts this ClientPlayerUpdate to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerUpdate
         * @function getTypeUrl
         * @memberof NT.ClientPlayerUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerUpdate";
        };

        return ClientPlayerUpdate;
    })();

    NT.ServerPlayerUpdate = (function() {

        /**
         * Properties of a ServerPlayerUpdate.
         * @memberof NT
         * @interface IServerPlayerUpdate
         * @property {string|null} [userId] ServerPlayerUpdate userId
         * @property {number|null} [curHp] ServerPlayerUpdate curHp
         * @property {number|null} [maxHp] ServerPlayerUpdate maxHp
         * @property {string|null} [location] ServerPlayerUpdate location
         * @property {boolean|null} [sampo] ServerPlayerUpdate sampo
         */

        /**
         * Constructs a new ServerPlayerUpdate.
         * @memberof NT
         * @classdesc Represents a ServerPlayerUpdate.
         * @implements IServerPlayerUpdate
         * @constructor
         * @param {NT.IServerPlayerUpdate=} [properties] Properties to set
         */
        function ServerPlayerUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerUpdate userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        ServerPlayerUpdate.prototype.userId = "";

        /**
         * ServerPlayerUpdate curHp.
         * @member {number|null|undefined} curHp
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        ServerPlayerUpdate.prototype.curHp = null;

        /**
         * ServerPlayerUpdate maxHp.
         * @member {number|null|undefined} maxHp
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        ServerPlayerUpdate.prototype.maxHp = null;

        /**
         * ServerPlayerUpdate location.
         * @member {string|null|undefined} location
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        ServerPlayerUpdate.prototype.location = null;

        /**
         * ServerPlayerUpdate sampo.
         * @member {boolean|null|undefined} sampo
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        ServerPlayerUpdate.prototype.sampo = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerPlayerUpdate _curHp.
         * @member {"curHp"|undefined} _curHp
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        Object.defineProperty(ServerPlayerUpdate.prototype, "_curHp", {
            get: $util.oneOfGetter($oneOfFields = ["curHp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerPlayerUpdate _maxHp.
         * @member {"maxHp"|undefined} _maxHp
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        Object.defineProperty(ServerPlayerUpdate.prototype, "_maxHp", {
            get: $util.oneOfGetter($oneOfFields = ["maxHp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerPlayerUpdate _location.
         * @member {"location"|undefined} _location
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        Object.defineProperty(ServerPlayerUpdate.prototype, "_location", {
            get: $util.oneOfGetter($oneOfFields = ["location"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerPlayerUpdate _sampo.
         * @member {"sampo"|undefined} _sampo
         * @memberof NT.ServerPlayerUpdate
         * @instance
         */
        Object.defineProperty(ServerPlayerUpdate.prototype, "_sampo", {
            get: $util.oneOfGetter($oneOfFields = ["sampo"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerPlayerUpdate instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {NT.IServerPlayerUpdate=} [properties] Properties to set
         * @returns {NT.ServerPlayerUpdate} ServerPlayerUpdate instance
         */
        ServerPlayerUpdate.create = function create(properties) {
            return new ServerPlayerUpdate(properties);
        };

        /**
         * Encodes the specified ServerPlayerUpdate message. Does not implicitly {@link NT.ServerPlayerUpdate.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {NT.IServerPlayerUpdate} message ServerPlayerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.curHp != null && Object.hasOwnProperty.call(message, "curHp"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.curHp);
            if (message.maxHp != null && Object.hasOwnProperty.call(message, "maxHp"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.maxHp);
            if (message.location != null && Object.hasOwnProperty.call(message, "location"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.location);
            if (message.sampo != null && Object.hasOwnProperty.call(message, "sampo"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.sampo);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerUpdate message, length delimited. Does not implicitly {@link NT.ServerPlayerUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {NT.IServerPlayerUpdate} message ServerPlayerUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerUpdate} ServerPlayerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.curHp = reader.float();
                        break;
                    }
                case 3: {
                        message.maxHp = reader.float();
                        break;
                    }
                case 4: {
                        message.location = reader.string();
                        break;
                    }
                case 5: {
                        message.sampo = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerUpdate} ServerPlayerUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerUpdate message.
         * @function verify
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.curHp != null && message.hasOwnProperty("curHp")) {
                properties._curHp = 1;
                if (typeof message.curHp !== "number")
                    return "curHp: number expected";
            }
            if (message.maxHp != null && message.hasOwnProperty("maxHp")) {
                properties._maxHp = 1;
                if (typeof message.maxHp !== "number")
                    return "maxHp: number expected";
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                properties._location = 1;
                if (!$util.isString(message.location))
                    return "location: string expected";
            }
            if (message.sampo != null && message.hasOwnProperty("sampo")) {
                properties._sampo = 1;
                if (typeof message.sampo !== "boolean")
                    return "sampo: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ServerPlayerUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerUpdate} ServerPlayerUpdate
         */
        ServerPlayerUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerUpdate)
                return object;
            let message = new $root.NT.ServerPlayerUpdate();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.curHp != null)
                message.curHp = Number(object.curHp);
            if (object.maxHp != null)
                message.maxHp = Number(object.maxHp);
            if (object.location != null)
                message.location = String(object.location);
            if (object.sampo != null)
                message.sampo = Boolean(object.sampo);
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {NT.ServerPlayerUpdate} message ServerPlayerUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.curHp != null && message.hasOwnProperty("curHp")) {
                object.curHp = options.json && !isFinite(message.curHp) ? String(message.curHp) : message.curHp;
                if (options.oneofs)
                    object._curHp = "curHp";
            }
            if (message.maxHp != null && message.hasOwnProperty("maxHp")) {
                object.maxHp = options.json && !isFinite(message.maxHp) ? String(message.maxHp) : message.maxHp;
                if (options.oneofs)
                    object._maxHp = "maxHp";
            }
            if (message.location != null && message.hasOwnProperty("location")) {
                object.location = message.location;
                if (options.oneofs)
                    object._location = "location";
            }
            if (message.sampo != null && message.hasOwnProperty("sampo")) {
                object.sampo = message.sampo;
                if (options.oneofs)
                    object._sampo = "sampo";
            }
            return object;
        };

        /**
         * Converts this ServerPlayerUpdate to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerUpdate
         * @function getTypeUrl
         * @memberof NT.ServerPlayerUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerUpdate";
        };

        return ServerPlayerUpdate;
    })();

    NT.ClientPlayerUpdateInventory = (function() {

        /**
         * Properties of a ClientPlayerUpdateInventory.
         * @memberof NT
         * @interface IClientPlayerUpdateInventory
         * @property {Array.<NT.ClientPlayerUpdateInventory.IInventoryWand>|null} [wands] ClientPlayerUpdateInventory wands
         * @property {Array.<NT.ClientPlayerUpdateInventory.IInventoryItem>|null} [items] ClientPlayerUpdateInventory items
         * @property {Array.<NT.ClientPlayerUpdateInventory.IInventorySpell>|null} [spells] ClientPlayerUpdateInventory spells
         */

        /**
         * Constructs a new ClientPlayerUpdateInventory.
         * @memberof NT
         * @classdesc Represents a ClientPlayerUpdateInventory.
         * @implements IClientPlayerUpdateInventory
         * @constructor
         * @param {NT.IClientPlayerUpdateInventory=} [properties] Properties to set
         */
        function ClientPlayerUpdateInventory(properties) {
            this.wands = [];
            this.items = [];
            this.spells = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerUpdateInventory wands.
         * @member {Array.<NT.ClientPlayerUpdateInventory.IInventoryWand>} wands
         * @memberof NT.ClientPlayerUpdateInventory
         * @instance
         */
        ClientPlayerUpdateInventory.prototype.wands = $util.emptyArray;

        /**
         * ClientPlayerUpdateInventory items.
         * @member {Array.<NT.ClientPlayerUpdateInventory.IInventoryItem>} items
         * @memberof NT.ClientPlayerUpdateInventory
         * @instance
         */
        ClientPlayerUpdateInventory.prototype.items = $util.emptyArray;

        /**
         * ClientPlayerUpdateInventory spells.
         * @member {Array.<NT.ClientPlayerUpdateInventory.IInventorySpell>} spells
         * @memberof NT.ClientPlayerUpdateInventory
         * @instance
         */
        ClientPlayerUpdateInventory.prototype.spells = $util.emptyArray;

        /**
         * Creates a new ClientPlayerUpdateInventory instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {NT.IClientPlayerUpdateInventory=} [properties] Properties to set
         * @returns {NT.ClientPlayerUpdateInventory} ClientPlayerUpdateInventory instance
         */
        ClientPlayerUpdateInventory.create = function create(properties) {
            return new ClientPlayerUpdateInventory(properties);
        };

        /**
         * Encodes the specified ClientPlayerUpdateInventory message. Does not implicitly {@link NT.ClientPlayerUpdateInventory.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {NT.IClientPlayerUpdateInventory} message ClientPlayerUpdateInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerUpdateInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wands != null && message.wands.length)
                for (let i = 0; i < message.wands.length; ++i)
                    $root.NT.ClientPlayerUpdateInventory.InventoryWand.encode(message.wands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.NT.ClientPlayerUpdateInventory.InventoryItem.encode(message.items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.spells != null && message.spells.length)
                for (let i = 0; i < message.spells.length; ++i)
                    $root.NT.ClientPlayerUpdateInventory.InventorySpell.encode(message.spells[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerUpdateInventory message, length delimited. Does not implicitly {@link NT.ClientPlayerUpdateInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {NT.IClientPlayerUpdateInventory} message ClientPlayerUpdateInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerUpdateInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerUpdateInventory message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerUpdateInventory} ClientPlayerUpdateInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerUpdateInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerUpdateInventory();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.wands && message.wands.length))
                            message.wands = [];
                        message.wands.push($root.NT.ClientPlayerUpdateInventory.InventoryWand.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.NT.ClientPlayerUpdateInventory.InventoryItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.spells && message.spells.length))
                            message.spells = [];
                        message.spells.push($root.NT.ClientPlayerUpdateInventory.InventorySpell.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerUpdateInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerUpdateInventory} ClientPlayerUpdateInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerUpdateInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerUpdateInventory message.
         * @function verify
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerUpdateInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (!Array.isArray(message.wands))
                    return "wands: array expected";
                for (let i = 0; i < message.wands.length; ++i) {
                    let error = $root.NT.ClientPlayerUpdateInventory.InventoryWand.verify(message.wands[i]);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.NT.ClientPlayerUpdateInventory.InventoryItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.spells != null && message.hasOwnProperty("spells")) {
                if (!Array.isArray(message.spells))
                    return "spells: array expected";
                for (let i = 0; i < message.spells.length; ++i) {
                    let error = $root.NT.ClientPlayerUpdateInventory.InventorySpell.verify(message.spells[i]);
                    if (error)
                        return "spells." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientPlayerUpdateInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerUpdateInventory} ClientPlayerUpdateInventory
         */
        ClientPlayerUpdateInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerUpdateInventory)
                return object;
            let message = new $root.NT.ClientPlayerUpdateInventory();
            if (object.wands) {
                if (!Array.isArray(object.wands))
                    throw TypeError(".NT.ClientPlayerUpdateInventory.wands: array expected");
                message.wands = [];
                for (let i = 0; i < object.wands.length; ++i) {
                    if (typeof object.wands[i] !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.wands: object expected");
                    message.wands[i] = $root.NT.ClientPlayerUpdateInventory.InventoryWand.fromObject(object.wands[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".NT.ClientPlayerUpdateInventory.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.items: object expected");
                    message.items[i] = $root.NT.ClientPlayerUpdateInventory.InventoryItem.fromObject(object.items[i]);
                }
            }
            if (object.spells) {
                if (!Array.isArray(object.spells))
                    throw TypeError(".NT.ClientPlayerUpdateInventory.spells: array expected");
                message.spells = [];
                for (let i = 0; i < object.spells.length; ++i) {
                    if (typeof object.spells[i] !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.spells: object expected");
                    message.spells[i] = $root.NT.ClientPlayerUpdateInventory.InventorySpell.fromObject(object.spells[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerUpdateInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {NT.ClientPlayerUpdateInventory} message ClientPlayerUpdateInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerUpdateInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.wands = [];
                object.items = [];
                object.spells = [];
            }
            if (message.wands && message.wands.length) {
                object.wands = [];
                for (let j = 0; j < message.wands.length; ++j)
                    object.wands[j] = $root.NT.ClientPlayerUpdateInventory.InventoryWand.toObject(message.wands[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.NT.ClientPlayerUpdateInventory.InventoryItem.toObject(message.items[j], options);
            }
            if (message.spells && message.spells.length) {
                object.spells = [];
                for (let j = 0; j < message.spells.length; ++j)
                    object.spells[j] = $root.NT.ClientPlayerUpdateInventory.InventorySpell.toObject(message.spells[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientPlayerUpdateInventory to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerUpdateInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerUpdateInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerUpdateInventory
         * @function getTypeUrl
         * @memberof NT.ClientPlayerUpdateInventory
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerUpdateInventory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerUpdateInventory";
        };

        ClientPlayerUpdateInventory.InventoryWand = (function() {

            /**
             * Properties of an InventoryWand.
             * @memberof NT.ClientPlayerUpdateInventory
             * @interface IInventoryWand
             * @property {number|null} [index] InventoryWand index
             * @property {NT.IWand|null} [wand] InventoryWand wand
             */

            /**
             * Constructs a new InventoryWand.
             * @memberof NT.ClientPlayerUpdateInventory
             * @classdesc Represents an InventoryWand.
             * @implements IInventoryWand
             * @constructor
             * @param {NT.ClientPlayerUpdateInventory.IInventoryWand=} [properties] Properties to set
             */
            function InventoryWand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventoryWand index.
             * @member {number} index
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @instance
             */
            InventoryWand.prototype.index = 0;

            /**
             * InventoryWand wand.
             * @member {NT.IWand|null|undefined} wand
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @instance
             */
            InventoryWand.prototype.wand = null;

            /**
             * Creates a new InventoryWand instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryWand=} [properties] Properties to set
             * @returns {NT.ClientPlayerUpdateInventory.InventoryWand} InventoryWand instance
             */
            InventoryWand.create = function create(properties) {
                return new InventoryWand(properties);
            };

            /**
             * Encodes the specified InventoryWand message. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventoryWand.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryWand} message InventoryWand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryWand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.wand != null && Object.hasOwnProperty.call(message, "wand"))
                    $root.NT.Wand.encode(message.wand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventoryWand message, length delimited. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventoryWand.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryWand} message InventoryWand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryWand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventoryWand message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerUpdateInventory.InventoryWand} InventoryWand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryWand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerUpdateInventory.InventoryWand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.wand = $root.NT.Wand.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventoryWand message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerUpdateInventory.InventoryWand} InventoryWand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryWand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventoryWand message.
             * @function verify
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventoryWand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.wand != null && message.hasOwnProperty("wand")) {
                    let error = $root.NT.Wand.verify(message.wand);
                    if (error)
                        return "wand." + error;
                }
                return null;
            };

            /**
             * Creates an InventoryWand message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerUpdateInventory.InventoryWand} InventoryWand
             */
            InventoryWand.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerUpdateInventory.InventoryWand)
                    return object;
                let message = new $root.NT.ClientPlayerUpdateInventory.InventoryWand();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.wand != null) {
                    if (typeof object.wand !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.InventoryWand.wand: object expected");
                    message.wand = $root.NT.Wand.fromObject(object.wand);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventoryWand message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ClientPlayerUpdateInventory.InventoryWand} message InventoryWand
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventoryWand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.wand = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.wand != null && message.hasOwnProperty("wand"))
                    object.wand = $root.NT.Wand.toObject(message.wand, options);
                return object;
            };

            /**
             * Converts this InventoryWand to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventoryWand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventoryWand
             * @function getTypeUrl
             * @memberof NT.ClientPlayerUpdateInventory.InventoryWand
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventoryWand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerUpdateInventory.InventoryWand";
            };

            return InventoryWand;
        })();

        ClientPlayerUpdateInventory.InventoryItem = (function() {

            /**
             * Properties of an InventoryItem.
             * @memberof NT.ClientPlayerUpdateInventory
             * @interface IInventoryItem
             * @property {number|null} [index] InventoryItem index
             * @property {NT.IItem|null} [item] InventoryItem item
             */

            /**
             * Constructs a new InventoryItem.
             * @memberof NT.ClientPlayerUpdateInventory
             * @classdesc Represents an InventoryItem.
             * @implements IInventoryItem
             * @constructor
             * @param {NT.ClientPlayerUpdateInventory.IInventoryItem=} [properties] Properties to set
             */
            function InventoryItem(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventoryItem index.
             * @member {number} index
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @instance
             */
            InventoryItem.prototype.index = 0;

            /**
             * InventoryItem item.
             * @member {NT.IItem|null|undefined} item
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @instance
             */
            InventoryItem.prototype.item = null;

            /**
             * Creates a new InventoryItem instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryItem=} [properties] Properties to set
             * @returns {NT.ClientPlayerUpdateInventory.InventoryItem} InventoryItem instance
             */
            InventoryItem.create = function create(properties) {
                return new InventoryItem(properties);
            };

            /**
             * Encodes the specified InventoryItem message. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventoryItem.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryItem} message InventoryItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.index);
                if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                    $root.NT.Item.encode(message.item, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventoryItem message, length delimited. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventoryItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventoryItem} message InventoryItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventoryItem message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerUpdateInventory.InventoryItem} InventoryItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerUpdateInventory.InventoryItem();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.item = $root.NT.Item.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventoryItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerUpdateInventory.InventoryItem} InventoryItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventoryItem message.
             * @function verify
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventoryItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.item != null && message.hasOwnProperty("item")) {
                    let error = $root.NT.Item.verify(message.item);
                    if (error)
                        return "item." + error;
                }
                return null;
            };

            /**
             * Creates an InventoryItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerUpdateInventory.InventoryItem} InventoryItem
             */
            InventoryItem.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerUpdateInventory.InventoryItem)
                    return object;
                let message = new $root.NT.ClientPlayerUpdateInventory.InventoryItem();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.item != null) {
                    if (typeof object.item !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.InventoryItem.item: object expected");
                    message.item = $root.NT.Item.fromObject(object.item);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventoryItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ClientPlayerUpdateInventory.InventoryItem} message InventoryItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventoryItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.item = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.item != null && message.hasOwnProperty("item"))
                    object.item = $root.NT.Item.toObject(message.item, options);
                return object;
            };

            /**
             * Converts this InventoryItem to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventoryItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventoryItem
             * @function getTypeUrl
             * @memberof NT.ClientPlayerUpdateInventory.InventoryItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventoryItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerUpdateInventory.InventoryItem";
            };

            return InventoryItem;
        })();

        ClientPlayerUpdateInventory.InventorySpell = (function() {

            /**
             * Properties of an InventorySpell.
             * @memberof NT.ClientPlayerUpdateInventory
             * @interface IInventorySpell
             * @property {number|null} [index] InventorySpell index
             * @property {NT.ISpell|null} [spell] InventorySpell spell
             */

            /**
             * Constructs a new InventorySpell.
             * @memberof NT.ClientPlayerUpdateInventory
             * @classdesc Represents an InventorySpell.
             * @implements IInventorySpell
             * @constructor
             * @param {NT.ClientPlayerUpdateInventory.IInventorySpell=} [properties] Properties to set
             */
            function InventorySpell(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventorySpell index.
             * @member {number} index
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @instance
             */
            InventorySpell.prototype.index = 0;

            /**
             * InventorySpell spell.
             * @member {NT.ISpell|null|undefined} spell
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @instance
             */
            InventorySpell.prototype.spell = null;

            /**
             * Creates a new InventorySpell instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventorySpell=} [properties] Properties to set
             * @returns {NT.ClientPlayerUpdateInventory.InventorySpell} InventorySpell instance
             */
            InventorySpell.create = function create(properties) {
                return new InventorySpell(properties);
            };

            /**
             * Encodes the specified InventorySpell message. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventorySpell.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventorySpell} message InventorySpell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventorySpell.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.spell != null && Object.hasOwnProperty.call(message, "spell"))
                    $root.NT.Spell.encode(message.spell, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventorySpell message, length delimited. Does not implicitly {@link NT.ClientPlayerUpdateInventory.InventorySpell.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ClientPlayerUpdateInventory.IInventorySpell} message InventorySpell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventorySpell.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventorySpell message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerUpdateInventory.InventorySpell} InventorySpell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventorySpell.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerUpdateInventory.InventorySpell();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.spell = $root.NT.Spell.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventorySpell message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerUpdateInventory.InventorySpell} InventorySpell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventorySpell.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventorySpell message.
             * @function verify
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventorySpell.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.spell != null && message.hasOwnProperty("spell")) {
                    let error = $root.NT.Spell.verify(message.spell);
                    if (error)
                        return "spell." + error;
                }
                return null;
            };

            /**
             * Creates an InventorySpell message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerUpdateInventory.InventorySpell} InventorySpell
             */
            InventorySpell.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerUpdateInventory.InventorySpell)
                    return object;
                let message = new $root.NT.ClientPlayerUpdateInventory.InventorySpell();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.spell != null) {
                    if (typeof object.spell !== "object")
                        throw TypeError(".NT.ClientPlayerUpdateInventory.InventorySpell.spell: object expected");
                    message.spell = $root.NT.Spell.fromObject(object.spell);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventorySpell message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ClientPlayerUpdateInventory.InventorySpell} message InventorySpell
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventorySpell.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.spell = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.spell != null && message.hasOwnProperty("spell"))
                    object.spell = $root.NT.Spell.toObject(message.spell, options);
                return object;
            };

            /**
             * Converts this InventorySpell to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventorySpell.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventorySpell
             * @function getTypeUrl
             * @memberof NT.ClientPlayerUpdateInventory.InventorySpell
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventorySpell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerUpdateInventory.InventorySpell";
            };

            return InventorySpell;
        })();

        return ClientPlayerUpdateInventory;
    })();

    NT.ServerPlayerUpdateInventory = (function() {

        /**
         * Properties of a ServerPlayerUpdateInventory.
         * @memberof NT
         * @interface IServerPlayerUpdateInventory
         * @property {string|null} [userId] ServerPlayerUpdateInventory userId
         * @property {Array.<NT.ServerPlayerUpdateInventory.IInventoryWand>|null} [wands] ServerPlayerUpdateInventory wands
         * @property {Array.<NT.ServerPlayerUpdateInventory.IInventoryItem>|null} [items] ServerPlayerUpdateInventory items
         * @property {Array.<NT.ServerPlayerUpdateInventory.IInventorySpell>|null} [spells] ServerPlayerUpdateInventory spells
         */

        /**
         * Constructs a new ServerPlayerUpdateInventory.
         * @memberof NT
         * @classdesc Represents a ServerPlayerUpdateInventory.
         * @implements IServerPlayerUpdateInventory
         * @constructor
         * @param {NT.IServerPlayerUpdateInventory=} [properties] Properties to set
         */
        function ServerPlayerUpdateInventory(properties) {
            this.wands = [];
            this.items = [];
            this.spells = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerUpdateInventory userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerUpdateInventory
         * @instance
         */
        ServerPlayerUpdateInventory.prototype.userId = "";

        /**
         * ServerPlayerUpdateInventory wands.
         * @member {Array.<NT.ServerPlayerUpdateInventory.IInventoryWand>} wands
         * @memberof NT.ServerPlayerUpdateInventory
         * @instance
         */
        ServerPlayerUpdateInventory.prototype.wands = $util.emptyArray;

        /**
         * ServerPlayerUpdateInventory items.
         * @member {Array.<NT.ServerPlayerUpdateInventory.IInventoryItem>} items
         * @memberof NT.ServerPlayerUpdateInventory
         * @instance
         */
        ServerPlayerUpdateInventory.prototype.items = $util.emptyArray;

        /**
         * ServerPlayerUpdateInventory spells.
         * @member {Array.<NT.ServerPlayerUpdateInventory.IInventorySpell>} spells
         * @memberof NT.ServerPlayerUpdateInventory
         * @instance
         */
        ServerPlayerUpdateInventory.prototype.spells = $util.emptyArray;

        /**
         * Creates a new ServerPlayerUpdateInventory instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {NT.IServerPlayerUpdateInventory=} [properties] Properties to set
         * @returns {NT.ServerPlayerUpdateInventory} ServerPlayerUpdateInventory instance
         */
        ServerPlayerUpdateInventory.create = function create(properties) {
            return new ServerPlayerUpdateInventory(properties);
        };

        /**
         * Encodes the specified ServerPlayerUpdateInventory message. Does not implicitly {@link NT.ServerPlayerUpdateInventory.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {NT.IServerPlayerUpdateInventory} message ServerPlayerUpdateInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerUpdateInventory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.wands != null && message.wands.length)
                for (let i = 0; i < message.wands.length; ++i)
                    $root.NT.ServerPlayerUpdateInventory.InventoryWand.encode(message.wands[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.NT.ServerPlayerUpdateInventory.InventoryItem.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.spells != null && message.spells.length)
                for (let i = 0; i < message.spells.length; ++i)
                    $root.NT.ServerPlayerUpdateInventory.InventorySpell.encode(message.spells[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerUpdateInventory message, length delimited. Does not implicitly {@link NT.ServerPlayerUpdateInventory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {NT.IServerPlayerUpdateInventory} message ServerPlayerUpdateInventory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerUpdateInventory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerUpdateInventory message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerUpdateInventory} ServerPlayerUpdateInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerUpdateInventory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerUpdateInventory();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.wands && message.wands.length))
                            message.wands = [];
                        message.wands.push($root.NT.ServerPlayerUpdateInventory.InventoryWand.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.NT.ServerPlayerUpdateInventory.InventoryItem.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.spells && message.spells.length))
                            message.spells = [];
                        message.spells.push($root.NT.ServerPlayerUpdateInventory.InventorySpell.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerUpdateInventory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerUpdateInventory} ServerPlayerUpdateInventory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerUpdateInventory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerUpdateInventory message.
         * @function verify
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerUpdateInventory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (!Array.isArray(message.wands))
                    return "wands: array expected";
                for (let i = 0; i < message.wands.length; ++i) {
                    let error = $root.NT.ServerPlayerUpdateInventory.InventoryWand.verify(message.wands[i]);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.NT.ServerPlayerUpdateInventory.InventoryItem.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.spells != null && message.hasOwnProperty("spells")) {
                if (!Array.isArray(message.spells))
                    return "spells: array expected";
                for (let i = 0; i < message.spells.length; ++i) {
                    let error = $root.NT.ServerPlayerUpdateInventory.InventorySpell.verify(message.spells[i]);
                    if (error)
                        return "spells." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerPlayerUpdateInventory message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerUpdateInventory} ServerPlayerUpdateInventory
         */
        ServerPlayerUpdateInventory.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerUpdateInventory)
                return object;
            let message = new $root.NT.ServerPlayerUpdateInventory();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.wands) {
                if (!Array.isArray(object.wands))
                    throw TypeError(".NT.ServerPlayerUpdateInventory.wands: array expected");
                message.wands = [];
                for (let i = 0; i < object.wands.length; ++i) {
                    if (typeof object.wands[i] !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.wands: object expected");
                    message.wands[i] = $root.NT.ServerPlayerUpdateInventory.InventoryWand.fromObject(object.wands[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".NT.ServerPlayerUpdateInventory.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.items: object expected");
                    message.items[i] = $root.NT.ServerPlayerUpdateInventory.InventoryItem.fromObject(object.items[i]);
                }
            }
            if (object.spells) {
                if (!Array.isArray(object.spells))
                    throw TypeError(".NT.ServerPlayerUpdateInventory.spells: array expected");
                message.spells = [];
                for (let i = 0; i < object.spells.length; ++i) {
                    if (typeof object.spells[i] !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.spells: object expected");
                    message.spells[i] = $root.NT.ServerPlayerUpdateInventory.InventorySpell.fromObject(object.spells[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerUpdateInventory message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {NT.ServerPlayerUpdateInventory} message ServerPlayerUpdateInventory
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerUpdateInventory.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.wands = [];
                object.items = [];
                object.spells = [];
            }
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.wands && message.wands.length) {
                object.wands = [];
                for (let j = 0; j < message.wands.length; ++j)
                    object.wands[j] = $root.NT.ServerPlayerUpdateInventory.InventoryWand.toObject(message.wands[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.NT.ServerPlayerUpdateInventory.InventoryItem.toObject(message.items[j], options);
            }
            if (message.spells && message.spells.length) {
                object.spells = [];
                for (let j = 0; j < message.spells.length; ++j)
                    object.spells[j] = $root.NT.ServerPlayerUpdateInventory.InventorySpell.toObject(message.spells[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerPlayerUpdateInventory to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerUpdateInventory
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerUpdateInventory.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerUpdateInventory
         * @function getTypeUrl
         * @memberof NT.ServerPlayerUpdateInventory
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerUpdateInventory.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerUpdateInventory";
        };

        ServerPlayerUpdateInventory.InventoryWand = (function() {

            /**
             * Properties of an InventoryWand.
             * @memberof NT.ServerPlayerUpdateInventory
             * @interface IInventoryWand
             * @property {number|null} [index] InventoryWand index
             * @property {NT.IWand|null} [wand] InventoryWand wand
             */

            /**
             * Constructs a new InventoryWand.
             * @memberof NT.ServerPlayerUpdateInventory
             * @classdesc Represents an InventoryWand.
             * @implements IInventoryWand
             * @constructor
             * @param {NT.ServerPlayerUpdateInventory.IInventoryWand=} [properties] Properties to set
             */
            function InventoryWand(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventoryWand index.
             * @member {number} index
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @instance
             */
            InventoryWand.prototype.index = 0;

            /**
             * InventoryWand wand.
             * @member {NT.IWand|null|undefined} wand
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @instance
             */
            InventoryWand.prototype.wand = null;

            /**
             * Creates a new InventoryWand instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryWand=} [properties] Properties to set
             * @returns {NT.ServerPlayerUpdateInventory.InventoryWand} InventoryWand instance
             */
            InventoryWand.create = function create(properties) {
                return new InventoryWand(properties);
            };

            /**
             * Encodes the specified InventoryWand message. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventoryWand.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryWand} message InventoryWand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryWand.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.wand != null && Object.hasOwnProperty.call(message, "wand"))
                    $root.NT.Wand.encode(message.wand, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventoryWand message, length delimited. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventoryWand.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryWand} message InventoryWand message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryWand.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventoryWand message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerUpdateInventory.InventoryWand} InventoryWand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryWand.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerUpdateInventory.InventoryWand();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.wand = $root.NT.Wand.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventoryWand message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerUpdateInventory.InventoryWand} InventoryWand
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryWand.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventoryWand message.
             * @function verify
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventoryWand.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.wand != null && message.hasOwnProperty("wand")) {
                    let error = $root.NT.Wand.verify(message.wand);
                    if (error)
                        return "wand." + error;
                }
                return null;
            };

            /**
             * Creates an InventoryWand message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerUpdateInventory.InventoryWand} InventoryWand
             */
            InventoryWand.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerUpdateInventory.InventoryWand)
                    return object;
                let message = new $root.NT.ServerPlayerUpdateInventory.InventoryWand();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.wand != null) {
                    if (typeof object.wand !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.InventoryWand.wand: object expected");
                    message.wand = $root.NT.Wand.fromObject(object.wand);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventoryWand message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {NT.ServerPlayerUpdateInventory.InventoryWand} message InventoryWand
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventoryWand.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.wand = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.wand != null && message.hasOwnProperty("wand"))
                    object.wand = $root.NT.Wand.toObject(message.wand, options);
                return object;
            };

            /**
             * Converts this InventoryWand to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventoryWand.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventoryWand
             * @function getTypeUrl
             * @memberof NT.ServerPlayerUpdateInventory.InventoryWand
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventoryWand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerUpdateInventory.InventoryWand";
            };

            return InventoryWand;
        })();

        ServerPlayerUpdateInventory.InventoryItem = (function() {

            /**
             * Properties of an InventoryItem.
             * @memberof NT.ServerPlayerUpdateInventory
             * @interface IInventoryItem
             * @property {number|null} [index] InventoryItem index
             * @property {NT.IItem|null} [item] InventoryItem item
             */

            /**
             * Constructs a new InventoryItem.
             * @memberof NT.ServerPlayerUpdateInventory
             * @classdesc Represents an InventoryItem.
             * @implements IInventoryItem
             * @constructor
             * @param {NT.ServerPlayerUpdateInventory.IInventoryItem=} [properties] Properties to set
             */
            function InventoryItem(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventoryItem index.
             * @member {number} index
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @instance
             */
            InventoryItem.prototype.index = 0;

            /**
             * InventoryItem item.
             * @member {NT.IItem|null|undefined} item
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @instance
             */
            InventoryItem.prototype.item = null;

            /**
             * Creates a new InventoryItem instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryItem=} [properties] Properties to set
             * @returns {NT.ServerPlayerUpdateInventory.InventoryItem} InventoryItem instance
             */
            InventoryItem.create = function create(properties) {
                return new InventoryItem(properties);
            };

            /**
             * Encodes the specified InventoryItem message. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventoryItem.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryItem} message InventoryItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryItem.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.item != null && Object.hasOwnProperty.call(message, "item"))
                    $root.NT.Item.encode(message.item, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventoryItem message, length delimited. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventoryItem.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventoryItem} message InventoryItem message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventoryItem.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventoryItem message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerUpdateInventory.InventoryItem} InventoryItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryItem.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerUpdateInventory.InventoryItem();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.item = $root.NT.Item.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventoryItem message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerUpdateInventory.InventoryItem} InventoryItem
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventoryItem.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventoryItem message.
             * @function verify
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventoryItem.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.item != null && message.hasOwnProperty("item")) {
                    let error = $root.NT.Item.verify(message.item);
                    if (error)
                        return "item." + error;
                }
                return null;
            };

            /**
             * Creates an InventoryItem message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerUpdateInventory.InventoryItem} InventoryItem
             */
            InventoryItem.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerUpdateInventory.InventoryItem)
                    return object;
                let message = new $root.NT.ServerPlayerUpdateInventory.InventoryItem();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.item != null) {
                    if (typeof object.item !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.InventoryItem.item: object expected");
                    message.item = $root.NT.Item.fromObject(object.item);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventoryItem message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {NT.ServerPlayerUpdateInventory.InventoryItem} message InventoryItem
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventoryItem.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.item = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.item != null && message.hasOwnProperty("item"))
                    object.item = $root.NT.Item.toObject(message.item, options);
                return object;
            };

            /**
             * Converts this InventoryItem to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventoryItem.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventoryItem
             * @function getTypeUrl
             * @memberof NT.ServerPlayerUpdateInventory.InventoryItem
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventoryItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerUpdateInventory.InventoryItem";
            };

            return InventoryItem;
        })();

        ServerPlayerUpdateInventory.InventorySpell = (function() {

            /**
             * Properties of an InventorySpell.
             * @memberof NT.ServerPlayerUpdateInventory
             * @interface IInventorySpell
             * @property {number|null} [index] InventorySpell index
             * @property {NT.ISpell|null} [spell] InventorySpell spell
             */

            /**
             * Constructs a new InventorySpell.
             * @memberof NT.ServerPlayerUpdateInventory
             * @classdesc Represents an InventorySpell.
             * @implements IInventorySpell
             * @constructor
             * @param {NT.ServerPlayerUpdateInventory.IInventorySpell=} [properties] Properties to set
             */
            function InventorySpell(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InventorySpell index.
             * @member {number} index
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @instance
             */
            InventorySpell.prototype.index = 0;

            /**
             * InventorySpell spell.
             * @member {NT.ISpell|null|undefined} spell
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @instance
             */
            InventorySpell.prototype.spell = null;

            /**
             * Creates a new InventorySpell instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventorySpell=} [properties] Properties to set
             * @returns {NT.ServerPlayerUpdateInventory.InventorySpell} InventorySpell instance
             */
            InventorySpell.create = function create(properties) {
                return new InventorySpell(properties);
            };

            /**
             * Encodes the specified InventorySpell message. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventorySpell.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventorySpell} message InventorySpell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventorySpell.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.index != null && Object.hasOwnProperty.call(message, "index"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);
                if (message.spell != null && Object.hasOwnProperty.call(message, "spell"))
                    $root.NT.Spell.encode(message.spell, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified InventorySpell message, length delimited. Does not implicitly {@link NT.ServerPlayerUpdateInventory.InventorySpell.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ServerPlayerUpdateInventory.IInventorySpell} message InventorySpell message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InventorySpell.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InventorySpell message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerUpdateInventory.InventorySpell} InventorySpell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventorySpell.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerUpdateInventory.InventorySpell();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.index = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.spell = $root.NT.Spell.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InventorySpell message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerUpdateInventory.InventorySpell} InventorySpell
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InventorySpell.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InventorySpell message.
             * @function verify
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InventorySpell.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.index != null && message.hasOwnProperty("index"))
                    if (!$util.isInteger(message.index))
                        return "index: integer expected";
                if (message.spell != null && message.hasOwnProperty("spell")) {
                    let error = $root.NT.Spell.verify(message.spell);
                    if (error)
                        return "spell." + error;
                }
                return null;
            };

            /**
             * Creates an InventorySpell message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerUpdateInventory.InventorySpell} InventorySpell
             */
            InventorySpell.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerUpdateInventory.InventorySpell)
                    return object;
                let message = new $root.NT.ServerPlayerUpdateInventory.InventorySpell();
                if (object.index != null)
                    message.index = object.index >>> 0;
                if (object.spell != null) {
                    if (typeof object.spell !== "object")
                        throw TypeError(".NT.ServerPlayerUpdateInventory.InventorySpell.spell: object expected");
                    message.spell = $root.NT.Spell.fromObject(object.spell);
                }
                return message;
            };

            /**
             * Creates a plain object from an InventorySpell message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {NT.ServerPlayerUpdateInventory.InventorySpell} message InventorySpell
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InventorySpell.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.index = 0;
                    object.spell = null;
                }
                if (message.index != null && message.hasOwnProperty("index"))
                    object.index = message.index;
                if (message.spell != null && message.hasOwnProperty("spell"))
                    object.spell = $root.NT.Spell.toObject(message.spell, options);
                return object;
            };

            /**
             * Converts this InventorySpell to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InventorySpell.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InventorySpell
             * @function getTypeUrl
             * @memberof NT.ServerPlayerUpdateInventory.InventorySpell
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InventorySpell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerUpdateInventory.InventorySpell";
            };

            return InventorySpell;
        })();

        return ServerPlayerUpdateInventory;
    })();

    NT.ClientHostItemBank = (function() {

        /**
         * Properties of a ClientHostItemBank.
         * @memberof NT
         * @interface IClientHostItemBank
         * @property {Array.<NT.IWand>|null} [wands] ClientHostItemBank wands
         * @property {Array.<NT.ISpell>|null} [spells] ClientHostItemBank spells
         * @property {Array.<NT.IItem>|null} [items] ClientHostItemBank items
         * @property {number|null} [gold] ClientHostItemBank gold
         * @property {Array.<NT.IEntityItem>|null} [objects] ClientHostItemBank objects
         */

        /**
         * Constructs a new ClientHostItemBank.
         * @memberof NT
         * @classdesc Represents a ClientHostItemBank.
         * @implements IClientHostItemBank
         * @constructor
         * @param {NT.IClientHostItemBank=} [properties] Properties to set
         */
        function ClientHostItemBank(properties) {
            this.wands = [];
            this.spells = [];
            this.items = [];
            this.objects = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientHostItemBank wands.
         * @member {Array.<NT.IWand>} wands
         * @memberof NT.ClientHostItemBank
         * @instance
         */
        ClientHostItemBank.prototype.wands = $util.emptyArray;

        /**
         * ClientHostItemBank spells.
         * @member {Array.<NT.ISpell>} spells
         * @memberof NT.ClientHostItemBank
         * @instance
         */
        ClientHostItemBank.prototype.spells = $util.emptyArray;

        /**
         * ClientHostItemBank items.
         * @member {Array.<NT.IItem>} items
         * @memberof NT.ClientHostItemBank
         * @instance
         */
        ClientHostItemBank.prototype.items = $util.emptyArray;

        /**
         * ClientHostItemBank gold.
         * @member {number} gold
         * @memberof NT.ClientHostItemBank
         * @instance
         */
        ClientHostItemBank.prototype.gold = 0;

        /**
         * ClientHostItemBank objects.
         * @member {Array.<NT.IEntityItem>} objects
         * @memberof NT.ClientHostItemBank
         * @instance
         */
        ClientHostItemBank.prototype.objects = $util.emptyArray;

        /**
         * Creates a new ClientHostItemBank instance using the specified properties.
         * @function create
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {NT.IClientHostItemBank=} [properties] Properties to set
         * @returns {NT.ClientHostItemBank} ClientHostItemBank instance
         */
        ClientHostItemBank.create = function create(properties) {
            return new ClientHostItemBank(properties);
        };

        /**
         * Encodes the specified ClientHostItemBank message. Does not implicitly {@link NT.ClientHostItemBank.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {NT.IClientHostItemBank} message ClientHostItemBank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostItemBank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wands != null && message.wands.length)
                for (let i = 0; i < message.wands.length; ++i)
                    $root.NT.Wand.encode(message.wands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.spells != null && message.spells.length)
                for (let i = 0; i < message.spells.length; ++i)
                    $root.NT.Spell.encode(message.spells[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.NT.Item.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.gold != null && Object.hasOwnProperty.call(message, "gold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.gold);
            if (message.objects != null && message.objects.length)
                for (let i = 0; i < message.objects.length; ++i)
                    $root.NT.EntityItem.encode(message.objects[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientHostItemBank message, length delimited. Does not implicitly {@link NT.ClientHostItemBank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {NT.IClientHostItemBank} message ClientHostItemBank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostItemBank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientHostItemBank message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientHostItemBank} ClientHostItemBank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostItemBank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientHostItemBank();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.wands && message.wands.length))
                            message.wands = [];
                        message.wands.push($root.NT.Wand.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.spells && message.spells.length))
                            message.spells = [];
                        message.spells.push($root.NT.Spell.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.NT.Item.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.gold = reader.uint32();
                        break;
                    }
                case 5: {
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push($root.NT.EntityItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientHostItemBank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientHostItemBank} ClientHostItemBank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostItemBank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientHostItemBank message.
         * @function verify
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientHostItemBank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (!Array.isArray(message.wands))
                    return "wands: array expected";
                for (let i = 0; i < message.wands.length; ++i) {
                    let error = $root.NT.Wand.verify(message.wands[i]);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.spells != null && message.hasOwnProperty("spells")) {
                if (!Array.isArray(message.spells))
                    return "spells: array expected";
                for (let i = 0; i < message.spells.length; ++i) {
                    let error = $root.NT.Spell.verify(message.spells[i]);
                    if (error)
                        return "spells." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.NT.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.gold != null && message.hasOwnProperty("gold"))
                if (!$util.isInteger(message.gold))
                    return "gold: integer expected";
            if (message.objects != null && message.hasOwnProperty("objects")) {
                if (!Array.isArray(message.objects))
                    return "objects: array expected";
                for (let i = 0; i < message.objects.length; ++i) {
                    let error = $root.NT.EntityItem.verify(message.objects[i]);
                    if (error)
                        return "objects." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientHostItemBank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientHostItemBank} ClientHostItemBank
         */
        ClientHostItemBank.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientHostItemBank)
                return object;
            let message = new $root.NT.ClientHostItemBank();
            if (object.wands) {
                if (!Array.isArray(object.wands))
                    throw TypeError(".NT.ClientHostItemBank.wands: array expected");
                message.wands = [];
                for (let i = 0; i < object.wands.length; ++i) {
                    if (typeof object.wands[i] !== "object")
                        throw TypeError(".NT.ClientHostItemBank.wands: object expected");
                    message.wands[i] = $root.NT.Wand.fromObject(object.wands[i]);
                }
            }
            if (object.spells) {
                if (!Array.isArray(object.spells))
                    throw TypeError(".NT.ClientHostItemBank.spells: array expected");
                message.spells = [];
                for (let i = 0; i < object.spells.length; ++i) {
                    if (typeof object.spells[i] !== "object")
                        throw TypeError(".NT.ClientHostItemBank.spells: object expected");
                    message.spells[i] = $root.NT.Spell.fromObject(object.spells[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".NT.ClientHostItemBank.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".NT.ClientHostItemBank.items: object expected");
                    message.items[i] = $root.NT.Item.fromObject(object.items[i]);
                }
            }
            if (object.gold != null)
                message.gold = object.gold >>> 0;
            if (object.objects) {
                if (!Array.isArray(object.objects))
                    throw TypeError(".NT.ClientHostItemBank.objects: array expected");
                message.objects = [];
                for (let i = 0; i < object.objects.length; ++i) {
                    if (typeof object.objects[i] !== "object")
                        throw TypeError(".NT.ClientHostItemBank.objects: object expected");
                    message.objects[i] = $root.NT.EntityItem.fromObject(object.objects[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientHostItemBank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {NT.ClientHostItemBank} message ClientHostItemBank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientHostItemBank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.wands = [];
                object.spells = [];
                object.items = [];
                object.objects = [];
            }
            if (options.defaults)
                object.gold = 0;
            if (message.wands && message.wands.length) {
                object.wands = [];
                for (let j = 0; j < message.wands.length; ++j)
                    object.wands[j] = $root.NT.Wand.toObject(message.wands[j], options);
            }
            if (message.spells && message.spells.length) {
                object.spells = [];
                for (let j = 0; j < message.spells.length; ++j)
                    object.spells[j] = $root.NT.Spell.toObject(message.spells[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.NT.Item.toObject(message.items[j], options);
            }
            if (message.gold != null && message.hasOwnProperty("gold"))
                object.gold = message.gold;
            if (message.objects && message.objects.length) {
                object.objects = [];
                for (let j = 0; j < message.objects.length; ++j)
                    object.objects[j] = $root.NT.EntityItem.toObject(message.objects[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientHostItemBank to JSON.
         * @function toJSON
         * @memberof NT.ClientHostItemBank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientHostItemBank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientHostItemBank
         * @function getTypeUrl
         * @memberof NT.ClientHostItemBank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientHostItemBank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientHostItemBank";
        };

        return ClientHostItemBank;
    })();

    NT.ServerHostItemBank = (function() {

        /**
         * Properties of a ServerHostItemBank.
         * @memberof NT
         * @interface IServerHostItemBank
         * @property {Array.<NT.IWand>|null} [wands] ServerHostItemBank wands
         * @property {Array.<NT.ISpell>|null} [spells] ServerHostItemBank spells
         * @property {Array.<NT.IItem>|null} [items] ServerHostItemBank items
         * @property {number|null} [gold] ServerHostItemBank gold
         * @property {Array.<NT.IEntityItem>|null} [objects] ServerHostItemBank objects
         */

        /**
         * Constructs a new ServerHostItemBank.
         * @memberof NT
         * @classdesc Represents a ServerHostItemBank.
         * @implements IServerHostItemBank
         * @constructor
         * @param {NT.IServerHostItemBank=} [properties] Properties to set
         */
        function ServerHostItemBank(properties) {
            this.wands = [];
            this.spells = [];
            this.items = [];
            this.objects = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerHostItemBank wands.
         * @member {Array.<NT.IWand>} wands
         * @memberof NT.ServerHostItemBank
         * @instance
         */
        ServerHostItemBank.prototype.wands = $util.emptyArray;

        /**
         * ServerHostItemBank spells.
         * @member {Array.<NT.ISpell>} spells
         * @memberof NT.ServerHostItemBank
         * @instance
         */
        ServerHostItemBank.prototype.spells = $util.emptyArray;

        /**
         * ServerHostItemBank items.
         * @member {Array.<NT.IItem>} items
         * @memberof NT.ServerHostItemBank
         * @instance
         */
        ServerHostItemBank.prototype.items = $util.emptyArray;

        /**
         * ServerHostItemBank gold.
         * @member {number} gold
         * @memberof NT.ServerHostItemBank
         * @instance
         */
        ServerHostItemBank.prototype.gold = 0;

        /**
         * ServerHostItemBank objects.
         * @member {Array.<NT.IEntityItem>} objects
         * @memberof NT.ServerHostItemBank
         * @instance
         */
        ServerHostItemBank.prototype.objects = $util.emptyArray;

        /**
         * Creates a new ServerHostItemBank instance using the specified properties.
         * @function create
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {NT.IServerHostItemBank=} [properties] Properties to set
         * @returns {NT.ServerHostItemBank} ServerHostItemBank instance
         */
        ServerHostItemBank.create = function create(properties) {
            return new ServerHostItemBank(properties);
        };

        /**
         * Encodes the specified ServerHostItemBank message. Does not implicitly {@link NT.ServerHostItemBank.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {NT.IServerHostItemBank} message ServerHostItemBank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostItemBank.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.wands != null && message.wands.length)
                for (let i = 0; i < message.wands.length; ++i)
                    $root.NT.Wand.encode(message.wands[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.spells != null && message.spells.length)
                for (let i = 0; i < message.spells.length; ++i)
                    $root.NT.Spell.encode(message.spells[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.items != null && message.items.length)
                for (let i = 0; i < message.items.length; ++i)
                    $root.NT.Item.encode(message.items[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.gold != null && Object.hasOwnProperty.call(message, "gold"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.gold);
            if (message.objects != null && message.objects.length)
                for (let i = 0; i < message.objects.length; ++i)
                    $root.NT.EntityItem.encode(message.objects[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerHostItemBank message, length delimited. Does not implicitly {@link NT.ServerHostItemBank.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {NT.IServerHostItemBank} message ServerHostItemBank message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostItemBank.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerHostItemBank message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerHostItemBank} ServerHostItemBank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostItemBank.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerHostItemBank();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.wands && message.wands.length))
                            message.wands = [];
                        message.wands.push($root.NT.Wand.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        if (!(message.spells && message.spells.length))
                            message.spells = [];
                        message.spells.push($root.NT.Spell.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        if (!(message.items && message.items.length))
                            message.items = [];
                        message.items.push($root.NT.Item.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.gold = reader.uint32();
                        break;
                    }
                case 5: {
                        if (!(message.objects && message.objects.length))
                            message.objects = [];
                        message.objects.push($root.NT.EntityItem.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerHostItemBank message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerHostItemBank} ServerHostItemBank
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostItemBank.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerHostItemBank message.
         * @function verify
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerHostItemBank.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (!Array.isArray(message.wands))
                    return "wands: array expected";
                for (let i = 0; i < message.wands.length; ++i) {
                    let error = $root.NT.Wand.verify(message.wands[i]);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.spells != null && message.hasOwnProperty("spells")) {
                if (!Array.isArray(message.spells))
                    return "spells: array expected";
                for (let i = 0; i < message.spells.length; ++i) {
                    let error = $root.NT.Spell.verify(message.spells[i]);
                    if (error)
                        return "spells." + error;
                }
            }
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (let i = 0; i < message.items.length; ++i) {
                    let error = $root.NT.Item.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.gold != null && message.hasOwnProperty("gold"))
                if (!$util.isInteger(message.gold))
                    return "gold: integer expected";
            if (message.objects != null && message.hasOwnProperty("objects")) {
                if (!Array.isArray(message.objects))
                    return "objects: array expected";
                for (let i = 0; i < message.objects.length; ++i) {
                    let error = $root.NT.EntityItem.verify(message.objects[i]);
                    if (error)
                        return "objects." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerHostItemBank message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerHostItemBank} ServerHostItemBank
         */
        ServerHostItemBank.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerHostItemBank)
                return object;
            let message = new $root.NT.ServerHostItemBank();
            if (object.wands) {
                if (!Array.isArray(object.wands))
                    throw TypeError(".NT.ServerHostItemBank.wands: array expected");
                message.wands = [];
                for (let i = 0; i < object.wands.length; ++i) {
                    if (typeof object.wands[i] !== "object")
                        throw TypeError(".NT.ServerHostItemBank.wands: object expected");
                    message.wands[i] = $root.NT.Wand.fromObject(object.wands[i]);
                }
            }
            if (object.spells) {
                if (!Array.isArray(object.spells))
                    throw TypeError(".NT.ServerHostItemBank.spells: array expected");
                message.spells = [];
                for (let i = 0; i < object.spells.length; ++i) {
                    if (typeof object.spells[i] !== "object")
                        throw TypeError(".NT.ServerHostItemBank.spells: object expected");
                    message.spells[i] = $root.NT.Spell.fromObject(object.spells[i]);
                }
            }
            if (object.items) {
                if (!Array.isArray(object.items))
                    throw TypeError(".NT.ServerHostItemBank.items: array expected");
                message.items = [];
                for (let i = 0; i < object.items.length; ++i) {
                    if (typeof object.items[i] !== "object")
                        throw TypeError(".NT.ServerHostItemBank.items: object expected");
                    message.items[i] = $root.NT.Item.fromObject(object.items[i]);
                }
            }
            if (object.gold != null)
                message.gold = object.gold >>> 0;
            if (object.objects) {
                if (!Array.isArray(object.objects))
                    throw TypeError(".NT.ServerHostItemBank.objects: array expected");
                message.objects = [];
                for (let i = 0; i < object.objects.length; ++i) {
                    if (typeof object.objects[i] !== "object")
                        throw TypeError(".NT.ServerHostItemBank.objects: object expected");
                    message.objects[i] = $root.NT.EntityItem.fromObject(object.objects[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerHostItemBank message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {NT.ServerHostItemBank} message ServerHostItemBank
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerHostItemBank.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.wands = [];
                object.spells = [];
                object.items = [];
                object.objects = [];
            }
            if (options.defaults)
                object.gold = 0;
            if (message.wands && message.wands.length) {
                object.wands = [];
                for (let j = 0; j < message.wands.length; ++j)
                    object.wands[j] = $root.NT.Wand.toObject(message.wands[j], options);
            }
            if (message.spells && message.spells.length) {
                object.spells = [];
                for (let j = 0; j < message.spells.length; ++j)
                    object.spells[j] = $root.NT.Spell.toObject(message.spells[j], options);
            }
            if (message.items && message.items.length) {
                object.items = [];
                for (let j = 0; j < message.items.length; ++j)
                    object.items[j] = $root.NT.Item.toObject(message.items[j], options);
            }
            if (message.gold != null && message.hasOwnProperty("gold"))
                object.gold = message.gold;
            if (message.objects && message.objects.length) {
                object.objects = [];
                for (let j = 0; j < message.objects.length; ++j)
                    object.objects[j] = $root.NT.EntityItem.toObject(message.objects[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerHostItemBank to JSON.
         * @function toJSON
         * @memberof NT.ServerHostItemBank
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerHostItemBank.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerHostItemBank
         * @function getTypeUrl
         * @memberof NT.ServerHostItemBank
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerHostItemBank.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerHostItemBank";
        };

        return ServerHostItemBank;
    })();

    NT.ClientHostUserTake = (function() {

        /**
         * Properties of a ClientHostUserTake.
         * @memberof NT
         * @interface IClientHostUserTake
         * @property {string|null} [userId] ClientHostUserTake userId
         * @property {string|null} [id] ClientHostUserTake id
         * @property {boolean|null} [success] ClientHostUserTake success
         */

        /**
         * Constructs a new ClientHostUserTake.
         * @memberof NT
         * @classdesc Represents a ClientHostUserTake.
         * @implements IClientHostUserTake
         * @constructor
         * @param {NT.IClientHostUserTake=} [properties] Properties to set
         */
        function ClientHostUserTake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientHostUserTake userId.
         * @member {string} userId
         * @memberof NT.ClientHostUserTake
         * @instance
         */
        ClientHostUserTake.prototype.userId = "";

        /**
         * ClientHostUserTake id.
         * @member {string} id
         * @memberof NT.ClientHostUserTake
         * @instance
         */
        ClientHostUserTake.prototype.id = "";

        /**
         * ClientHostUserTake success.
         * @member {boolean} success
         * @memberof NT.ClientHostUserTake
         * @instance
         */
        ClientHostUserTake.prototype.success = false;

        /**
         * Creates a new ClientHostUserTake instance using the specified properties.
         * @function create
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {NT.IClientHostUserTake=} [properties] Properties to set
         * @returns {NT.ClientHostUserTake} ClientHostUserTake instance
         */
        ClientHostUserTake.create = function create(properties) {
            return new ClientHostUserTake(properties);
        };

        /**
         * Encodes the specified ClientHostUserTake message. Does not implicitly {@link NT.ClientHostUserTake.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {NT.IClientHostUserTake} message ClientHostUserTake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostUserTake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ClientHostUserTake message, length delimited. Does not implicitly {@link NT.ClientHostUserTake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {NT.IClientHostUserTake} message ClientHostUserTake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostUserTake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientHostUserTake message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientHostUserTake} ClientHostUserTake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostUserTake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientHostUserTake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.id = reader.string();
                        break;
                    }
                case 3: {
                        message.success = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientHostUserTake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientHostUserTake} ClientHostUserTake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostUserTake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientHostUserTake message.
         * @function verify
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientHostUserTake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ClientHostUserTake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientHostUserTake} ClientHostUserTake
         */
        ClientHostUserTake.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientHostUserTake)
                return object;
            let message = new $root.NT.ClientHostUserTake();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.id != null)
                message.id = String(object.id);
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ClientHostUserTake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {NT.ClientHostUserTake} message ClientHostUserTake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientHostUserTake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.id = "";
                object.success = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ClientHostUserTake to JSON.
         * @function toJSON
         * @memberof NT.ClientHostUserTake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientHostUserTake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientHostUserTake
         * @function getTypeUrl
         * @memberof NT.ClientHostUserTake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientHostUserTake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientHostUserTake";
        };

        return ClientHostUserTake;
    })();

    NT.ServerHostUserTake = (function() {

        /**
         * Properties of a ServerHostUserTake.
         * @memberof NT
         * @interface IServerHostUserTake
         * @property {string|null} [userId] ServerHostUserTake userId
         * @property {string|null} [id] ServerHostUserTake id
         * @property {boolean|null} [success] ServerHostUserTake success
         */

        /**
         * Constructs a new ServerHostUserTake.
         * @memberof NT
         * @classdesc Represents a ServerHostUserTake.
         * @implements IServerHostUserTake
         * @constructor
         * @param {NT.IServerHostUserTake=} [properties] Properties to set
         */
        function ServerHostUserTake(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerHostUserTake userId.
         * @member {string} userId
         * @memberof NT.ServerHostUserTake
         * @instance
         */
        ServerHostUserTake.prototype.userId = "";

        /**
         * ServerHostUserTake id.
         * @member {string} id
         * @memberof NT.ServerHostUserTake
         * @instance
         */
        ServerHostUserTake.prototype.id = "";

        /**
         * ServerHostUserTake success.
         * @member {boolean} success
         * @memberof NT.ServerHostUserTake
         * @instance
         */
        ServerHostUserTake.prototype.success = false;

        /**
         * Creates a new ServerHostUserTake instance using the specified properties.
         * @function create
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {NT.IServerHostUserTake=} [properties] Properties to set
         * @returns {NT.ServerHostUserTake} ServerHostUserTake instance
         */
        ServerHostUserTake.create = function create(properties) {
            return new ServerHostUserTake(properties);
        };

        /**
         * Encodes the specified ServerHostUserTake message. Does not implicitly {@link NT.ServerHostUserTake.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {NT.IServerHostUserTake} message ServerHostUserTake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostUserTake.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ServerHostUserTake message, length delimited. Does not implicitly {@link NT.ServerHostUserTake.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {NT.IServerHostUserTake} message ServerHostUserTake message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostUserTake.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerHostUserTake message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerHostUserTake} ServerHostUserTake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostUserTake.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerHostUserTake();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.id = reader.string();
                        break;
                    }
                case 3: {
                        message.success = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerHostUserTake message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerHostUserTake} ServerHostUserTake
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostUserTake.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerHostUserTake message.
         * @function verify
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerHostUserTake.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ServerHostUserTake message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerHostUserTake} ServerHostUserTake
         */
        ServerHostUserTake.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerHostUserTake)
                return object;
            let message = new $root.NT.ServerHostUserTake();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.id != null)
                message.id = String(object.id);
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ServerHostUserTake message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {NT.ServerHostUserTake} message ServerHostUserTake
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerHostUserTake.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.id = "";
                object.success = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ServerHostUserTake to JSON.
         * @function toJSON
         * @memberof NT.ServerHostUserTake
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerHostUserTake.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerHostUserTake
         * @function getTypeUrl
         * @memberof NT.ServerHostUserTake
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerHostUserTake.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerHostUserTake";
        };

        return ServerHostUserTake;
    })();

    NT.ClientHostUserTakeGold = (function() {

        /**
         * Properties of a ClientHostUserTakeGold.
         * @memberof NT
         * @interface IClientHostUserTakeGold
         * @property {string|null} [userId] ClientHostUserTakeGold userId
         * @property {number|null} [amount] ClientHostUserTakeGold amount
         * @property {boolean|null} [success] ClientHostUserTakeGold success
         */

        /**
         * Constructs a new ClientHostUserTakeGold.
         * @memberof NT
         * @classdesc Represents a ClientHostUserTakeGold.
         * @implements IClientHostUserTakeGold
         * @constructor
         * @param {NT.IClientHostUserTakeGold=} [properties] Properties to set
         */
        function ClientHostUserTakeGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientHostUserTakeGold userId.
         * @member {string} userId
         * @memberof NT.ClientHostUserTakeGold
         * @instance
         */
        ClientHostUserTakeGold.prototype.userId = "";

        /**
         * ClientHostUserTakeGold amount.
         * @member {number} amount
         * @memberof NT.ClientHostUserTakeGold
         * @instance
         */
        ClientHostUserTakeGold.prototype.amount = 0;

        /**
         * ClientHostUserTakeGold success.
         * @member {boolean} success
         * @memberof NT.ClientHostUserTakeGold
         * @instance
         */
        ClientHostUserTakeGold.prototype.success = false;

        /**
         * Creates a new ClientHostUserTakeGold instance using the specified properties.
         * @function create
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {NT.IClientHostUserTakeGold=} [properties] Properties to set
         * @returns {NT.ClientHostUserTakeGold} ClientHostUserTakeGold instance
         */
        ClientHostUserTakeGold.create = function create(properties) {
            return new ClientHostUserTakeGold(properties);
        };

        /**
         * Encodes the specified ClientHostUserTakeGold message. Does not implicitly {@link NT.ClientHostUserTakeGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {NT.IClientHostUserTakeGold} message ClientHostUserTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostUserTakeGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ClientHostUserTakeGold message, length delimited. Does not implicitly {@link NT.ClientHostUserTakeGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {NT.IClientHostUserTakeGold} message ClientHostUserTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientHostUserTakeGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientHostUserTakeGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientHostUserTakeGold} ClientHostUserTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostUserTakeGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientHostUserTakeGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.amount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.success = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientHostUserTakeGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientHostUserTakeGold} ClientHostUserTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientHostUserTakeGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientHostUserTakeGold message.
         * @function verify
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientHostUserTakeGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ClientHostUserTakeGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientHostUserTakeGold} ClientHostUserTakeGold
         */
        ClientHostUserTakeGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientHostUserTakeGold)
                return object;
            let message = new $root.NT.ClientHostUserTakeGold();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ClientHostUserTakeGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {NT.ClientHostUserTakeGold} message ClientHostUserTakeGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientHostUserTakeGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.amount = 0;
                object.success = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ClientHostUserTakeGold to JSON.
         * @function toJSON
         * @memberof NT.ClientHostUserTakeGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientHostUserTakeGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientHostUserTakeGold
         * @function getTypeUrl
         * @memberof NT.ClientHostUserTakeGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientHostUserTakeGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientHostUserTakeGold";
        };

        return ClientHostUserTakeGold;
    })();

    NT.ServerHostUserTakeGold = (function() {

        /**
         * Properties of a ServerHostUserTakeGold.
         * @memberof NT
         * @interface IServerHostUserTakeGold
         * @property {string|null} [userId] ServerHostUserTakeGold userId
         * @property {number|null} [amount] ServerHostUserTakeGold amount
         * @property {boolean|null} [success] ServerHostUserTakeGold success
         */

        /**
         * Constructs a new ServerHostUserTakeGold.
         * @memberof NT
         * @classdesc Represents a ServerHostUserTakeGold.
         * @implements IServerHostUserTakeGold
         * @constructor
         * @param {NT.IServerHostUserTakeGold=} [properties] Properties to set
         */
        function ServerHostUserTakeGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerHostUserTakeGold userId.
         * @member {string} userId
         * @memberof NT.ServerHostUserTakeGold
         * @instance
         */
        ServerHostUserTakeGold.prototype.userId = "";

        /**
         * ServerHostUserTakeGold amount.
         * @member {number} amount
         * @memberof NT.ServerHostUserTakeGold
         * @instance
         */
        ServerHostUserTakeGold.prototype.amount = 0;

        /**
         * ServerHostUserTakeGold success.
         * @member {boolean} success
         * @memberof NT.ServerHostUserTakeGold
         * @instance
         */
        ServerHostUserTakeGold.prototype.success = false;

        /**
         * Creates a new ServerHostUserTakeGold instance using the specified properties.
         * @function create
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {NT.IServerHostUserTakeGold=} [properties] Properties to set
         * @returns {NT.ServerHostUserTakeGold} ServerHostUserTakeGold instance
         */
        ServerHostUserTakeGold.create = function create(properties) {
            return new ServerHostUserTakeGold(properties);
        };

        /**
         * Encodes the specified ServerHostUserTakeGold message. Does not implicitly {@link NT.ServerHostUserTakeGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {NT.IServerHostUserTakeGold} message ServerHostUserTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostUserTakeGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
            if (message.success != null && Object.hasOwnProperty.call(message, "success"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.success);
            return writer;
        };

        /**
         * Encodes the specified ServerHostUserTakeGold message, length delimited. Does not implicitly {@link NT.ServerHostUserTakeGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {NT.IServerHostUserTakeGold} message ServerHostUserTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostUserTakeGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerHostUserTakeGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerHostUserTakeGold} ServerHostUserTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostUserTakeGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerHostUserTakeGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.amount = reader.uint32();
                        break;
                    }
                case 3: {
                        message.success = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerHostUserTakeGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerHostUserTakeGold} ServerHostUserTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostUserTakeGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerHostUserTakeGold message.
         * @function verify
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerHostUserTakeGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            if (message.success != null && message.hasOwnProperty("success"))
                if (typeof message.success !== "boolean")
                    return "success: boolean expected";
            return null;
        };

        /**
         * Creates a ServerHostUserTakeGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerHostUserTakeGold} ServerHostUserTakeGold
         */
        ServerHostUserTakeGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerHostUserTakeGold)
                return object;
            let message = new $root.NT.ServerHostUserTakeGold();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            if (object.success != null)
                message.success = Boolean(object.success);
            return message;
        };

        /**
         * Creates a plain object from a ServerHostUserTakeGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {NT.ServerHostUserTakeGold} message ServerHostUserTakeGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerHostUserTakeGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.amount = 0;
                object.success = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            if (message.success != null && message.hasOwnProperty("success"))
                object.success = message.success;
            return object;
        };

        /**
         * Converts this ServerHostUserTakeGold to JSON.
         * @function toJSON
         * @memberof NT.ServerHostUserTakeGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerHostUserTakeGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerHostUserTakeGold
         * @function getTypeUrl
         * @memberof NT.ServerHostUserTakeGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerHostUserTakeGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerHostUserTakeGold";
        };

        return ServerHostUserTakeGold;
    })();

    NT.ClientPlayerAddGold = (function() {

        /**
         * Properties of a ClientPlayerAddGold.
         * @memberof NT
         * @interface IClientPlayerAddGold
         * @property {number|null} [amount] ClientPlayerAddGold amount
         */

        /**
         * Constructs a new ClientPlayerAddGold.
         * @memberof NT
         * @classdesc Represents a ClientPlayerAddGold.
         * @implements IClientPlayerAddGold
         * @constructor
         * @param {NT.IClientPlayerAddGold=} [properties] Properties to set
         */
        function ClientPlayerAddGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerAddGold amount.
         * @member {number} amount
         * @memberof NT.ClientPlayerAddGold
         * @instance
         */
        ClientPlayerAddGold.prototype.amount = 0;

        /**
         * Creates a new ClientPlayerAddGold instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {NT.IClientPlayerAddGold=} [properties] Properties to set
         * @returns {NT.ClientPlayerAddGold} ClientPlayerAddGold instance
         */
        ClientPlayerAddGold.create = function create(properties) {
            return new ClientPlayerAddGold(properties);
        };

        /**
         * Encodes the specified ClientPlayerAddGold message. Does not implicitly {@link NT.ClientPlayerAddGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {NT.IClientPlayerAddGold} message ClientPlayerAddGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerAddGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerAddGold message, length delimited. Does not implicitly {@link NT.ClientPlayerAddGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {NT.IClientPlayerAddGold} message ClientPlayerAddGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerAddGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerAddGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerAddGold} ClientPlayerAddGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerAddGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerAddGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerAddGold} ClientPlayerAddGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerAddGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerAddGold message.
         * @function verify
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerAddGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ClientPlayerAddGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerAddGold} ClientPlayerAddGold
         */
        ClientPlayerAddGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerAddGold)
                return object;
            let message = new $root.NT.ClientPlayerAddGold();
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerAddGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {NT.ClientPlayerAddGold} message ClientPlayerAddGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerAddGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.amount = 0;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ClientPlayerAddGold to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerAddGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerAddGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerAddGold
         * @function getTypeUrl
         * @memberof NT.ClientPlayerAddGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerAddGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerAddGold";
        };

        return ClientPlayerAddGold;
    })();

    NT.ServerPlayerAddGold = (function() {

        /**
         * Properties of a ServerPlayerAddGold.
         * @memberof NT
         * @interface IServerPlayerAddGold
         * @property {string|null} [userId] ServerPlayerAddGold userId
         * @property {number|null} [amount] ServerPlayerAddGold amount
         */

        /**
         * Constructs a new ServerPlayerAddGold.
         * @memberof NT
         * @classdesc Represents a ServerPlayerAddGold.
         * @implements IServerPlayerAddGold
         * @constructor
         * @param {NT.IServerPlayerAddGold=} [properties] Properties to set
         */
        function ServerPlayerAddGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerAddGold userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerAddGold
         * @instance
         */
        ServerPlayerAddGold.prototype.userId = "";

        /**
         * ServerPlayerAddGold amount.
         * @member {number} amount
         * @memberof NT.ServerPlayerAddGold
         * @instance
         */
        ServerPlayerAddGold.prototype.amount = 0;

        /**
         * Creates a new ServerPlayerAddGold instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {NT.IServerPlayerAddGold=} [properties] Properties to set
         * @returns {NT.ServerPlayerAddGold} ServerPlayerAddGold instance
         */
        ServerPlayerAddGold.create = function create(properties) {
            return new ServerPlayerAddGold(properties);
        };

        /**
         * Encodes the specified ServerPlayerAddGold message. Does not implicitly {@link NT.ServerPlayerAddGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {NT.IServerPlayerAddGold} message ServerPlayerAddGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerAddGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerAddGold message, length delimited. Does not implicitly {@link NT.ServerPlayerAddGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {NT.IServerPlayerAddGold} message ServerPlayerAddGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerAddGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerAddGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerAddGold} ServerPlayerAddGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerAddGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerAddGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerAddGold} ServerPlayerAddGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerAddGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerAddGold message.
         * @function verify
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerAddGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ServerPlayerAddGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerAddGold} ServerPlayerAddGold
         */
        ServerPlayerAddGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerAddGold)
                return object;
            let message = new $root.NT.ServerPlayerAddGold();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerAddGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {NT.ServerPlayerAddGold} message ServerPlayerAddGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerAddGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.amount = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ServerPlayerAddGold to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerAddGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerAddGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerAddGold
         * @function getTypeUrl
         * @memberof NT.ServerPlayerAddGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerAddGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerAddGold";
        };

        return ServerPlayerAddGold;
    })();

    NT.ClientPlayerTakeGold = (function() {

        /**
         * Properties of a ClientPlayerTakeGold.
         * @memberof NT
         * @interface IClientPlayerTakeGold
         * @property {number|null} [amount] ClientPlayerTakeGold amount
         */

        /**
         * Constructs a new ClientPlayerTakeGold.
         * @memberof NT
         * @classdesc Represents a ClientPlayerTakeGold.
         * @implements IClientPlayerTakeGold
         * @constructor
         * @param {NT.IClientPlayerTakeGold=} [properties] Properties to set
         */
        function ClientPlayerTakeGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerTakeGold amount.
         * @member {number} amount
         * @memberof NT.ClientPlayerTakeGold
         * @instance
         */
        ClientPlayerTakeGold.prototype.amount = 0;

        /**
         * Creates a new ClientPlayerTakeGold instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {NT.IClientPlayerTakeGold=} [properties] Properties to set
         * @returns {NT.ClientPlayerTakeGold} ClientPlayerTakeGold instance
         */
        ClientPlayerTakeGold.create = function create(properties) {
            return new ClientPlayerTakeGold(properties);
        };

        /**
         * Encodes the specified ClientPlayerTakeGold message. Does not implicitly {@link NT.ClientPlayerTakeGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {NT.IClientPlayerTakeGold} message ClientPlayerTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerTakeGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerTakeGold message, length delimited. Does not implicitly {@link NT.ClientPlayerTakeGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {NT.IClientPlayerTakeGold} message ClientPlayerTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerTakeGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerTakeGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerTakeGold} ClientPlayerTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerTakeGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerTakeGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerTakeGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerTakeGold} ClientPlayerTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerTakeGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerTakeGold message.
         * @function verify
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerTakeGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ClientPlayerTakeGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerTakeGold} ClientPlayerTakeGold
         */
        ClientPlayerTakeGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerTakeGold)
                return object;
            let message = new $root.NT.ClientPlayerTakeGold();
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerTakeGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {NT.ClientPlayerTakeGold} message ClientPlayerTakeGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerTakeGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.amount = 0;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ClientPlayerTakeGold to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerTakeGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerTakeGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerTakeGold
         * @function getTypeUrl
         * @memberof NT.ClientPlayerTakeGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerTakeGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerTakeGold";
        };

        return ClientPlayerTakeGold;
    })();

    NT.ServerPlayerTakeGold = (function() {

        /**
         * Properties of a ServerPlayerTakeGold.
         * @memberof NT
         * @interface IServerPlayerTakeGold
         * @property {string|null} [userId] ServerPlayerTakeGold userId
         * @property {number|null} [amount] ServerPlayerTakeGold amount
         */

        /**
         * Constructs a new ServerPlayerTakeGold.
         * @memberof NT
         * @classdesc Represents a ServerPlayerTakeGold.
         * @implements IServerPlayerTakeGold
         * @constructor
         * @param {NT.IServerPlayerTakeGold=} [properties] Properties to set
         */
        function ServerPlayerTakeGold(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerTakeGold userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerTakeGold
         * @instance
         */
        ServerPlayerTakeGold.prototype.userId = "";

        /**
         * ServerPlayerTakeGold amount.
         * @member {number} amount
         * @memberof NT.ServerPlayerTakeGold
         * @instance
         */
        ServerPlayerTakeGold.prototype.amount = 0;

        /**
         * Creates a new ServerPlayerTakeGold instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {NT.IServerPlayerTakeGold=} [properties] Properties to set
         * @returns {NT.ServerPlayerTakeGold} ServerPlayerTakeGold instance
         */
        ServerPlayerTakeGold.create = function create(properties) {
            return new ServerPlayerTakeGold(properties);
        };

        /**
         * Encodes the specified ServerPlayerTakeGold message. Does not implicitly {@link NT.ServerPlayerTakeGold.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {NT.IServerPlayerTakeGold} message ServerPlayerTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerTakeGold.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerTakeGold message, length delimited. Does not implicitly {@link NT.ServerPlayerTakeGold.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {NT.IServerPlayerTakeGold} message ServerPlayerTakeGold message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerTakeGold.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerTakeGold message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerTakeGold} ServerPlayerTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerTakeGold.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerTakeGold();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerTakeGold message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerTakeGold} ServerPlayerTakeGold
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerTakeGold.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerTakeGold message.
         * @function verify
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerTakeGold.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ServerPlayerTakeGold message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerTakeGold} ServerPlayerTakeGold
         */
        ServerPlayerTakeGold.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerTakeGold)
                return object;
            let message = new $root.NT.ServerPlayerTakeGold();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerTakeGold message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {NT.ServerPlayerTakeGold} message ServerPlayerTakeGold
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerTakeGold.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.amount = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ServerPlayerTakeGold to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerTakeGold
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerTakeGold.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerTakeGold
         * @function getTypeUrl
         * @memberof NT.ServerPlayerTakeGold
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerTakeGold.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerTakeGold";
        };

        return ServerPlayerTakeGold;
    })();

    NT.ClientPlayerAddItem = (function() {

        /**
         * Properties of a ClientPlayerAddItem.
         * @memberof NT
         * @interface IClientPlayerAddItem
         * @property {NT.ClientPlayerAddItem.ISpells|null} [spells] ClientPlayerAddItem spells
         * @property {NT.ClientPlayerAddItem.IWands|null} [wands] ClientPlayerAddItem wands
         * @property {NT.ClientPlayerAddItem.IItems|null} [flasks] ClientPlayerAddItem flasks
         * @property {NT.ClientPlayerAddItem.IEntities|null} [objects] ClientPlayerAddItem objects
         */

        /**
         * Constructs a new ClientPlayerAddItem.
         * @memberof NT
         * @classdesc Represents a ClientPlayerAddItem.
         * @implements IClientPlayerAddItem
         * @constructor
         * @param {NT.IClientPlayerAddItem=} [properties] Properties to set
         */
        function ClientPlayerAddItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerAddItem spells.
         * @member {NT.ClientPlayerAddItem.ISpells|null|undefined} spells
         * @memberof NT.ClientPlayerAddItem
         * @instance
         */
        ClientPlayerAddItem.prototype.spells = null;

        /**
         * ClientPlayerAddItem wands.
         * @member {NT.ClientPlayerAddItem.IWands|null|undefined} wands
         * @memberof NT.ClientPlayerAddItem
         * @instance
         */
        ClientPlayerAddItem.prototype.wands = null;

        /**
         * ClientPlayerAddItem flasks.
         * @member {NT.ClientPlayerAddItem.IItems|null|undefined} flasks
         * @memberof NT.ClientPlayerAddItem
         * @instance
         */
        ClientPlayerAddItem.prototype.flasks = null;

        /**
         * ClientPlayerAddItem objects.
         * @member {NT.ClientPlayerAddItem.IEntities|null|undefined} objects
         * @memberof NT.ClientPlayerAddItem
         * @instance
         */
        ClientPlayerAddItem.prototype.objects = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientPlayerAddItem item.
         * @member {"spells"|"wands"|"flasks"|"objects"|undefined} item
         * @memberof NT.ClientPlayerAddItem
         * @instance
         */
        Object.defineProperty(ClientPlayerAddItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["spells", "wands", "flasks", "objects"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientPlayerAddItem instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {NT.IClientPlayerAddItem=} [properties] Properties to set
         * @returns {NT.ClientPlayerAddItem} ClientPlayerAddItem instance
         */
        ClientPlayerAddItem.create = function create(properties) {
            return new ClientPlayerAddItem(properties);
        };

        /**
         * Encodes the specified ClientPlayerAddItem message. Does not implicitly {@link NT.ClientPlayerAddItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {NT.IClientPlayerAddItem} message ClientPlayerAddItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerAddItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.spells != null && Object.hasOwnProperty.call(message, "spells"))
                $root.NT.ClientPlayerAddItem.Spells.encode(message.spells, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.wands != null && Object.hasOwnProperty.call(message, "wands"))
                $root.NT.ClientPlayerAddItem.Wands.encode(message.wands, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.flasks != null && Object.hasOwnProperty.call(message, "flasks"))
                $root.NT.ClientPlayerAddItem.Items.encode(message.flasks, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.objects != null && Object.hasOwnProperty.call(message, "objects"))
                $root.NT.ClientPlayerAddItem.Entities.encode(message.objects, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerAddItem message, length delimited. Does not implicitly {@link NT.ClientPlayerAddItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {NT.IClientPlayerAddItem} message ClientPlayerAddItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerAddItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerAddItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerAddItem} ClientPlayerAddItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerAddItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.spells = $root.NT.ClientPlayerAddItem.Spells.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.wands = $root.NT.ClientPlayerAddItem.Wands.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.flasks = $root.NT.ClientPlayerAddItem.Items.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.objects = $root.NT.ClientPlayerAddItem.Entities.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerAddItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerAddItem} ClientPlayerAddItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerAddItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerAddItem message.
         * @function verify
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerAddItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.spells != null && message.hasOwnProperty("spells")) {
                properties.item = 1;
                {
                    let error = $root.NT.ClientPlayerAddItem.Spells.verify(message.spells);
                    if (error)
                        return "spells." + error;
                }
            }
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ClientPlayerAddItem.Wands.verify(message.wands);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.flasks != null && message.hasOwnProperty("flasks")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ClientPlayerAddItem.Items.verify(message.flasks);
                    if (error)
                        return "flasks." + error;
                }
            }
            if (message.objects != null && message.hasOwnProperty("objects")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ClientPlayerAddItem.Entities.verify(message.objects);
                    if (error)
                        return "objects." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientPlayerAddItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerAddItem} ClientPlayerAddItem
         */
        ClientPlayerAddItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerAddItem)
                return object;
            let message = new $root.NT.ClientPlayerAddItem();
            if (object.spells != null) {
                if (typeof object.spells !== "object")
                    throw TypeError(".NT.ClientPlayerAddItem.spells: object expected");
                message.spells = $root.NT.ClientPlayerAddItem.Spells.fromObject(object.spells);
            }
            if (object.wands != null) {
                if (typeof object.wands !== "object")
                    throw TypeError(".NT.ClientPlayerAddItem.wands: object expected");
                message.wands = $root.NT.ClientPlayerAddItem.Wands.fromObject(object.wands);
            }
            if (object.flasks != null) {
                if (typeof object.flasks !== "object")
                    throw TypeError(".NT.ClientPlayerAddItem.flasks: object expected");
                message.flasks = $root.NT.ClientPlayerAddItem.Items.fromObject(object.flasks);
            }
            if (object.objects != null) {
                if (typeof object.objects !== "object")
                    throw TypeError(".NT.ClientPlayerAddItem.objects: object expected");
                message.objects = $root.NT.ClientPlayerAddItem.Entities.fromObject(object.objects);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerAddItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {NT.ClientPlayerAddItem} message ClientPlayerAddItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerAddItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.spells != null && message.hasOwnProperty("spells")) {
                object.spells = $root.NT.ClientPlayerAddItem.Spells.toObject(message.spells, options);
                if (options.oneofs)
                    object.item = "spells";
            }
            if (message.wands != null && message.hasOwnProperty("wands")) {
                object.wands = $root.NT.ClientPlayerAddItem.Wands.toObject(message.wands, options);
                if (options.oneofs)
                    object.item = "wands";
            }
            if (message.flasks != null && message.hasOwnProperty("flasks")) {
                object.flasks = $root.NT.ClientPlayerAddItem.Items.toObject(message.flasks, options);
                if (options.oneofs)
                    object.item = "flasks";
            }
            if (message.objects != null && message.hasOwnProperty("objects")) {
                object.objects = $root.NT.ClientPlayerAddItem.Entities.toObject(message.objects, options);
                if (options.oneofs)
                    object.item = "objects";
            }
            return object;
        };

        /**
         * Converts this ClientPlayerAddItem to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerAddItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerAddItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerAddItem
         * @function getTypeUrl
         * @memberof NT.ClientPlayerAddItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerAddItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerAddItem";
        };

        ClientPlayerAddItem.Spells = (function() {

            /**
             * Properties of a Spells.
             * @memberof NT.ClientPlayerAddItem
             * @interface ISpells
             * @property {Array.<NT.ISpell>|null} [list] Spells list
             */

            /**
             * Constructs a new Spells.
             * @memberof NT.ClientPlayerAddItem
             * @classdesc Represents a Spells.
             * @implements ISpells
             * @constructor
             * @param {NT.ClientPlayerAddItem.ISpells=} [properties] Properties to set
             */
            function Spells(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Spells list.
             * @member {Array.<NT.ISpell>} list
             * @memberof NT.ClientPlayerAddItem.Spells
             * @instance
             */
            Spells.prototype.list = $util.emptyArray;

            /**
             * Creates a new Spells instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {NT.ClientPlayerAddItem.ISpells=} [properties] Properties to set
             * @returns {NT.ClientPlayerAddItem.Spells} Spells instance
             */
            Spells.create = function create(properties) {
                return new Spells(properties);
            };

            /**
             * Encodes the specified Spells message. Does not implicitly {@link NT.ClientPlayerAddItem.Spells.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {NT.ClientPlayerAddItem.ISpells} message Spells message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Spells.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Spell.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Spells message, length delimited. Does not implicitly {@link NT.ClientPlayerAddItem.Spells.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {NT.ClientPlayerAddItem.ISpells} message Spells message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Spells.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Spells message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerAddItem.Spells} Spells
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Spells.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddItem.Spells();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Spell.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Spells message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerAddItem.Spells} Spells
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Spells.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Spells message.
             * @function verify
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Spells.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Spell.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Spells message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerAddItem.Spells} Spells
             */
            Spells.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerAddItem.Spells)
                    return object;
                let message = new $root.NT.ClientPlayerAddItem.Spells();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ClientPlayerAddItem.Spells.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ClientPlayerAddItem.Spells.list: object expected");
                        message.list[i] = $root.NT.Spell.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Spells message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {NT.ClientPlayerAddItem.Spells} message Spells
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Spells.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Spell.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Spells to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerAddItem.Spells
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Spells.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Spells
             * @function getTypeUrl
             * @memberof NT.ClientPlayerAddItem.Spells
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Spells.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerAddItem.Spells";
            };

            return Spells;
        })();

        ClientPlayerAddItem.Wands = (function() {

            /**
             * Properties of a Wands.
             * @memberof NT.ClientPlayerAddItem
             * @interface IWands
             * @property {Array.<NT.IWand>|null} [list] Wands list
             */

            /**
             * Constructs a new Wands.
             * @memberof NT.ClientPlayerAddItem
             * @classdesc Represents a Wands.
             * @implements IWands
             * @constructor
             * @param {NT.ClientPlayerAddItem.IWands=} [properties] Properties to set
             */
            function Wands(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Wands list.
             * @member {Array.<NT.IWand>} list
             * @memberof NT.ClientPlayerAddItem.Wands
             * @instance
             */
            Wands.prototype.list = $util.emptyArray;

            /**
             * Creates a new Wands instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {NT.ClientPlayerAddItem.IWands=} [properties] Properties to set
             * @returns {NT.ClientPlayerAddItem.Wands} Wands instance
             */
            Wands.create = function create(properties) {
                return new Wands(properties);
            };

            /**
             * Encodes the specified Wands message. Does not implicitly {@link NT.ClientPlayerAddItem.Wands.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {NT.ClientPlayerAddItem.IWands} message Wands message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wands.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Wand.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Wands message, length delimited. Does not implicitly {@link NT.ClientPlayerAddItem.Wands.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {NT.ClientPlayerAddItem.IWands} message Wands message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wands.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Wands message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerAddItem.Wands} Wands
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wands.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddItem.Wands();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Wand.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Wands message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerAddItem.Wands} Wands
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wands.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Wands message.
             * @function verify
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Wands.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Wand.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Wands message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerAddItem.Wands} Wands
             */
            Wands.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerAddItem.Wands)
                    return object;
                let message = new $root.NT.ClientPlayerAddItem.Wands();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ClientPlayerAddItem.Wands.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ClientPlayerAddItem.Wands.list: object expected");
                        message.list[i] = $root.NT.Wand.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Wands message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {NT.ClientPlayerAddItem.Wands} message Wands
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Wands.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Wand.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Wands to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerAddItem.Wands
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Wands.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Wands
             * @function getTypeUrl
             * @memberof NT.ClientPlayerAddItem.Wands
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Wands.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerAddItem.Wands";
            };

            return Wands;
        })();

        ClientPlayerAddItem.Items = (function() {

            /**
             * Properties of an Items.
             * @memberof NT.ClientPlayerAddItem
             * @interface IItems
             * @property {Array.<NT.IItem>|null} [list] Items list
             */

            /**
             * Constructs a new Items.
             * @memberof NT.ClientPlayerAddItem
             * @classdesc Represents an Items.
             * @implements IItems
             * @constructor
             * @param {NT.ClientPlayerAddItem.IItems=} [properties] Properties to set
             */
            function Items(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Items list.
             * @member {Array.<NT.IItem>} list
             * @memberof NT.ClientPlayerAddItem.Items
             * @instance
             */
            Items.prototype.list = $util.emptyArray;

            /**
             * Creates a new Items instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {NT.ClientPlayerAddItem.IItems=} [properties] Properties to set
             * @returns {NT.ClientPlayerAddItem.Items} Items instance
             */
            Items.create = function create(properties) {
                return new Items(properties);
            };

            /**
             * Encodes the specified Items message. Does not implicitly {@link NT.ClientPlayerAddItem.Items.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {NT.ClientPlayerAddItem.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Item.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Items message, length delimited. Does not implicitly {@link NT.ClientPlayerAddItem.Items.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {NT.ClientPlayerAddItem.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Items message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerAddItem.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddItem.Items();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Item.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Items message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerAddItem.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Items message.
             * @function verify
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Items.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Item.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Items message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerAddItem.Items} Items
             */
            Items.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerAddItem.Items)
                    return object;
                let message = new $root.NT.ClientPlayerAddItem.Items();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ClientPlayerAddItem.Items.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ClientPlayerAddItem.Items.list: object expected");
                        message.list[i] = $root.NT.Item.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Items message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {NT.ClientPlayerAddItem.Items} message Items
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Items.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Item.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Items to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerAddItem.Items
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Items.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Items
             * @function getTypeUrl
             * @memberof NT.ClientPlayerAddItem.Items
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerAddItem.Items";
            };

            return Items;
        })();

        ClientPlayerAddItem.Entities = (function() {

            /**
             * Properties of an Entities.
             * @memberof NT.ClientPlayerAddItem
             * @interface IEntities
             * @property {Array.<NT.IEntityItem>|null} [list] Entities list
             */

            /**
             * Constructs a new Entities.
             * @memberof NT.ClientPlayerAddItem
             * @classdesc Represents an Entities.
             * @implements IEntities
             * @constructor
             * @param {NT.ClientPlayerAddItem.IEntities=} [properties] Properties to set
             */
            function Entities(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entities list.
             * @member {Array.<NT.IEntityItem>} list
             * @memberof NT.ClientPlayerAddItem.Entities
             * @instance
             */
            Entities.prototype.list = $util.emptyArray;

            /**
             * Creates a new Entities instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {NT.ClientPlayerAddItem.IEntities=} [properties] Properties to set
             * @returns {NT.ClientPlayerAddItem.Entities} Entities instance
             */
            Entities.create = function create(properties) {
                return new Entities(properties);
            };

            /**
             * Encodes the specified Entities message. Does not implicitly {@link NT.ClientPlayerAddItem.Entities.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {NT.ClientPlayerAddItem.IEntities} message Entities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entities.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.EntityItem.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Entities message, length delimited. Does not implicitly {@link NT.ClientPlayerAddItem.Entities.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {NT.ClientPlayerAddItem.IEntities} message Entities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entities.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entities message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerAddItem.Entities} Entities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entities.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerAddItem.Entities();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.EntityItem.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entities message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerAddItem.Entities} Entities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entities.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entities message.
             * @function verify
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entities.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.EntityItem.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Entities message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerAddItem.Entities} Entities
             */
            Entities.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerAddItem.Entities)
                    return object;
                let message = new $root.NT.ClientPlayerAddItem.Entities();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ClientPlayerAddItem.Entities.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ClientPlayerAddItem.Entities.list: object expected");
                        message.list[i] = $root.NT.EntityItem.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Entities message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {NT.ClientPlayerAddItem.Entities} message Entities
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entities.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.EntityItem.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Entities to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerAddItem.Entities
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entities.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Entities
             * @function getTypeUrl
             * @memberof NT.ClientPlayerAddItem.Entities
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Entities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerAddItem.Entities";
            };

            return Entities;
        })();

        return ClientPlayerAddItem;
    })();

    NT.ServerPlayerAddItem = (function() {

        /**
         * Properties of a ServerPlayerAddItem.
         * @memberof NT
         * @interface IServerPlayerAddItem
         * @property {string|null} [userId] ServerPlayerAddItem userId
         * @property {NT.ServerPlayerAddItem.ISpells|null} [spells] ServerPlayerAddItem spells
         * @property {NT.ServerPlayerAddItem.IWands|null} [wands] ServerPlayerAddItem wands
         * @property {NT.ServerPlayerAddItem.IItems|null} [flasks] ServerPlayerAddItem flasks
         * @property {NT.ServerPlayerAddItem.IEntities|null} [objects] ServerPlayerAddItem objects
         */

        /**
         * Constructs a new ServerPlayerAddItem.
         * @memberof NT
         * @classdesc Represents a ServerPlayerAddItem.
         * @implements IServerPlayerAddItem
         * @constructor
         * @param {NT.IServerPlayerAddItem=} [properties] Properties to set
         */
        function ServerPlayerAddItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerAddItem userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        ServerPlayerAddItem.prototype.userId = "";

        /**
         * ServerPlayerAddItem spells.
         * @member {NT.ServerPlayerAddItem.ISpells|null|undefined} spells
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        ServerPlayerAddItem.prototype.spells = null;

        /**
         * ServerPlayerAddItem wands.
         * @member {NT.ServerPlayerAddItem.IWands|null|undefined} wands
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        ServerPlayerAddItem.prototype.wands = null;

        /**
         * ServerPlayerAddItem flasks.
         * @member {NT.ServerPlayerAddItem.IItems|null|undefined} flasks
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        ServerPlayerAddItem.prototype.flasks = null;

        /**
         * ServerPlayerAddItem objects.
         * @member {NT.ServerPlayerAddItem.IEntities|null|undefined} objects
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        ServerPlayerAddItem.prototype.objects = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerPlayerAddItem item.
         * @member {"spells"|"wands"|"flasks"|"objects"|undefined} item
         * @memberof NT.ServerPlayerAddItem
         * @instance
         */
        Object.defineProperty(ServerPlayerAddItem.prototype, "item", {
            get: $util.oneOfGetter($oneOfFields = ["spells", "wands", "flasks", "objects"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerPlayerAddItem instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {NT.IServerPlayerAddItem=} [properties] Properties to set
         * @returns {NT.ServerPlayerAddItem} ServerPlayerAddItem instance
         */
        ServerPlayerAddItem.create = function create(properties) {
            return new ServerPlayerAddItem(properties);
        };

        /**
         * Encodes the specified ServerPlayerAddItem message. Does not implicitly {@link NT.ServerPlayerAddItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {NT.IServerPlayerAddItem} message ServerPlayerAddItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerAddItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.spells != null && Object.hasOwnProperty.call(message, "spells"))
                $root.NT.ServerPlayerAddItem.Spells.encode(message.spells, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.wands != null && Object.hasOwnProperty.call(message, "wands"))
                $root.NT.ServerPlayerAddItem.Wands.encode(message.wands, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.flasks != null && Object.hasOwnProperty.call(message, "flasks"))
                $root.NT.ServerPlayerAddItem.Items.encode(message.flasks, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.objects != null && Object.hasOwnProperty.call(message, "objects"))
                $root.NT.ServerPlayerAddItem.Entities.encode(message.objects, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerAddItem message, length delimited. Does not implicitly {@link NT.ServerPlayerAddItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {NT.IServerPlayerAddItem} message ServerPlayerAddItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerAddItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerAddItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerAddItem} ServerPlayerAddItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerAddItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.spells = $root.NT.ServerPlayerAddItem.Spells.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.wands = $root.NT.ServerPlayerAddItem.Wands.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.flasks = $root.NT.ServerPlayerAddItem.Items.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.objects = $root.NT.ServerPlayerAddItem.Entities.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerAddItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerAddItem} ServerPlayerAddItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerAddItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerAddItem message.
         * @function verify
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerAddItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.spells != null && message.hasOwnProperty("spells")) {
                properties.item = 1;
                {
                    let error = $root.NT.ServerPlayerAddItem.Spells.verify(message.spells);
                    if (error)
                        return "spells." + error;
                }
            }
            if (message.wands != null && message.hasOwnProperty("wands")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ServerPlayerAddItem.Wands.verify(message.wands);
                    if (error)
                        return "wands." + error;
                }
            }
            if (message.flasks != null && message.hasOwnProperty("flasks")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ServerPlayerAddItem.Items.verify(message.flasks);
                    if (error)
                        return "flasks." + error;
                }
            }
            if (message.objects != null && message.hasOwnProperty("objects")) {
                if (properties.item === 1)
                    return "item: multiple values";
                properties.item = 1;
                {
                    let error = $root.NT.ServerPlayerAddItem.Entities.verify(message.objects);
                    if (error)
                        return "objects." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerPlayerAddItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerAddItem} ServerPlayerAddItem
         */
        ServerPlayerAddItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerAddItem)
                return object;
            let message = new $root.NT.ServerPlayerAddItem();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.spells != null) {
                if (typeof object.spells !== "object")
                    throw TypeError(".NT.ServerPlayerAddItem.spells: object expected");
                message.spells = $root.NT.ServerPlayerAddItem.Spells.fromObject(object.spells);
            }
            if (object.wands != null) {
                if (typeof object.wands !== "object")
                    throw TypeError(".NT.ServerPlayerAddItem.wands: object expected");
                message.wands = $root.NT.ServerPlayerAddItem.Wands.fromObject(object.wands);
            }
            if (object.flasks != null) {
                if (typeof object.flasks !== "object")
                    throw TypeError(".NT.ServerPlayerAddItem.flasks: object expected");
                message.flasks = $root.NT.ServerPlayerAddItem.Items.fromObject(object.flasks);
            }
            if (object.objects != null) {
                if (typeof object.objects !== "object")
                    throw TypeError(".NT.ServerPlayerAddItem.objects: object expected");
                message.objects = $root.NT.ServerPlayerAddItem.Entities.fromObject(object.objects);
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerAddItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {NT.ServerPlayerAddItem} message ServerPlayerAddItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerAddItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.spells != null && message.hasOwnProperty("spells")) {
                object.spells = $root.NT.ServerPlayerAddItem.Spells.toObject(message.spells, options);
                if (options.oneofs)
                    object.item = "spells";
            }
            if (message.wands != null && message.hasOwnProperty("wands")) {
                object.wands = $root.NT.ServerPlayerAddItem.Wands.toObject(message.wands, options);
                if (options.oneofs)
                    object.item = "wands";
            }
            if (message.flasks != null && message.hasOwnProperty("flasks")) {
                object.flasks = $root.NT.ServerPlayerAddItem.Items.toObject(message.flasks, options);
                if (options.oneofs)
                    object.item = "flasks";
            }
            if (message.objects != null && message.hasOwnProperty("objects")) {
                object.objects = $root.NT.ServerPlayerAddItem.Entities.toObject(message.objects, options);
                if (options.oneofs)
                    object.item = "objects";
            }
            return object;
        };

        /**
         * Converts this ServerPlayerAddItem to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerAddItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerAddItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerAddItem
         * @function getTypeUrl
         * @memberof NT.ServerPlayerAddItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerAddItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerAddItem";
        };

        ServerPlayerAddItem.Spells = (function() {

            /**
             * Properties of a Spells.
             * @memberof NT.ServerPlayerAddItem
             * @interface ISpells
             * @property {Array.<NT.ISpell>|null} [list] Spells list
             */

            /**
             * Constructs a new Spells.
             * @memberof NT.ServerPlayerAddItem
             * @classdesc Represents a Spells.
             * @implements ISpells
             * @constructor
             * @param {NT.ServerPlayerAddItem.ISpells=} [properties] Properties to set
             */
            function Spells(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Spells list.
             * @member {Array.<NT.ISpell>} list
             * @memberof NT.ServerPlayerAddItem.Spells
             * @instance
             */
            Spells.prototype.list = $util.emptyArray;

            /**
             * Creates a new Spells instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {NT.ServerPlayerAddItem.ISpells=} [properties] Properties to set
             * @returns {NT.ServerPlayerAddItem.Spells} Spells instance
             */
            Spells.create = function create(properties) {
                return new Spells(properties);
            };

            /**
             * Encodes the specified Spells message. Does not implicitly {@link NT.ServerPlayerAddItem.Spells.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {NT.ServerPlayerAddItem.ISpells} message Spells message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Spells.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Spell.encode(message.list[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Spells message, length delimited. Does not implicitly {@link NT.ServerPlayerAddItem.Spells.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {NT.ServerPlayerAddItem.ISpells} message Spells message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Spells.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Spells message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerAddItem.Spells} Spells
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Spells.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddItem.Spells();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Spell.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Spells message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerAddItem.Spells} Spells
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Spells.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Spells message.
             * @function verify
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Spells.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Spell.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Spells message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerAddItem.Spells} Spells
             */
            Spells.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerAddItem.Spells)
                    return object;
                let message = new $root.NT.ServerPlayerAddItem.Spells();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ServerPlayerAddItem.Spells.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ServerPlayerAddItem.Spells.list: object expected");
                        message.list[i] = $root.NT.Spell.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Spells message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {NT.ServerPlayerAddItem.Spells} message Spells
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Spells.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Spell.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Spells to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerAddItem.Spells
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Spells.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Spells
             * @function getTypeUrl
             * @memberof NT.ServerPlayerAddItem.Spells
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Spells.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerAddItem.Spells";
            };

            return Spells;
        })();

        ServerPlayerAddItem.Wands = (function() {

            /**
             * Properties of a Wands.
             * @memberof NT.ServerPlayerAddItem
             * @interface IWands
             * @property {Array.<NT.IWand>|null} [list] Wands list
             */

            /**
             * Constructs a new Wands.
             * @memberof NT.ServerPlayerAddItem
             * @classdesc Represents a Wands.
             * @implements IWands
             * @constructor
             * @param {NT.ServerPlayerAddItem.IWands=} [properties] Properties to set
             */
            function Wands(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Wands list.
             * @member {Array.<NT.IWand>} list
             * @memberof NT.ServerPlayerAddItem.Wands
             * @instance
             */
            Wands.prototype.list = $util.emptyArray;

            /**
             * Creates a new Wands instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {NT.ServerPlayerAddItem.IWands=} [properties] Properties to set
             * @returns {NT.ServerPlayerAddItem.Wands} Wands instance
             */
            Wands.create = function create(properties) {
                return new Wands(properties);
            };

            /**
             * Encodes the specified Wands message. Does not implicitly {@link NT.ServerPlayerAddItem.Wands.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {NT.ServerPlayerAddItem.IWands} message Wands message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wands.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Wand.encode(message.list[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Wands message, length delimited. Does not implicitly {@link NT.ServerPlayerAddItem.Wands.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {NT.ServerPlayerAddItem.IWands} message Wands message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Wands.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Wands message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerAddItem.Wands} Wands
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wands.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddItem.Wands();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Wand.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Wands message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerAddItem.Wands} Wands
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Wands.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Wands message.
             * @function verify
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Wands.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Wand.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Wands message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerAddItem.Wands} Wands
             */
            Wands.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerAddItem.Wands)
                    return object;
                let message = new $root.NT.ServerPlayerAddItem.Wands();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ServerPlayerAddItem.Wands.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ServerPlayerAddItem.Wands.list: object expected");
                        message.list[i] = $root.NT.Wand.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Wands message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {NT.ServerPlayerAddItem.Wands} message Wands
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Wands.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Wand.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Wands to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerAddItem.Wands
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Wands.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Wands
             * @function getTypeUrl
             * @memberof NT.ServerPlayerAddItem.Wands
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Wands.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerAddItem.Wands";
            };

            return Wands;
        })();

        ServerPlayerAddItem.Items = (function() {

            /**
             * Properties of an Items.
             * @memberof NT.ServerPlayerAddItem
             * @interface IItems
             * @property {Array.<NT.IItem>|null} [list] Items list
             */

            /**
             * Constructs a new Items.
             * @memberof NT.ServerPlayerAddItem
             * @classdesc Represents an Items.
             * @implements IItems
             * @constructor
             * @param {NT.ServerPlayerAddItem.IItems=} [properties] Properties to set
             */
            function Items(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Items list.
             * @member {Array.<NT.IItem>} list
             * @memberof NT.ServerPlayerAddItem.Items
             * @instance
             */
            Items.prototype.list = $util.emptyArray;

            /**
             * Creates a new Items instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {NT.ServerPlayerAddItem.IItems=} [properties] Properties to set
             * @returns {NT.ServerPlayerAddItem.Items} Items instance
             */
            Items.create = function create(properties) {
                return new Items(properties);
            };

            /**
             * Encodes the specified Items message. Does not implicitly {@link NT.ServerPlayerAddItem.Items.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {NT.ServerPlayerAddItem.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.Item.encode(message.list[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Items message, length delimited. Does not implicitly {@link NT.ServerPlayerAddItem.Items.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {NT.ServerPlayerAddItem.IItems} message Items message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Items.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Items message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerAddItem.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddItem.Items();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.Item.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Items message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerAddItem.Items} Items
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Items.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Items message.
             * @function verify
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Items.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.Item.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Items message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerAddItem.Items} Items
             */
            Items.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerAddItem.Items)
                    return object;
                let message = new $root.NT.ServerPlayerAddItem.Items();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ServerPlayerAddItem.Items.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ServerPlayerAddItem.Items.list: object expected");
                        message.list[i] = $root.NT.Item.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Items message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {NT.ServerPlayerAddItem.Items} message Items
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Items.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.Item.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Items to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerAddItem.Items
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Items.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Items
             * @function getTypeUrl
             * @memberof NT.ServerPlayerAddItem.Items
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Items.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerAddItem.Items";
            };

            return Items;
        })();

        ServerPlayerAddItem.Entities = (function() {

            /**
             * Properties of an Entities.
             * @memberof NT.ServerPlayerAddItem
             * @interface IEntities
             * @property {Array.<NT.IEntityItem>|null} [list] Entities list
             */

            /**
             * Constructs a new Entities.
             * @memberof NT.ServerPlayerAddItem
             * @classdesc Represents an Entities.
             * @implements IEntities
             * @constructor
             * @param {NT.ServerPlayerAddItem.IEntities=} [properties] Properties to set
             */
            function Entities(properties) {
                this.list = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Entities list.
             * @member {Array.<NT.IEntityItem>} list
             * @memberof NT.ServerPlayerAddItem.Entities
             * @instance
             */
            Entities.prototype.list = $util.emptyArray;

            /**
             * Creates a new Entities instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {NT.ServerPlayerAddItem.IEntities=} [properties] Properties to set
             * @returns {NT.ServerPlayerAddItem.Entities} Entities instance
             */
            Entities.create = function create(properties) {
                return new Entities(properties);
            };

            /**
             * Encodes the specified Entities message. Does not implicitly {@link NT.ServerPlayerAddItem.Entities.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {NT.ServerPlayerAddItem.IEntities} message Entities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entities.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.list != null && message.list.length)
                    for (let i = 0; i < message.list.length; ++i)
                        $root.NT.EntityItem.encode(message.list[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Entities message, length delimited. Does not implicitly {@link NT.ServerPlayerAddItem.Entities.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {NT.ServerPlayerAddItem.IEntities} message Entities message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Entities.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Entities message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerAddItem.Entities} Entities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entities.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerAddItem.Entities();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 4: {
                            if (!(message.list && message.list.length))
                                message.list = [];
                            message.list.push($root.NT.EntityItem.decode(reader, reader.uint32()));
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Entities message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerAddItem.Entities} Entities
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Entities.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Entities message.
             * @function verify
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Entities.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.list != null && message.hasOwnProperty("list")) {
                    if (!Array.isArray(message.list))
                        return "list: array expected";
                    for (let i = 0; i < message.list.length; ++i) {
                        let error = $root.NT.EntityItem.verify(message.list[i]);
                        if (error)
                            return "list." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Entities message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerAddItem.Entities} Entities
             */
            Entities.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerAddItem.Entities)
                    return object;
                let message = new $root.NT.ServerPlayerAddItem.Entities();
                if (object.list) {
                    if (!Array.isArray(object.list))
                        throw TypeError(".NT.ServerPlayerAddItem.Entities.list: array expected");
                    message.list = [];
                    for (let i = 0; i < object.list.length; ++i) {
                        if (typeof object.list[i] !== "object")
                            throw TypeError(".NT.ServerPlayerAddItem.Entities.list: object expected");
                        message.list[i] = $root.NT.EntityItem.fromObject(object.list[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Entities message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {NT.ServerPlayerAddItem.Entities} message Entities
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Entities.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.list = [];
                if (message.list && message.list.length) {
                    object.list = [];
                    for (let j = 0; j < message.list.length; ++j)
                        object.list[j] = $root.NT.EntityItem.toObject(message.list[j], options);
                }
                return object;
            };

            /**
             * Converts this Entities to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerAddItem.Entities
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Entities.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Entities
             * @function getTypeUrl
             * @memberof NT.ServerPlayerAddItem.Entities
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Entities.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerAddItem.Entities";
            };

            return Entities;
        })();

        return ServerPlayerAddItem;
    })();

    NT.ClientPlayerTakeItem = (function() {

        /**
         * Properties of a ClientPlayerTakeItem.
         * @memberof NT
         * @interface IClientPlayerTakeItem
         * @property {string|null} [id] ClientPlayerTakeItem id
         */

        /**
         * Constructs a new ClientPlayerTakeItem.
         * @memberof NT
         * @classdesc Represents a ClientPlayerTakeItem.
         * @implements IClientPlayerTakeItem
         * @constructor
         * @param {NT.IClientPlayerTakeItem=} [properties] Properties to set
         */
        function ClientPlayerTakeItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerTakeItem id.
         * @member {string} id
         * @memberof NT.ClientPlayerTakeItem
         * @instance
         */
        ClientPlayerTakeItem.prototype.id = "";

        /**
         * Creates a new ClientPlayerTakeItem instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {NT.IClientPlayerTakeItem=} [properties] Properties to set
         * @returns {NT.ClientPlayerTakeItem} ClientPlayerTakeItem instance
         */
        ClientPlayerTakeItem.create = function create(properties) {
            return new ClientPlayerTakeItem(properties);
        };

        /**
         * Encodes the specified ClientPlayerTakeItem message. Does not implicitly {@link NT.ClientPlayerTakeItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {NT.IClientPlayerTakeItem} message ClientPlayerTakeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerTakeItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerTakeItem message, length delimited. Does not implicitly {@link NT.ClientPlayerTakeItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {NT.IClientPlayerTakeItem} message ClientPlayerTakeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerTakeItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerTakeItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerTakeItem} ClientPlayerTakeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerTakeItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerTakeItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerTakeItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerTakeItem} ClientPlayerTakeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerTakeItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerTakeItem message.
         * @function verify
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerTakeItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ClientPlayerTakeItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerTakeItem} ClientPlayerTakeItem
         */
        ClientPlayerTakeItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerTakeItem)
                return object;
            let message = new $root.NT.ClientPlayerTakeItem();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerTakeItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {NT.ClientPlayerTakeItem} message ClientPlayerTakeItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerTakeItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ClientPlayerTakeItem to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerTakeItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerTakeItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerTakeItem
         * @function getTypeUrl
         * @memberof NT.ClientPlayerTakeItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerTakeItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerTakeItem";
        };

        return ClientPlayerTakeItem;
    })();

    NT.ServerPlayerTakeItem = (function() {

        /**
         * Properties of a ServerPlayerTakeItem.
         * @memberof NT
         * @interface IServerPlayerTakeItem
         * @property {string|null} [userId] ServerPlayerTakeItem userId
         * @property {string|null} [id] ServerPlayerTakeItem id
         */

        /**
         * Constructs a new ServerPlayerTakeItem.
         * @memberof NT
         * @classdesc Represents a ServerPlayerTakeItem.
         * @implements IServerPlayerTakeItem
         * @constructor
         * @param {NT.IServerPlayerTakeItem=} [properties] Properties to set
         */
        function ServerPlayerTakeItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerTakeItem userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerTakeItem
         * @instance
         */
        ServerPlayerTakeItem.prototype.userId = "";

        /**
         * ServerPlayerTakeItem id.
         * @member {string} id
         * @memberof NT.ServerPlayerTakeItem
         * @instance
         */
        ServerPlayerTakeItem.prototype.id = "";

        /**
         * Creates a new ServerPlayerTakeItem instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {NT.IServerPlayerTakeItem=} [properties] Properties to set
         * @returns {NT.ServerPlayerTakeItem} ServerPlayerTakeItem instance
         */
        ServerPlayerTakeItem.create = function create(properties) {
            return new ServerPlayerTakeItem(properties);
        };

        /**
         * Encodes the specified ServerPlayerTakeItem message. Does not implicitly {@link NT.ServerPlayerTakeItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {NT.IServerPlayerTakeItem} message ServerPlayerTakeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerTakeItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerTakeItem message, length delimited. Does not implicitly {@link NT.ServerPlayerTakeItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {NT.IServerPlayerTakeItem} message ServerPlayerTakeItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerTakeItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerTakeItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerTakeItem} ServerPlayerTakeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerTakeItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerTakeItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerTakeItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerTakeItem} ServerPlayerTakeItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerTakeItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerTakeItem message.
         * @function verify
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerTakeItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ServerPlayerTakeItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerTakeItem} ServerPlayerTakeItem
         */
        ServerPlayerTakeItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerTakeItem)
                return object;
            let message = new $root.NT.ServerPlayerTakeItem();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerTakeItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {NT.ServerPlayerTakeItem} message ServerPlayerTakeItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerTakeItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.id = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ServerPlayerTakeItem to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerTakeItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerTakeItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerTakeItem
         * @function getTypeUrl
         * @memberof NT.ServerPlayerTakeItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerTakeItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerTakeItem";
        };

        return ServerPlayerTakeItem;
    })();

    NT.ClientChat = (function() {

        /**
         * Properties of a ClientChat.
         * @memberof NT
         * @interface IClientChat
         * @property {string|null} [message] ClientChat message
         */

        /**
         * Constructs a new ClientChat.
         * @memberof NT
         * @classdesc Represents a ClientChat.
         * @implements IClientChat
         * @constructor
         * @param {NT.IClientChat=} [properties] Properties to set
         */
        function ClientChat(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientChat message.
         * @member {string} message
         * @memberof NT.ClientChat
         * @instance
         */
        ClientChat.prototype.message = "";

        /**
         * Creates a new ClientChat instance using the specified properties.
         * @function create
         * @memberof NT.ClientChat
         * @static
         * @param {NT.IClientChat=} [properties] Properties to set
         * @returns {NT.ClientChat} ClientChat instance
         */
        ClientChat.create = function create(properties) {
            return new ClientChat(properties);
        };

        /**
         * Encodes the specified ClientChat message. Does not implicitly {@link NT.ClientChat.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientChat
         * @static
         * @param {NT.IClientChat} message ClientChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified ClientChat message, length delimited. Does not implicitly {@link NT.ClientChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientChat
         * @static
         * @param {NT.IClientChat} message ClientChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientChat message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientChat} ClientChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientChat();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientChat} ClientChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientChat message.
         * @function verify
         * @memberof NT.ClientChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a ClientChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientChat} ClientChat
         */
        ClientChat.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientChat)
                return object;
            let message = new $root.NT.ClientChat();
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a ClientChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientChat
         * @static
         * @param {NT.ClientChat} message ClientChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.message = "";
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this ClientChat to JSON.
         * @function toJSON
         * @memberof NT.ClientChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientChat
         * @function getTypeUrl
         * @memberof NT.ClientChat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientChat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientChat";
        };

        return ClientChat;
    })();

    NT.ServerChat = (function() {

        /**
         * Properties of a ServerChat.
         * @memberof NT
         * @interface IServerChat
         * @property {string|null} [id] ServerChat id
         * @property {string|null} [userId] ServerChat userId
         * @property {string|null} [name] ServerChat name
         * @property {string|null} [message] ServerChat message
         */

        /**
         * Constructs a new ServerChat.
         * @memberof NT
         * @classdesc Represents a ServerChat.
         * @implements IServerChat
         * @constructor
         * @param {NT.IServerChat=} [properties] Properties to set
         */
        function ServerChat(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerChat id.
         * @member {string} id
         * @memberof NT.ServerChat
         * @instance
         */
        ServerChat.prototype.id = "";

        /**
         * ServerChat userId.
         * @member {string} userId
         * @memberof NT.ServerChat
         * @instance
         */
        ServerChat.prototype.userId = "";

        /**
         * ServerChat name.
         * @member {string} name
         * @memberof NT.ServerChat
         * @instance
         */
        ServerChat.prototype.name = "";

        /**
         * ServerChat message.
         * @member {string} message
         * @memberof NT.ServerChat
         * @instance
         */
        ServerChat.prototype.message = "";

        /**
         * Creates a new ServerChat instance using the specified properties.
         * @function create
         * @memberof NT.ServerChat
         * @static
         * @param {NT.IServerChat=} [properties] Properties to set
         * @returns {NT.ServerChat} ServerChat instance
         */
        ServerChat.create = function create(properties) {
            return new ServerChat(properties);
        };

        /**
         * Encodes the specified ServerChat message. Does not implicitly {@link NT.ServerChat.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerChat
         * @static
         * @param {NT.IServerChat} message ServerChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.userId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.message);
            return writer;
        };

        /**
         * Encodes the specified ServerChat message, length delimited. Does not implicitly {@link NT.ServerChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerChat
         * @static
         * @param {NT.IServerChat} message ServerChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerChat message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerChat} ServerChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerChat();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.userId = reader.string();
                        break;
                    }
                case 3: {
                        message.name = reader.string();
                        break;
                    }
                case 4: {
                        message.message = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerChat} ServerChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerChat message.
         * @function verify
         * @memberof NT.ServerChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.message != null && message.hasOwnProperty("message"))
                if (!$util.isString(message.message))
                    return "message: string expected";
            return null;
        };

        /**
         * Creates a ServerChat message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerChat
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerChat} ServerChat
         */
        ServerChat.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerChat)
                return object;
            let message = new $root.NT.ServerChat();
            if (object.id != null)
                message.id = String(object.id);
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.name != null)
                message.name = String(object.name);
            if (object.message != null)
                message.message = String(object.message);
            return message;
        };

        /**
         * Creates a plain object from a ServerChat message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerChat
         * @static
         * @param {NT.ServerChat} message ServerChat
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerChat.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.userId = "";
                object.name = "";
                object.message = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = message.message;
            return object;
        };

        /**
         * Converts this ServerChat to JSON.
         * @function toJSON
         * @memberof NT.ServerChat
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerChat.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerChat
         * @function getTypeUrl
         * @memberof NT.ServerChat
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerChat.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerChat";
        };

        return ServerChat;
    })();

    NT.ServerStatsUpdate = (function() {

        /**
         * Properties of a ServerStatsUpdate.
         * @memberof NT
         * @interface IServerStatsUpdate
         * @property {string|null} [data] ServerStatsUpdate data
         */

        /**
         * Constructs a new ServerStatsUpdate.
         * @memberof NT
         * @classdesc Represents a ServerStatsUpdate.
         * @implements IServerStatsUpdate
         * @constructor
         * @param {NT.IServerStatsUpdate=} [properties] Properties to set
         */
        function ServerStatsUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerStatsUpdate data.
         * @member {string} data
         * @memberof NT.ServerStatsUpdate
         * @instance
         */
        ServerStatsUpdate.prototype.data = "";

        /**
         * Creates a new ServerStatsUpdate instance using the specified properties.
         * @function create
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {NT.IServerStatsUpdate=} [properties] Properties to set
         * @returns {NT.ServerStatsUpdate} ServerStatsUpdate instance
         */
        ServerStatsUpdate.create = function create(properties) {
            return new ServerStatsUpdate(properties);
        };

        /**
         * Encodes the specified ServerStatsUpdate message. Does not implicitly {@link NT.ServerStatsUpdate.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {NT.IServerStatsUpdate} message ServerStatsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.data);
            return writer;
        };

        /**
         * Encodes the specified ServerStatsUpdate message, length delimited. Does not implicitly {@link NT.ServerStatsUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {NT.IServerStatsUpdate} message ServerStatsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerStatsUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerStatsUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerStatsUpdate} ServerStatsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerStatsUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.data = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerStatsUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerStatsUpdate} ServerStatsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerStatsUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerStatsUpdate message.
         * @function verify
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerStatsUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.data != null && message.hasOwnProperty("data"))
                if (!$util.isString(message.data))
                    return "data: string expected";
            return null;
        };

        /**
         * Creates a ServerStatsUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerStatsUpdate} ServerStatsUpdate
         */
        ServerStatsUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerStatsUpdate)
                return object;
            let message = new $root.NT.ServerStatsUpdate();
            if (object.data != null)
                message.data = String(object.data);
            return message;
        };

        /**
         * Creates a plain object from a ServerStatsUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {NT.ServerStatsUpdate} message ServerStatsUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerStatsUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.data = "";
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = message.data;
            return object;
        };

        /**
         * Converts this ServerStatsUpdate to JSON.
         * @function toJSON
         * @memberof NT.ServerStatsUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerStatsUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerStatsUpdate
         * @function getTypeUrl
         * @memberof NT.ServerStatsUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerStatsUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerStatsUpdate";
        };

        return ServerStatsUpdate;
    })();

    NT.ClientPlayerPickup = (function() {

        /**
         * Properties of a ClientPlayerPickup.
         * @memberof NT
         * @interface IClientPlayerPickup
         * @property {NT.ClientPlayerPickup.IHeartPickup|null} [heart] ClientPlayerPickup heart
         * @property {NT.ClientPlayerPickup.IOrbPickup|null} [orb] ClientPlayerPickup orb
         */

        /**
         * Constructs a new ClientPlayerPickup.
         * @memberof NT
         * @classdesc Represents a ClientPlayerPickup.
         * @implements IClientPlayerPickup
         * @constructor
         * @param {NT.IClientPlayerPickup=} [properties] Properties to set
         */
        function ClientPlayerPickup(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerPickup heart.
         * @member {NT.ClientPlayerPickup.IHeartPickup|null|undefined} heart
         * @memberof NT.ClientPlayerPickup
         * @instance
         */
        ClientPlayerPickup.prototype.heart = null;

        /**
         * ClientPlayerPickup orb.
         * @member {NT.ClientPlayerPickup.IOrbPickup|null|undefined} orb
         * @memberof NT.ClientPlayerPickup
         * @instance
         */
        ClientPlayerPickup.prototype.orb = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientPlayerPickup kind.
         * @member {"heart"|"orb"|undefined} kind
         * @memberof NT.ClientPlayerPickup
         * @instance
         */
        Object.defineProperty(ClientPlayerPickup.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["heart", "orb"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientPlayerPickup instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {NT.IClientPlayerPickup=} [properties] Properties to set
         * @returns {NT.ClientPlayerPickup} ClientPlayerPickup instance
         */
        ClientPlayerPickup.create = function create(properties) {
            return new ClientPlayerPickup(properties);
        };

        /**
         * Encodes the specified ClientPlayerPickup message. Does not implicitly {@link NT.ClientPlayerPickup.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {NT.IClientPlayerPickup} message ClientPlayerPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerPickup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heart != null && Object.hasOwnProperty.call(message, "heart"))
                $root.NT.ClientPlayerPickup.HeartPickup.encode(message.heart, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.orb != null && Object.hasOwnProperty.call(message, "orb"))
                $root.NT.ClientPlayerPickup.OrbPickup.encode(message.orb, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerPickup message, length delimited. Does not implicitly {@link NT.ClientPlayerPickup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {NT.IClientPlayerPickup} message ClientPlayerPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerPickup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerPickup message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerPickup} ClientPlayerPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerPickup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerPickup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.heart = $root.NT.ClientPlayerPickup.HeartPickup.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.orb = $root.NT.ClientPlayerPickup.OrbPickup.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerPickup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerPickup} ClientPlayerPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerPickup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerPickup message.
         * @function verify
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerPickup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.heart != null && message.hasOwnProperty("heart")) {
                properties.kind = 1;
                {
                    let error = $root.NT.ClientPlayerPickup.HeartPickup.verify(message.heart);
                    if (error)
                        return "heart." + error;
                }
            }
            if (message.orb != null && message.hasOwnProperty("orb")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.NT.ClientPlayerPickup.OrbPickup.verify(message.orb);
                    if (error)
                        return "orb." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientPlayerPickup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerPickup} ClientPlayerPickup
         */
        ClientPlayerPickup.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerPickup)
                return object;
            let message = new $root.NT.ClientPlayerPickup();
            if (object.heart != null) {
                if (typeof object.heart !== "object")
                    throw TypeError(".NT.ClientPlayerPickup.heart: object expected");
                message.heart = $root.NT.ClientPlayerPickup.HeartPickup.fromObject(object.heart);
            }
            if (object.orb != null) {
                if (typeof object.orb !== "object")
                    throw TypeError(".NT.ClientPlayerPickup.orb: object expected");
                message.orb = $root.NT.ClientPlayerPickup.OrbPickup.fromObject(object.orb);
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerPickup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {NT.ClientPlayerPickup} message ClientPlayerPickup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerPickup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.heart != null && message.hasOwnProperty("heart")) {
                object.heart = $root.NT.ClientPlayerPickup.HeartPickup.toObject(message.heart, options);
                if (options.oneofs)
                    object.kind = "heart";
            }
            if (message.orb != null && message.hasOwnProperty("orb")) {
                object.orb = $root.NT.ClientPlayerPickup.OrbPickup.toObject(message.orb, options);
                if (options.oneofs)
                    object.kind = "orb";
            }
            return object;
        };

        /**
         * Converts this ClientPlayerPickup to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerPickup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerPickup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerPickup
         * @function getTypeUrl
         * @memberof NT.ClientPlayerPickup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerPickup";
        };

        ClientPlayerPickup.HeartPickup = (function() {

            /**
             * Properties of a HeartPickup.
             * @memberof NT.ClientPlayerPickup
             * @interface IHeartPickup
             * @property {boolean|null} [hpPerk] HeartPickup hpPerk
             */

            /**
             * Constructs a new HeartPickup.
             * @memberof NT.ClientPlayerPickup
             * @classdesc Represents a HeartPickup.
             * @implements IHeartPickup
             * @constructor
             * @param {NT.ClientPlayerPickup.IHeartPickup=} [properties] Properties to set
             */
            function HeartPickup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeartPickup hpPerk.
             * @member {boolean} hpPerk
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @instance
             */
            HeartPickup.prototype.hpPerk = false;

            /**
             * Creates a new HeartPickup instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {NT.ClientPlayerPickup.IHeartPickup=} [properties] Properties to set
             * @returns {NT.ClientPlayerPickup.HeartPickup} HeartPickup instance
             */
            HeartPickup.create = function create(properties) {
                return new HeartPickup(properties);
            };

            /**
             * Encodes the specified HeartPickup message. Does not implicitly {@link NT.ClientPlayerPickup.HeartPickup.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {NT.ClientPlayerPickup.IHeartPickup} message HeartPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartPickup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hpPerk != null && Object.hasOwnProperty.call(message, "hpPerk"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hpPerk);
                return writer;
            };

            /**
             * Encodes the specified HeartPickup message, length delimited. Does not implicitly {@link NT.ClientPlayerPickup.HeartPickup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {NT.ClientPlayerPickup.IHeartPickup} message HeartPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartPickup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeartPickup message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerPickup.HeartPickup} HeartPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartPickup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerPickup.HeartPickup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.hpPerk = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeartPickup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerPickup.HeartPickup} HeartPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartPickup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeartPickup message.
             * @function verify
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HeartPickup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hpPerk != null && message.hasOwnProperty("hpPerk"))
                    if (typeof message.hpPerk !== "boolean")
                        return "hpPerk: boolean expected";
                return null;
            };

            /**
             * Creates a HeartPickup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerPickup.HeartPickup} HeartPickup
             */
            HeartPickup.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerPickup.HeartPickup)
                    return object;
                let message = new $root.NT.ClientPlayerPickup.HeartPickup();
                if (object.hpPerk != null)
                    message.hpPerk = Boolean(object.hpPerk);
                return message;
            };

            /**
             * Creates a plain object from a HeartPickup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {NT.ClientPlayerPickup.HeartPickup} message HeartPickup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeartPickup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hpPerk = false;
                if (message.hpPerk != null && message.hasOwnProperty("hpPerk"))
                    object.hpPerk = message.hpPerk;
                return object;
            };

            /**
             * Converts this HeartPickup to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HeartPickup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HeartPickup
             * @function getTypeUrl
             * @memberof NT.ClientPlayerPickup.HeartPickup
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HeartPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerPickup.HeartPickup";
            };

            return HeartPickup;
        })();

        ClientPlayerPickup.OrbPickup = (function() {

            /**
             * Properties of an OrbPickup.
             * @memberof NT.ClientPlayerPickup
             * @interface IOrbPickup
             * @property {number|null} [id] OrbPickup id
             */

            /**
             * Constructs a new OrbPickup.
             * @memberof NT.ClientPlayerPickup
             * @classdesc Represents an OrbPickup.
             * @implements IOrbPickup
             * @constructor
             * @param {NT.ClientPlayerPickup.IOrbPickup=} [properties] Properties to set
             */
            function OrbPickup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OrbPickup id.
             * @member {number} id
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @instance
             */
            OrbPickup.prototype.id = 0;

            /**
             * Creates a new OrbPickup instance using the specified properties.
             * @function create
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {NT.ClientPlayerPickup.IOrbPickup=} [properties] Properties to set
             * @returns {NT.ClientPlayerPickup.OrbPickup} OrbPickup instance
             */
            OrbPickup.create = function create(properties) {
                return new OrbPickup(properties);
            };

            /**
             * Encodes the specified OrbPickup message. Does not implicitly {@link NT.ClientPlayerPickup.OrbPickup.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {NT.ClientPlayerPickup.IOrbPickup} message OrbPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrbPickup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified OrbPickup message, length delimited. Does not implicitly {@link NT.ClientPlayerPickup.OrbPickup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {NT.ClientPlayerPickup.IOrbPickup} message OrbPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrbPickup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OrbPickup message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientPlayerPickup.OrbPickup} OrbPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrbPickup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerPickup.OrbPickup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OrbPickup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientPlayerPickup.OrbPickup} OrbPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrbPickup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OrbPickup message.
             * @function verify
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrbPickup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates an OrbPickup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientPlayerPickup.OrbPickup} OrbPickup
             */
            OrbPickup.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientPlayerPickup.OrbPickup)
                    return object;
                let message = new $root.NT.ClientPlayerPickup.OrbPickup();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an OrbPickup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {NT.ClientPlayerPickup.OrbPickup} message OrbPickup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrbPickup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this OrbPickup to JSON.
             * @function toJSON
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrbPickup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OrbPickup
             * @function getTypeUrl
             * @memberof NT.ClientPlayerPickup.OrbPickup
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OrbPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientPlayerPickup.OrbPickup";
            };

            return OrbPickup;
        })();

        return ClientPlayerPickup;
    })();

    NT.ServerPlayerPickup = (function() {

        /**
         * Properties of a ServerPlayerPickup.
         * @memberof NT
         * @interface IServerPlayerPickup
         * @property {string|null} [userId] ServerPlayerPickup userId
         * @property {NT.ServerPlayerPickup.IHeartPickup|null} [heart] ServerPlayerPickup heart
         * @property {NT.ServerPlayerPickup.IOrbPickup|null} [orb] ServerPlayerPickup orb
         */

        /**
         * Constructs a new ServerPlayerPickup.
         * @memberof NT
         * @classdesc Represents a ServerPlayerPickup.
         * @implements IServerPlayerPickup
         * @constructor
         * @param {NT.IServerPlayerPickup=} [properties] Properties to set
         */
        function ServerPlayerPickup(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerPickup userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerPickup
         * @instance
         */
        ServerPlayerPickup.prototype.userId = "";

        /**
         * ServerPlayerPickup heart.
         * @member {NT.ServerPlayerPickup.IHeartPickup|null|undefined} heart
         * @memberof NT.ServerPlayerPickup
         * @instance
         */
        ServerPlayerPickup.prototype.heart = null;

        /**
         * ServerPlayerPickup orb.
         * @member {NT.ServerPlayerPickup.IOrbPickup|null|undefined} orb
         * @memberof NT.ServerPlayerPickup
         * @instance
         */
        ServerPlayerPickup.prototype.orb = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerPlayerPickup kind.
         * @member {"heart"|"orb"|undefined} kind
         * @memberof NT.ServerPlayerPickup
         * @instance
         */
        Object.defineProperty(ServerPlayerPickup.prototype, "kind", {
            get: $util.oneOfGetter($oneOfFields = ["heart", "orb"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerPlayerPickup instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {NT.IServerPlayerPickup=} [properties] Properties to set
         * @returns {NT.ServerPlayerPickup} ServerPlayerPickup instance
         */
        ServerPlayerPickup.create = function create(properties) {
            return new ServerPlayerPickup(properties);
        };

        /**
         * Encodes the specified ServerPlayerPickup message. Does not implicitly {@link NT.ServerPlayerPickup.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {NT.IServerPlayerPickup} message ServerPlayerPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerPickup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.heart != null && Object.hasOwnProperty.call(message, "heart"))
                $root.NT.ServerPlayerPickup.HeartPickup.encode(message.heart, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.orb != null && Object.hasOwnProperty.call(message, "orb"))
                $root.NT.ServerPlayerPickup.OrbPickup.encode(message.orb, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerPickup message, length delimited. Does not implicitly {@link NT.ServerPlayerPickup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {NT.IServerPlayerPickup} message ServerPlayerPickup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerPickup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerPickup message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerPickup} ServerPlayerPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerPickup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerPickup();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.heart = $root.NT.ServerPlayerPickup.HeartPickup.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.orb = $root.NT.ServerPlayerPickup.OrbPickup.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerPickup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerPickup} ServerPlayerPickup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerPickup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerPickup message.
         * @function verify
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerPickup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.heart != null && message.hasOwnProperty("heart")) {
                properties.kind = 1;
                {
                    let error = $root.NT.ServerPlayerPickup.HeartPickup.verify(message.heart);
                    if (error)
                        return "heart." + error;
                }
            }
            if (message.orb != null && message.hasOwnProperty("orb")) {
                if (properties.kind === 1)
                    return "kind: multiple values";
                properties.kind = 1;
                {
                    let error = $root.NT.ServerPlayerPickup.OrbPickup.verify(message.orb);
                    if (error)
                        return "orb." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerPlayerPickup message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerPickup} ServerPlayerPickup
         */
        ServerPlayerPickup.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerPickup)
                return object;
            let message = new $root.NT.ServerPlayerPickup();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.heart != null) {
                if (typeof object.heart !== "object")
                    throw TypeError(".NT.ServerPlayerPickup.heart: object expected");
                message.heart = $root.NT.ServerPlayerPickup.HeartPickup.fromObject(object.heart);
            }
            if (object.orb != null) {
                if (typeof object.orb !== "object")
                    throw TypeError(".NT.ServerPlayerPickup.orb: object expected");
                message.orb = $root.NT.ServerPlayerPickup.OrbPickup.fromObject(object.orb);
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerPickup message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {NT.ServerPlayerPickup} message ServerPlayerPickup
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerPickup.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.heart != null && message.hasOwnProperty("heart")) {
                object.heart = $root.NT.ServerPlayerPickup.HeartPickup.toObject(message.heart, options);
                if (options.oneofs)
                    object.kind = "heart";
            }
            if (message.orb != null && message.hasOwnProperty("orb")) {
                object.orb = $root.NT.ServerPlayerPickup.OrbPickup.toObject(message.orb, options);
                if (options.oneofs)
                    object.kind = "orb";
            }
            return object;
        };

        /**
         * Converts this ServerPlayerPickup to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerPickup
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerPickup.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerPickup
         * @function getTypeUrl
         * @memberof NT.ServerPlayerPickup
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerPickup";
        };

        ServerPlayerPickup.HeartPickup = (function() {

            /**
             * Properties of a HeartPickup.
             * @memberof NT.ServerPlayerPickup
             * @interface IHeartPickup
             * @property {boolean|null} [hpPerk] HeartPickup hpPerk
             */

            /**
             * Constructs a new HeartPickup.
             * @memberof NT.ServerPlayerPickup
             * @classdesc Represents a HeartPickup.
             * @implements IHeartPickup
             * @constructor
             * @param {NT.ServerPlayerPickup.IHeartPickup=} [properties] Properties to set
             */
            function HeartPickup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HeartPickup hpPerk.
             * @member {boolean} hpPerk
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @instance
             */
            HeartPickup.prototype.hpPerk = false;

            /**
             * Creates a new HeartPickup instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {NT.ServerPlayerPickup.IHeartPickup=} [properties] Properties to set
             * @returns {NT.ServerPlayerPickup.HeartPickup} HeartPickup instance
             */
            HeartPickup.create = function create(properties) {
                return new HeartPickup(properties);
            };

            /**
             * Encodes the specified HeartPickup message. Does not implicitly {@link NT.ServerPlayerPickup.HeartPickup.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {NT.ServerPlayerPickup.IHeartPickup} message HeartPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartPickup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.hpPerk != null && Object.hasOwnProperty.call(message, "hpPerk"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.hpPerk);
                return writer;
            };

            /**
             * Encodes the specified HeartPickup message, length delimited. Does not implicitly {@link NT.ServerPlayerPickup.HeartPickup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {NT.ServerPlayerPickup.IHeartPickup} message HeartPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            HeartPickup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a HeartPickup message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerPickup.HeartPickup} HeartPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartPickup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerPickup.HeartPickup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.hpPerk = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a HeartPickup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerPickup.HeartPickup} HeartPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            HeartPickup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a HeartPickup message.
             * @function verify
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HeartPickup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.hpPerk != null && message.hasOwnProperty("hpPerk"))
                    if (typeof message.hpPerk !== "boolean")
                        return "hpPerk: boolean expected";
                return null;
            };

            /**
             * Creates a HeartPickup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerPickup.HeartPickup} HeartPickup
             */
            HeartPickup.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerPickup.HeartPickup)
                    return object;
                let message = new $root.NT.ServerPlayerPickup.HeartPickup();
                if (object.hpPerk != null)
                    message.hpPerk = Boolean(object.hpPerk);
                return message;
            };

            /**
             * Creates a plain object from a HeartPickup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {NT.ServerPlayerPickup.HeartPickup} message HeartPickup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HeartPickup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.hpPerk = false;
                if (message.hpPerk != null && message.hasOwnProperty("hpPerk"))
                    object.hpPerk = message.hpPerk;
                return object;
            };

            /**
             * Converts this HeartPickup to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HeartPickup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for HeartPickup
             * @function getTypeUrl
             * @memberof NT.ServerPlayerPickup.HeartPickup
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            HeartPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerPickup.HeartPickup";
            };

            return HeartPickup;
        })();

        ServerPlayerPickup.OrbPickup = (function() {

            /**
             * Properties of an OrbPickup.
             * @memberof NT.ServerPlayerPickup
             * @interface IOrbPickup
             * @property {number|null} [id] OrbPickup id
             */

            /**
             * Constructs a new OrbPickup.
             * @memberof NT.ServerPlayerPickup
             * @classdesc Represents an OrbPickup.
             * @implements IOrbPickup
             * @constructor
             * @param {NT.ServerPlayerPickup.IOrbPickup=} [properties] Properties to set
             */
            function OrbPickup(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OrbPickup id.
             * @member {number} id
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @instance
             */
            OrbPickup.prototype.id = 0;

            /**
             * Creates a new OrbPickup instance using the specified properties.
             * @function create
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {NT.ServerPlayerPickup.IOrbPickup=} [properties] Properties to set
             * @returns {NT.ServerPlayerPickup.OrbPickup} OrbPickup instance
             */
            OrbPickup.create = function create(properties) {
                return new OrbPickup(properties);
            };

            /**
             * Encodes the specified OrbPickup message. Does not implicitly {@link NT.ServerPlayerPickup.OrbPickup.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {NT.ServerPlayerPickup.IOrbPickup} message OrbPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrbPickup.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                return writer;
            };

            /**
             * Encodes the specified OrbPickup message, length delimited. Does not implicitly {@link NT.ServerPlayerPickup.OrbPickup.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {NT.ServerPlayerPickup.IOrbPickup} message OrbPickup message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OrbPickup.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OrbPickup message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerPlayerPickup.OrbPickup} OrbPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrbPickup.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerPickup.OrbPickup();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OrbPickup message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerPlayerPickup.OrbPickup} OrbPickup
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OrbPickup.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OrbPickup message.
             * @function verify
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OrbPickup.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                return null;
            };

            /**
             * Creates an OrbPickup message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerPlayerPickup.OrbPickup} OrbPickup
             */
            OrbPickup.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerPlayerPickup.OrbPickup)
                    return object;
                let message = new $root.NT.ServerPlayerPickup.OrbPickup();
                if (object.id != null)
                    message.id = object.id >>> 0;
                return message;
            };

            /**
             * Creates a plain object from an OrbPickup message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {NT.ServerPlayerPickup.OrbPickup} message OrbPickup
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OrbPickup.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.id = 0;
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                return object;
            };

            /**
             * Converts this OrbPickup to JSON.
             * @function toJSON
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OrbPickup.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for OrbPickup
             * @function getTypeUrl
             * @memberof NT.ServerPlayerPickup.OrbPickup
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            OrbPickup.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerPlayerPickup.OrbPickup";
            };

            return OrbPickup;
        })();

        return ServerPlayerPickup;
    })();

    NT.ClientNemesisPickupItem = (function() {

        /**
         * Properties of a ClientNemesisPickupItem.
         * @memberof NT
         * @interface IClientNemesisPickupItem
         * @property {string|null} [gameId] ClientNemesisPickupItem gameId
         */

        /**
         * Constructs a new ClientNemesisPickupItem.
         * @memberof NT
         * @classdesc Represents a ClientNemesisPickupItem.
         * @implements IClientNemesisPickupItem
         * @constructor
         * @param {NT.IClientNemesisPickupItem=} [properties] Properties to set
         */
        function ClientNemesisPickupItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientNemesisPickupItem gameId.
         * @member {string} gameId
         * @memberof NT.ClientNemesisPickupItem
         * @instance
         */
        ClientNemesisPickupItem.prototype.gameId = "";

        /**
         * Creates a new ClientNemesisPickupItem instance using the specified properties.
         * @function create
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {NT.IClientNemesisPickupItem=} [properties] Properties to set
         * @returns {NT.ClientNemesisPickupItem} ClientNemesisPickupItem instance
         */
        ClientNemesisPickupItem.create = function create(properties) {
            return new ClientNemesisPickupItem(properties);
        };

        /**
         * Encodes the specified ClientNemesisPickupItem message. Does not implicitly {@link NT.ClientNemesisPickupItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {NT.IClientNemesisPickupItem} message ClientNemesisPickupItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNemesisPickupItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified ClientNemesisPickupItem message, length delimited. Does not implicitly {@link NT.ClientNemesisPickupItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {NT.IClientNemesisPickupItem} message ClientNemesisPickupItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNemesisPickupItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientNemesisPickupItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientNemesisPickupItem} ClientNemesisPickupItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNemesisPickupItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientNemesisPickupItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gameId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientNemesisPickupItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientNemesisPickupItem} ClientNemesisPickupItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNemesisPickupItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientNemesisPickupItem message.
         * @function verify
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientNemesisPickupItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isString(message.gameId))
                    return "gameId: string expected";
            return null;
        };

        /**
         * Creates a ClientNemesisPickupItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientNemesisPickupItem} ClientNemesisPickupItem
         */
        ClientNemesisPickupItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientNemesisPickupItem)
                return object;
            let message = new $root.NT.ClientNemesisPickupItem();
            if (object.gameId != null)
                message.gameId = String(object.gameId);
            return message;
        };

        /**
         * Creates a plain object from a ClientNemesisPickupItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {NT.ClientNemesisPickupItem} message ClientNemesisPickupItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientNemesisPickupItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameId = "";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this ClientNemesisPickupItem to JSON.
         * @function toJSON
         * @memberof NT.ClientNemesisPickupItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientNemesisPickupItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientNemesisPickupItem
         * @function getTypeUrl
         * @memberof NT.ClientNemesisPickupItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientNemesisPickupItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientNemesisPickupItem";
        };

        return ClientNemesisPickupItem;
    })();

    NT.ServerNemesisPickupItem = (function() {

        /**
         * Properties of a ServerNemesisPickupItem.
         * @memberof NT
         * @interface IServerNemesisPickupItem
         * @property {string|null} [userId] ServerNemesisPickupItem userId
         * @property {string|null} [gameId] ServerNemesisPickupItem gameId
         */

        /**
         * Constructs a new ServerNemesisPickupItem.
         * @memberof NT
         * @classdesc Represents a ServerNemesisPickupItem.
         * @implements IServerNemesisPickupItem
         * @constructor
         * @param {NT.IServerNemesisPickupItem=} [properties] Properties to set
         */
        function ServerNemesisPickupItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerNemesisPickupItem userId.
         * @member {string} userId
         * @memberof NT.ServerNemesisPickupItem
         * @instance
         */
        ServerNemesisPickupItem.prototype.userId = "";

        /**
         * ServerNemesisPickupItem gameId.
         * @member {string} gameId
         * @memberof NT.ServerNemesisPickupItem
         * @instance
         */
        ServerNemesisPickupItem.prototype.gameId = "";

        /**
         * Creates a new ServerNemesisPickupItem instance using the specified properties.
         * @function create
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {NT.IServerNemesisPickupItem=} [properties] Properties to set
         * @returns {NT.ServerNemesisPickupItem} ServerNemesisPickupItem instance
         */
        ServerNemesisPickupItem.create = function create(properties) {
            return new ServerNemesisPickupItem(properties);
        };

        /**
         * Encodes the specified ServerNemesisPickupItem message. Does not implicitly {@link NT.ServerNemesisPickupItem.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {NT.IServerNemesisPickupItem} message ServerNemesisPickupItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerNemesisPickupItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified ServerNemesisPickupItem message, length delimited. Does not implicitly {@link NT.ServerNemesisPickupItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {NT.IServerNemesisPickupItem} message ServerNemesisPickupItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerNemesisPickupItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerNemesisPickupItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerNemesisPickupItem} ServerNemesisPickupItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerNemesisPickupItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerNemesisPickupItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.gameId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerNemesisPickupItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerNemesisPickupItem} ServerNemesisPickupItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerNemesisPickupItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerNemesisPickupItem message.
         * @function verify
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerNemesisPickupItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isString(message.gameId))
                    return "gameId: string expected";
            return null;
        };

        /**
         * Creates a ServerNemesisPickupItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerNemesisPickupItem} ServerNemesisPickupItem
         */
        ServerNemesisPickupItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerNemesisPickupItem)
                return object;
            let message = new $root.NT.ServerNemesisPickupItem();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.gameId != null)
                message.gameId = String(object.gameId);
            return message;
        };

        /**
         * Creates a plain object from a ServerNemesisPickupItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {NT.ServerNemesisPickupItem} message ServerNemesisPickupItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerNemesisPickupItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.gameId = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this ServerNemesisPickupItem to JSON.
         * @function toJSON
         * @memberof NT.ServerNemesisPickupItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerNemesisPickupItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerNemesisPickupItem
         * @function getTypeUrl
         * @memberof NT.ServerNemesisPickupItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerNemesisPickupItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerNemesisPickupItem";
        };

        return ServerNemesisPickupItem;
    })();

    NT.ClientNemesisAbility = (function() {

        /**
         * Properties of a ClientNemesisAbility.
         * @memberof NT
         * @interface IClientNemesisAbility
         * @property {string|null} [gameId] ClientNemesisAbility gameId
         */

        /**
         * Constructs a new ClientNemesisAbility.
         * @memberof NT
         * @classdesc Represents a ClientNemesisAbility.
         * @implements IClientNemesisAbility
         * @constructor
         * @param {NT.IClientNemesisAbility=} [properties] Properties to set
         */
        function ClientNemesisAbility(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientNemesisAbility gameId.
         * @member {string} gameId
         * @memberof NT.ClientNemesisAbility
         * @instance
         */
        ClientNemesisAbility.prototype.gameId = "";

        /**
         * Creates a new ClientNemesisAbility instance using the specified properties.
         * @function create
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {NT.IClientNemesisAbility=} [properties] Properties to set
         * @returns {NT.ClientNemesisAbility} ClientNemesisAbility instance
         */
        ClientNemesisAbility.create = function create(properties) {
            return new ClientNemesisAbility(properties);
        };

        /**
         * Encodes the specified ClientNemesisAbility message. Does not implicitly {@link NT.ClientNemesisAbility.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {NT.IClientNemesisAbility} message ClientNemesisAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNemesisAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified ClientNemesisAbility message, length delimited. Does not implicitly {@link NT.ClientNemesisAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {NT.IClientNemesisAbility} message ClientNemesisAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientNemesisAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientNemesisAbility message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientNemesisAbility} ClientNemesisAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNemesisAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientNemesisAbility();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.gameId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientNemesisAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientNemesisAbility} ClientNemesisAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientNemesisAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientNemesisAbility message.
         * @function verify
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientNemesisAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isString(message.gameId))
                    return "gameId: string expected";
            return null;
        };

        /**
         * Creates a ClientNemesisAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientNemesisAbility} ClientNemesisAbility
         */
        ClientNemesisAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientNemesisAbility)
                return object;
            let message = new $root.NT.ClientNemesisAbility();
            if (object.gameId != null)
                message.gameId = String(object.gameId);
            return message;
        };

        /**
         * Creates a plain object from a ClientNemesisAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {NT.ClientNemesisAbility} message ClientNemesisAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientNemesisAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.gameId = "";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this ClientNemesisAbility to JSON.
         * @function toJSON
         * @memberof NT.ClientNemesisAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientNemesisAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientNemesisAbility
         * @function getTypeUrl
         * @memberof NT.ClientNemesisAbility
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientNemesisAbility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientNemesisAbility";
        };

        return ClientNemesisAbility;
    })();

    NT.ServerNemesisAbility = (function() {

        /**
         * Properties of a ServerNemesisAbility.
         * @memberof NT
         * @interface IServerNemesisAbility
         * @property {string|null} [userId] ServerNemesisAbility userId
         * @property {string|null} [gameId] ServerNemesisAbility gameId
         */

        /**
         * Constructs a new ServerNemesisAbility.
         * @memberof NT
         * @classdesc Represents a ServerNemesisAbility.
         * @implements IServerNemesisAbility
         * @constructor
         * @param {NT.IServerNemesisAbility=} [properties] Properties to set
         */
        function ServerNemesisAbility(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerNemesisAbility userId.
         * @member {string} userId
         * @memberof NT.ServerNemesisAbility
         * @instance
         */
        ServerNemesisAbility.prototype.userId = "";

        /**
         * ServerNemesisAbility gameId.
         * @member {string} gameId
         * @memberof NT.ServerNemesisAbility
         * @instance
         */
        ServerNemesisAbility.prototype.gameId = "";

        /**
         * Creates a new ServerNemesisAbility instance using the specified properties.
         * @function create
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {NT.IServerNemesisAbility=} [properties] Properties to set
         * @returns {NT.ServerNemesisAbility} ServerNemesisAbility instance
         */
        ServerNemesisAbility.create = function create(properties) {
            return new ServerNemesisAbility(properties);
        };

        /**
         * Encodes the specified ServerNemesisAbility message. Does not implicitly {@link NT.ServerNemesisAbility.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {NT.IServerNemesisAbility} message ServerNemesisAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerNemesisAbility.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameId);
            return writer;
        };

        /**
         * Encodes the specified ServerNemesisAbility message, length delimited. Does not implicitly {@link NT.ServerNemesisAbility.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {NT.IServerNemesisAbility} message ServerNemesisAbility message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerNemesisAbility.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerNemesisAbility message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerNemesisAbility} ServerNemesisAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerNemesisAbility.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerNemesisAbility();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.gameId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerNemesisAbility message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerNemesisAbility} ServerNemesisAbility
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerNemesisAbility.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerNemesisAbility message.
         * @function verify
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerNemesisAbility.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isString(message.gameId))
                    return "gameId: string expected";
            return null;
        };

        /**
         * Creates a ServerNemesisAbility message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerNemesisAbility} ServerNemesisAbility
         */
        ServerNemesisAbility.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerNemesisAbility)
                return object;
            let message = new $root.NT.ServerNemesisAbility();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.gameId != null)
                message.gameId = String(object.gameId);
            return message;
        };

        /**
         * Creates a plain object from a ServerNemesisAbility message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {NT.ServerNemesisAbility} message ServerNemesisAbility
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerNemesisAbility.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.gameId = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            return object;
        };

        /**
         * Converts this ServerNemesisAbility to JSON.
         * @function toJSON
         * @memberof NT.ServerNemesisAbility
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerNemesisAbility.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerNemesisAbility
         * @function getTypeUrl
         * @memberof NT.ServerNemesisAbility
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerNemesisAbility.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerNemesisAbility";
        };

        return ServerNemesisAbility;
    })();

    NT.ClientPlayerDeath = (function() {

        /**
         * Properties of a ClientPlayerDeath.
         * @memberof NT
         * @interface IClientPlayerDeath
         * @property {boolean|null} [isWin] ClientPlayerDeath isWin
         * @property {number|null} [gameTime] ClientPlayerDeath gameTime
         */

        /**
         * Constructs a new ClientPlayerDeath.
         * @memberof NT
         * @classdesc Represents a ClientPlayerDeath.
         * @implements IClientPlayerDeath
         * @constructor
         * @param {NT.IClientPlayerDeath=} [properties] Properties to set
         */
        function ClientPlayerDeath(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerDeath isWin.
         * @member {boolean} isWin
         * @memberof NT.ClientPlayerDeath
         * @instance
         */
        ClientPlayerDeath.prototype.isWin = false;

        /**
         * ClientPlayerDeath gameTime.
         * @member {number|null|undefined} gameTime
         * @memberof NT.ClientPlayerDeath
         * @instance
         */
        ClientPlayerDeath.prototype.gameTime = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientPlayerDeath _gameTime.
         * @member {"gameTime"|undefined} _gameTime
         * @memberof NT.ClientPlayerDeath
         * @instance
         */
        Object.defineProperty(ClientPlayerDeath.prototype, "_gameTime", {
            get: $util.oneOfGetter($oneOfFields = ["gameTime"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientPlayerDeath instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {NT.IClientPlayerDeath=} [properties] Properties to set
         * @returns {NT.ClientPlayerDeath} ClientPlayerDeath instance
         */
        ClientPlayerDeath.create = function create(properties) {
            return new ClientPlayerDeath(properties);
        };

        /**
         * Encodes the specified ClientPlayerDeath message. Does not implicitly {@link NT.ClientPlayerDeath.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {NT.IClientPlayerDeath} message ClientPlayerDeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerDeath.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isWin != null && Object.hasOwnProperty.call(message, "isWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isWin);
            if (message.gameTime != null && Object.hasOwnProperty.call(message, "gameTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gameTime);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerDeath message, length delimited. Does not implicitly {@link NT.ClientPlayerDeath.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {NT.IClientPlayerDeath} message ClientPlayerDeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerDeath.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerDeath message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerDeath} ClientPlayerDeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerDeath.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerDeath();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isWin = reader.bool();
                        break;
                    }
                case 2: {
                        message.gameTime = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerDeath message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerDeath} ClientPlayerDeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerDeath.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerDeath message.
         * @function verify
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerDeath.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.gameTime != null && message.hasOwnProperty("gameTime")) {
                properties._gameTime = 1;
                if (!$util.isInteger(message.gameTime))
                    return "gameTime: integer expected";
            }
            return null;
        };

        /**
         * Creates a ClientPlayerDeath message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerDeath} ClientPlayerDeath
         */
        ClientPlayerDeath.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerDeath)
                return object;
            let message = new $root.NT.ClientPlayerDeath();
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.gameTime != null)
                message.gameTime = object.gameTime >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerDeath message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {NT.ClientPlayerDeath} message ClientPlayerDeath
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerDeath.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.isWin = false;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.gameTime != null && message.hasOwnProperty("gameTime")) {
                object.gameTime = message.gameTime;
                if (options.oneofs)
                    object._gameTime = "gameTime";
            }
            return object;
        };

        /**
         * Converts this ClientPlayerDeath to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerDeath
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerDeath.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerDeath
         * @function getTypeUrl
         * @memberof NT.ClientPlayerDeath
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerDeath.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerDeath";
        };

        return ClientPlayerDeath;
    })();

    NT.ServerPlayerDeath = (function() {

        /**
         * Properties of a ServerPlayerDeath.
         * @memberof NT
         * @interface IServerPlayerDeath
         * @property {string|null} [userId] ServerPlayerDeath userId
         * @property {boolean|null} [isWin] ServerPlayerDeath isWin
         * @property {number|null} [gameTime] ServerPlayerDeath gameTime
         */

        /**
         * Constructs a new ServerPlayerDeath.
         * @memberof NT
         * @classdesc Represents a ServerPlayerDeath.
         * @implements IServerPlayerDeath
         * @constructor
         * @param {NT.IServerPlayerDeath=} [properties] Properties to set
         */
        function ServerPlayerDeath(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerDeath userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerDeath
         * @instance
         */
        ServerPlayerDeath.prototype.userId = "";

        /**
         * ServerPlayerDeath isWin.
         * @member {boolean} isWin
         * @memberof NT.ServerPlayerDeath
         * @instance
         */
        ServerPlayerDeath.prototype.isWin = false;

        /**
         * ServerPlayerDeath gameTime.
         * @member {number|null|undefined} gameTime
         * @memberof NT.ServerPlayerDeath
         * @instance
         */
        ServerPlayerDeath.prototype.gameTime = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerPlayerDeath _gameTime.
         * @member {"gameTime"|undefined} _gameTime
         * @memberof NT.ServerPlayerDeath
         * @instance
         */
        Object.defineProperty(ServerPlayerDeath.prototype, "_gameTime", {
            get: $util.oneOfGetter($oneOfFields = ["gameTime"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerPlayerDeath instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {NT.IServerPlayerDeath=} [properties] Properties to set
         * @returns {NT.ServerPlayerDeath} ServerPlayerDeath instance
         */
        ServerPlayerDeath.create = function create(properties) {
            return new ServerPlayerDeath(properties);
        };

        /**
         * Encodes the specified ServerPlayerDeath message. Does not implicitly {@link NT.ServerPlayerDeath.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {NT.IServerPlayerDeath} message ServerPlayerDeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerDeath.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.isWin != null && Object.hasOwnProperty.call(message, "isWin"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isWin);
            if (message.gameTime != null && Object.hasOwnProperty.call(message, "gameTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gameTime);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerDeath message, length delimited. Does not implicitly {@link NT.ServerPlayerDeath.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {NT.IServerPlayerDeath} message ServerPlayerDeath message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerDeath.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerDeath message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerDeath} ServerPlayerDeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerDeath.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerDeath();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.isWin = reader.bool();
                        break;
                    }
                case 3: {
                        message.gameTime = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerDeath message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerDeath} ServerPlayerDeath
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerDeath.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerDeath message.
         * @function verify
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerDeath.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                if (typeof message.isWin !== "boolean")
                    return "isWin: boolean expected";
            if (message.gameTime != null && message.hasOwnProperty("gameTime")) {
                properties._gameTime = 1;
                if (!$util.isInteger(message.gameTime))
                    return "gameTime: integer expected";
            }
            return null;
        };

        /**
         * Creates a ServerPlayerDeath message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerDeath} ServerPlayerDeath
         */
        ServerPlayerDeath.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerDeath)
                return object;
            let message = new $root.NT.ServerPlayerDeath();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.isWin != null)
                message.isWin = Boolean(object.isWin);
            if (object.gameTime != null)
                message.gameTime = object.gameTime >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerDeath message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {NT.ServerPlayerDeath} message ServerPlayerDeath
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerDeath.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.isWin = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.isWin != null && message.hasOwnProperty("isWin"))
                object.isWin = message.isWin;
            if (message.gameTime != null && message.hasOwnProperty("gameTime")) {
                object.gameTime = message.gameTime;
                if (options.oneofs)
                    object._gameTime = "gameTime";
            }
            return object;
        };

        /**
         * Converts this ServerPlayerDeath to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerDeath
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerDeath.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerDeath
         * @function getTypeUrl
         * @memberof NT.ServerPlayerDeath
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerDeath.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerDeath";
        };

        return ServerPlayerDeath;
    })();

    NT.ClientPlayerNewGamePlus = (function() {

        /**
         * Properties of a ClientPlayerNewGamePlus.
         * @memberof NT
         * @interface IClientPlayerNewGamePlus
         * @property {number|null} [amount] ClientPlayerNewGamePlus amount
         */

        /**
         * Constructs a new ClientPlayerNewGamePlus.
         * @memberof NT
         * @classdesc Represents a ClientPlayerNewGamePlus.
         * @implements IClientPlayerNewGamePlus
         * @constructor
         * @param {NT.IClientPlayerNewGamePlus=} [properties] Properties to set
         */
        function ClientPlayerNewGamePlus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerNewGamePlus amount.
         * @member {number} amount
         * @memberof NT.ClientPlayerNewGamePlus
         * @instance
         */
        ClientPlayerNewGamePlus.prototype.amount = 0;

        /**
         * Creates a new ClientPlayerNewGamePlus instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {NT.IClientPlayerNewGamePlus=} [properties] Properties to set
         * @returns {NT.ClientPlayerNewGamePlus} ClientPlayerNewGamePlus instance
         */
        ClientPlayerNewGamePlus.create = function create(properties) {
            return new ClientPlayerNewGamePlus(properties);
        };

        /**
         * Encodes the specified ClientPlayerNewGamePlus message. Does not implicitly {@link NT.ClientPlayerNewGamePlus.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {NT.IClientPlayerNewGamePlus} message ClientPlayerNewGamePlus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerNewGamePlus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerNewGamePlus message, length delimited. Does not implicitly {@link NT.ClientPlayerNewGamePlus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {NT.IClientPlayerNewGamePlus} message ClientPlayerNewGamePlus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerNewGamePlus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerNewGamePlus message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerNewGamePlus} ClientPlayerNewGamePlus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerNewGamePlus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerNewGamePlus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerNewGamePlus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerNewGamePlus} ClientPlayerNewGamePlus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerNewGamePlus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerNewGamePlus message.
         * @function verify
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerNewGamePlus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ClientPlayerNewGamePlus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerNewGamePlus} ClientPlayerNewGamePlus
         */
        ClientPlayerNewGamePlus.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerNewGamePlus)
                return object;
            let message = new $root.NT.ClientPlayerNewGamePlus();
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerNewGamePlus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {NT.ClientPlayerNewGamePlus} message ClientPlayerNewGamePlus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerNewGamePlus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.amount = 0;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ClientPlayerNewGamePlus to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerNewGamePlus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerNewGamePlus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerNewGamePlus
         * @function getTypeUrl
         * @memberof NT.ClientPlayerNewGamePlus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerNewGamePlus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerNewGamePlus";
        };

        return ClientPlayerNewGamePlus;
    })();

    NT.ServerPlayerNewGamePlus = (function() {

        /**
         * Properties of a ServerPlayerNewGamePlus.
         * @memberof NT
         * @interface IServerPlayerNewGamePlus
         * @property {string|null} [userId] ServerPlayerNewGamePlus userId
         * @property {number|null} [amount] ServerPlayerNewGamePlus amount
         */

        /**
         * Constructs a new ServerPlayerNewGamePlus.
         * @memberof NT
         * @classdesc Represents a ServerPlayerNewGamePlus.
         * @implements IServerPlayerNewGamePlus
         * @constructor
         * @param {NT.IServerPlayerNewGamePlus=} [properties] Properties to set
         */
        function ServerPlayerNewGamePlus(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerNewGamePlus userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerNewGamePlus
         * @instance
         */
        ServerPlayerNewGamePlus.prototype.userId = "";

        /**
         * ServerPlayerNewGamePlus amount.
         * @member {number} amount
         * @memberof NT.ServerPlayerNewGamePlus
         * @instance
         */
        ServerPlayerNewGamePlus.prototype.amount = 0;

        /**
         * Creates a new ServerPlayerNewGamePlus instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {NT.IServerPlayerNewGamePlus=} [properties] Properties to set
         * @returns {NT.ServerPlayerNewGamePlus} ServerPlayerNewGamePlus instance
         */
        ServerPlayerNewGamePlus.create = function create(properties) {
            return new ServerPlayerNewGamePlus(properties);
        };

        /**
         * Encodes the specified ServerPlayerNewGamePlus message. Does not implicitly {@link NT.ServerPlayerNewGamePlus.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {NT.IServerPlayerNewGamePlus} message ServerPlayerNewGamePlus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerNewGamePlus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerNewGamePlus message, length delimited. Does not implicitly {@link NT.ServerPlayerNewGamePlus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {NT.IServerPlayerNewGamePlus} message ServerPlayerNewGamePlus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerNewGamePlus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerNewGamePlus message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerNewGamePlus} ServerPlayerNewGamePlus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerNewGamePlus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerNewGamePlus();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.amount = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerNewGamePlus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerNewGamePlus} ServerPlayerNewGamePlus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerNewGamePlus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerNewGamePlus message.
         * @function verify
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerNewGamePlus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.amount != null && message.hasOwnProperty("amount"))
                if (!$util.isInteger(message.amount))
                    return "amount: integer expected";
            return null;
        };

        /**
         * Creates a ServerPlayerNewGamePlus message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerNewGamePlus} ServerPlayerNewGamePlus
         */
        ServerPlayerNewGamePlus.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerNewGamePlus)
                return object;
            let message = new $root.NT.ServerPlayerNewGamePlus();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.amount != null)
                message.amount = object.amount >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerNewGamePlus message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {NT.ServerPlayerNewGamePlus} message ServerPlayerNewGamePlus
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerNewGamePlus.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.amount = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.amount != null && message.hasOwnProperty("amount"))
                object.amount = message.amount;
            return object;
        };

        /**
         * Converts this ServerPlayerNewGamePlus to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerNewGamePlus
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerNewGamePlus.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerNewGamePlus
         * @function getTypeUrl
         * @memberof NT.ServerPlayerNewGamePlus
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerNewGamePlus.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerNewGamePlus";
        };

        return ServerPlayerNewGamePlus;
    })();

    NT.ClientPlayerSecretHourglass = (function() {

        /**
         * Properties of a ClientPlayerSecretHourglass.
         * @memberof NT
         * @interface IClientPlayerSecretHourglass
         * @property {string|null} [material] ClientPlayerSecretHourglass material
         */

        /**
         * Constructs a new ClientPlayerSecretHourglass.
         * @memberof NT
         * @classdesc Represents a ClientPlayerSecretHourglass.
         * @implements IClientPlayerSecretHourglass
         * @constructor
         * @param {NT.IClientPlayerSecretHourglass=} [properties] Properties to set
         */
        function ClientPlayerSecretHourglass(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientPlayerSecretHourglass material.
         * @member {string} material
         * @memberof NT.ClientPlayerSecretHourglass
         * @instance
         */
        ClientPlayerSecretHourglass.prototype.material = "";

        /**
         * Creates a new ClientPlayerSecretHourglass instance using the specified properties.
         * @function create
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {NT.IClientPlayerSecretHourglass=} [properties] Properties to set
         * @returns {NT.ClientPlayerSecretHourglass} ClientPlayerSecretHourglass instance
         */
        ClientPlayerSecretHourglass.create = function create(properties) {
            return new ClientPlayerSecretHourglass(properties);
        };

        /**
         * Encodes the specified ClientPlayerSecretHourglass message. Does not implicitly {@link NT.ClientPlayerSecretHourglass.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {NT.IClientPlayerSecretHourglass} message ClientPlayerSecretHourglass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerSecretHourglass.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.material);
            return writer;
        };

        /**
         * Encodes the specified ClientPlayerSecretHourglass message, length delimited. Does not implicitly {@link NT.ClientPlayerSecretHourglass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {NT.IClientPlayerSecretHourglass} message ClientPlayerSecretHourglass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientPlayerSecretHourglass.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientPlayerSecretHourglass message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientPlayerSecretHourglass} ClientPlayerSecretHourglass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerSecretHourglass.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientPlayerSecretHourglass();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.material = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientPlayerSecretHourglass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientPlayerSecretHourglass} ClientPlayerSecretHourglass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientPlayerSecretHourglass.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientPlayerSecretHourglass message.
         * @function verify
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientPlayerSecretHourglass.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.material != null && message.hasOwnProperty("material"))
                if (!$util.isString(message.material))
                    return "material: string expected";
            return null;
        };

        /**
         * Creates a ClientPlayerSecretHourglass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientPlayerSecretHourglass} ClientPlayerSecretHourglass
         */
        ClientPlayerSecretHourglass.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientPlayerSecretHourglass)
                return object;
            let message = new $root.NT.ClientPlayerSecretHourglass();
            if (object.material != null)
                message.material = String(object.material);
            return message;
        };

        /**
         * Creates a plain object from a ClientPlayerSecretHourglass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {NT.ClientPlayerSecretHourglass} message ClientPlayerSecretHourglass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientPlayerSecretHourglass.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.material = "";
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = message.material;
            return object;
        };

        /**
         * Converts this ClientPlayerSecretHourglass to JSON.
         * @function toJSON
         * @memberof NT.ClientPlayerSecretHourglass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientPlayerSecretHourglass.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientPlayerSecretHourglass
         * @function getTypeUrl
         * @memberof NT.ClientPlayerSecretHourglass
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientPlayerSecretHourglass.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientPlayerSecretHourglass";
        };

        return ClientPlayerSecretHourglass;
    })();

    NT.ServerPlayerSecretHourglass = (function() {

        /**
         * Properties of a ServerPlayerSecretHourglass.
         * @memberof NT
         * @interface IServerPlayerSecretHourglass
         * @property {string|null} [userId] ServerPlayerSecretHourglass userId
         * @property {string|null} [material] ServerPlayerSecretHourglass material
         */

        /**
         * Constructs a new ServerPlayerSecretHourglass.
         * @memberof NT
         * @classdesc Represents a ServerPlayerSecretHourglass.
         * @implements IServerPlayerSecretHourglass
         * @constructor
         * @param {NT.IServerPlayerSecretHourglass=} [properties] Properties to set
         */
        function ServerPlayerSecretHourglass(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerPlayerSecretHourglass userId.
         * @member {string} userId
         * @memberof NT.ServerPlayerSecretHourglass
         * @instance
         */
        ServerPlayerSecretHourglass.prototype.userId = "";

        /**
         * ServerPlayerSecretHourglass material.
         * @member {string} material
         * @memberof NT.ServerPlayerSecretHourglass
         * @instance
         */
        ServerPlayerSecretHourglass.prototype.material = "";

        /**
         * Creates a new ServerPlayerSecretHourglass instance using the specified properties.
         * @function create
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {NT.IServerPlayerSecretHourglass=} [properties] Properties to set
         * @returns {NT.ServerPlayerSecretHourglass} ServerPlayerSecretHourglass instance
         */
        ServerPlayerSecretHourglass.create = function create(properties) {
            return new ServerPlayerSecretHourglass(properties);
        };

        /**
         * Encodes the specified ServerPlayerSecretHourglass message. Does not implicitly {@link NT.ServerPlayerSecretHourglass.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {NT.IServerPlayerSecretHourglass} message ServerPlayerSecretHourglass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerSecretHourglass.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.material != null && Object.hasOwnProperty.call(message, "material"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.material);
            return writer;
        };

        /**
         * Encodes the specified ServerPlayerSecretHourglass message, length delimited. Does not implicitly {@link NT.ServerPlayerSecretHourglass.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {NT.IServerPlayerSecretHourglass} message ServerPlayerSecretHourglass message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerPlayerSecretHourglass.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerPlayerSecretHourglass message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerPlayerSecretHourglass} ServerPlayerSecretHourglass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerSecretHourglass.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerPlayerSecretHourglass();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.material = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerPlayerSecretHourglass message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerPlayerSecretHourglass} ServerPlayerSecretHourglass
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerPlayerSecretHourglass.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerPlayerSecretHourglass message.
         * @function verify
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerPlayerSecretHourglass.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.material != null && message.hasOwnProperty("material"))
                if (!$util.isString(message.material))
                    return "material: string expected";
            return null;
        };

        /**
         * Creates a ServerPlayerSecretHourglass message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerPlayerSecretHourglass} ServerPlayerSecretHourglass
         */
        ServerPlayerSecretHourglass.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerPlayerSecretHourglass)
                return object;
            let message = new $root.NT.ServerPlayerSecretHourglass();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.material != null)
                message.material = String(object.material);
            return message;
        };

        /**
         * Creates a plain object from a ServerPlayerSecretHourglass message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {NT.ServerPlayerSecretHourglass} message ServerPlayerSecretHourglass
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerPlayerSecretHourglass.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.material = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.material != null && message.hasOwnProperty("material"))
                object.material = message.material;
            return object;
        };

        /**
         * Converts this ServerPlayerSecretHourglass to JSON.
         * @function toJSON
         * @memberof NT.ServerPlayerSecretHourglass
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerPlayerSecretHourglass.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerPlayerSecretHourglass
         * @function getTypeUrl
         * @memberof NT.ServerPlayerSecretHourglass
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerPlayerSecretHourglass.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerPlayerSecretHourglass";
        };

        return ServerPlayerSecretHourglass;
    })();

    NT.ClientCustomModEvent = (function() {

        /**
         * Properties of a ClientCustomModEvent.
         * @memberof NT
         * @interface IClientCustomModEvent
         * @property {string|null} [payload] ClientCustomModEvent payload
         */

        /**
         * Constructs a new ClientCustomModEvent.
         * @memberof NT
         * @classdesc Represents a ClientCustomModEvent.
         * @implements IClientCustomModEvent
         * @constructor
         * @param {NT.IClientCustomModEvent=} [properties] Properties to set
         */
        function ClientCustomModEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientCustomModEvent payload.
         * @member {string} payload
         * @memberof NT.ClientCustomModEvent
         * @instance
         */
        ClientCustomModEvent.prototype.payload = "";

        /**
         * Creates a new ClientCustomModEvent instance using the specified properties.
         * @function create
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {NT.IClientCustomModEvent=} [properties] Properties to set
         * @returns {NT.ClientCustomModEvent} ClientCustomModEvent instance
         */
        ClientCustomModEvent.create = function create(properties) {
            return new ClientCustomModEvent(properties);
        };

        /**
         * Encodes the specified ClientCustomModEvent message. Does not implicitly {@link NT.ClientCustomModEvent.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {NT.IClientCustomModEvent} message ClientCustomModEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientCustomModEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ClientCustomModEvent message, length delimited. Does not implicitly {@link NT.ClientCustomModEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {NT.IClientCustomModEvent} message ClientCustomModEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientCustomModEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientCustomModEvent message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientCustomModEvent} ClientCustomModEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientCustomModEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientCustomModEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.payload = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientCustomModEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientCustomModEvent} ClientCustomModEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientCustomModEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientCustomModEvent message.
         * @function verify
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientCustomModEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!$util.isString(message.payload))
                    return "payload: string expected";
            return null;
        };

        /**
         * Creates a ClientCustomModEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientCustomModEvent} ClientCustomModEvent
         */
        ClientCustomModEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientCustomModEvent)
                return object;
            let message = new $root.NT.ClientCustomModEvent();
            if (object.payload != null)
                message.payload = String(object.payload);
            return message;
        };

        /**
         * Creates a plain object from a ClientCustomModEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {NT.ClientCustomModEvent} message ClientCustomModEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientCustomModEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.payload = "";
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = message.payload;
            return object;
        };

        /**
         * Converts this ClientCustomModEvent to JSON.
         * @function toJSON
         * @memberof NT.ClientCustomModEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientCustomModEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientCustomModEvent
         * @function getTypeUrl
         * @memberof NT.ClientCustomModEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientCustomModEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientCustomModEvent";
        };

        return ClientCustomModEvent;
    })();

    NT.ServerCustomModEvent = (function() {

        /**
         * Properties of a ServerCustomModEvent.
         * @memberof NT
         * @interface IServerCustomModEvent
         * @property {string|null} [userId] ServerCustomModEvent userId
         * @property {string|null} [payload] ServerCustomModEvent payload
         */

        /**
         * Constructs a new ServerCustomModEvent.
         * @memberof NT
         * @classdesc Represents a ServerCustomModEvent.
         * @implements IServerCustomModEvent
         * @constructor
         * @param {NT.IServerCustomModEvent=} [properties] Properties to set
         */
        function ServerCustomModEvent(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerCustomModEvent userId.
         * @member {string} userId
         * @memberof NT.ServerCustomModEvent
         * @instance
         */
        ServerCustomModEvent.prototype.userId = "";

        /**
         * ServerCustomModEvent payload.
         * @member {string} payload
         * @memberof NT.ServerCustomModEvent
         * @instance
         */
        ServerCustomModEvent.prototype.payload = "";

        /**
         * Creates a new ServerCustomModEvent instance using the specified properties.
         * @function create
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {NT.IServerCustomModEvent=} [properties] Properties to set
         * @returns {NT.ServerCustomModEvent} ServerCustomModEvent instance
         */
        ServerCustomModEvent.create = function create(properties) {
            return new ServerCustomModEvent(properties);
        };

        /**
         * Encodes the specified ServerCustomModEvent message. Does not implicitly {@link NT.ServerCustomModEvent.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {NT.IServerCustomModEvent} message ServerCustomModEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerCustomModEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.payload);
            return writer;
        };

        /**
         * Encodes the specified ServerCustomModEvent message, length delimited. Does not implicitly {@link NT.ServerCustomModEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {NT.IServerCustomModEvent} message ServerCustomModEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerCustomModEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerCustomModEvent message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerCustomModEvent} ServerCustomModEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerCustomModEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerCustomModEvent();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.payload = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerCustomModEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerCustomModEvent} ServerCustomModEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerCustomModEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerCustomModEvent message.
         * @function verify
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerCustomModEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.payload != null && message.hasOwnProperty("payload"))
                if (!$util.isString(message.payload))
                    return "payload: string expected";
            return null;
        };

        /**
         * Creates a ServerCustomModEvent message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerCustomModEvent} ServerCustomModEvent
         */
        ServerCustomModEvent.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerCustomModEvent)
                return object;
            let message = new $root.NT.ServerCustomModEvent();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.payload != null)
                message.payload = String(object.payload);
            return message;
        };

        /**
         * Creates a plain object from a ServerCustomModEvent message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {NT.ServerCustomModEvent} message ServerCustomModEvent
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerCustomModEvent.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.payload = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = message.payload;
            return object;
        };

        /**
         * Converts this ServerCustomModEvent to JSON.
         * @function toJSON
         * @memberof NT.ServerCustomModEvent
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerCustomModEvent.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerCustomModEvent
         * @function getTypeUrl
         * @memberof NT.ServerCustomModEvent
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerCustomModEvent.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerCustomModEvent";
        };

        return ServerCustomModEvent;
    })();

    NT.ClientRespawnPenalty = (function() {

        /**
         * Properties of a ClientRespawnPenalty.
         * @memberof NT
         * @interface IClientRespawnPenalty
         * @property {number|null} [deaths] ClientRespawnPenalty deaths
         */

        /**
         * Constructs a new ClientRespawnPenalty.
         * @memberof NT
         * @classdesc Represents a ClientRespawnPenalty.
         * @implements IClientRespawnPenalty
         * @constructor
         * @param {NT.IClientRespawnPenalty=} [properties] Properties to set
         */
        function ClientRespawnPenalty(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRespawnPenalty deaths.
         * @member {number} deaths
         * @memberof NT.ClientRespawnPenalty
         * @instance
         */
        ClientRespawnPenalty.prototype.deaths = 0;

        /**
         * Creates a new ClientRespawnPenalty instance using the specified properties.
         * @function create
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {NT.IClientRespawnPenalty=} [properties] Properties to set
         * @returns {NT.ClientRespawnPenalty} ClientRespawnPenalty instance
         */
        ClientRespawnPenalty.create = function create(properties) {
            return new ClientRespawnPenalty(properties);
        };

        /**
         * Encodes the specified ClientRespawnPenalty message. Does not implicitly {@link NT.ClientRespawnPenalty.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {NT.IClientRespawnPenalty} message ClientRespawnPenalty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRespawnPenalty.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.deaths != null && Object.hasOwnProperty.call(message, "deaths"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.deaths);
            return writer;
        };

        /**
         * Encodes the specified ClientRespawnPenalty message, length delimited. Does not implicitly {@link NT.ClientRespawnPenalty.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {NT.IClientRespawnPenalty} message ClientRespawnPenalty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRespawnPenalty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRespawnPenalty message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRespawnPenalty} ClientRespawnPenalty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRespawnPenalty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRespawnPenalty();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.deaths = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRespawnPenalty message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRespawnPenalty} ClientRespawnPenalty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRespawnPenalty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRespawnPenalty message.
         * @function verify
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRespawnPenalty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                if (!$util.isInteger(message.deaths))
                    return "deaths: integer expected";
            return null;
        };

        /**
         * Creates a ClientRespawnPenalty message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRespawnPenalty} ClientRespawnPenalty
         */
        ClientRespawnPenalty.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRespawnPenalty)
                return object;
            let message = new $root.NT.ClientRespawnPenalty();
            if (object.deaths != null)
                message.deaths = object.deaths >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientRespawnPenalty message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {NT.ClientRespawnPenalty} message ClientRespawnPenalty
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRespawnPenalty.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.deaths = 0;
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                object.deaths = message.deaths;
            return object;
        };

        /**
         * Converts this ClientRespawnPenalty to JSON.
         * @function toJSON
         * @memberof NT.ClientRespawnPenalty
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRespawnPenalty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRespawnPenalty
         * @function getTypeUrl
         * @memberof NT.ClientRespawnPenalty
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRespawnPenalty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRespawnPenalty";
        };

        return ClientRespawnPenalty;
    })();

    NT.ServerRespawnPenalty = (function() {

        /**
         * Properties of a ServerRespawnPenalty.
         * @memberof NT
         * @interface IServerRespawnPenalty
         * @property {string|null} [userId] ServerRespawnPenalty userId
         * @property {number|null} [deaths] ServerRespawnPenalty deaths
         */

        /**
         * Constructs a new ServerRespawnPenalty.
         * @memberof NT
         * @classdesc Represents a ServerRespawnPenalty.
         * @implements IServerRespawnPenalty
         * @constructor
         * @param {NT.IServerRespawnPenalty=} [properties] Properties to set
         */
        function ServerRespawnPenalty(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRespawnPenalty userId.
         * @member {string} userId
         * @memberof NT.ServerRespawnPenalty
         * @instance
         */
        ServerRespawnPenalty.prototype.userId = "";

        /**
         * ServerRespawnPenalty deaths.
         * @member {number} deaths
         * @memberof NT.ServerRespawnPenalty
         * @instance
         */
        ServerRespawnPenalty.prototype.deaths = 0;

        /**
         * Creates a new ServerRespawnPenalty instance using the specified properties.
         * @function create
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {NT.IServerRespawnPenalty=} [properties] Properties to set
         * @returns {NT.ServerRespawnPenalty} ServerRespawnPenalty instance
         */
        ServerRespawnPenalty.create = function create(properties) {
            return new ServerRespawnPenalty(properties);
        };

        /**
         * Encodes the specified ServerRespawnPenalty message. Does not implicitly {@link NT.ServerRespawnPenalty.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {NT.IServerRespawnPenalty} message ServerRespawnPenalty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRespawnPenalty.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.deaths != null && Object.hasOwnProperty.call(message, "deaths"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.deaths);
            return writer;
        };

        /**
         * Encodes the specified ServerRespawnPenalty message, length delimited. Does not implicitly {@link NT.ServerRespawnPenalty.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {NT.IServerRespawnPenalty} message ServerRespawnPenalty message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRespawnPenalty.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRespawnPenalty message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRespawnPenalty} ServerRespawnPenalty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRespawnPenalty.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRespawnPenalty();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.deaths = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRespawnPenalty message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRespawnPenalty} ServerRespawnPenalty
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRespawnPenalty.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRespawnPenalty message.
         * @function verify
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRespawnPenalty.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                if (!$util.isInteger(message.deaths))
                    return "deaths: integer expected";
            return null;
        };

        /**
         * Creates a ServerRespawnPenalty message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRespawnPenalty} ServerRespawnPenalty
         */
        ServerRespawnPenalty.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRespawnPenalty)
                return object;
            let message = new $root.NT.ServerRespawnPenalty();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.deaths != null)
                message.deaths = object.deaths >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerRespawnPenalty message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {NT.ServerRespawnPenalty} message ServerRespawnPenalty
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRespawnPenalty.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.deaths = 0;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.deaths != null && message.hasOwnProperty("deaths"))
                object.deaths = message.deaths;
            return object;
        };

        /**
         * Converts this ServerRespawnPenalty to JSON.
         * @function toJSON
         * @memberof NT.ServerRespawnPenalty
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRespawnPenalty.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRespawnPenalty
         * @function getTypeUrl
         * @memberof NT.ServerRespawnPenalty
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRespawnPenalty.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRespawnPenalty";
        };

        return ServerRespawnPenalty;
    })();

    NT.ClientAngerySteve = (function() {

        /**
         * Properties of a ClientAngerySteve.
         * @memberof NT
         * @interface IClientAngerySteve
         * @property {boolean|null} [idk] ClientAngerySteve idk
         */

        /**
         * Constructs a new ClientAngerySteve.
         * @memberof NT
         * @classdesc Represents a ClientAngerySteve.
         * @implements IClientAngerySteve
         * @constructor
         * @param {NT.IClientAngerySteve=} [properties] Properties to set
         */
        function ClientAngerySteve(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientAngerySteve idk.
         * @member {boolean} idk
         * @memberof NT.ClientAngerySteve
         * @instance
         */
        ClientAngerySteve.prototype.idk = false;

        /**
         * Creates a new ClientAngerySteve instance using the specified properties.
         * @function create
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {NT.IClientAngerySteve=} [properties] Properties to set
         * @returns {NT.ClientAngerySteve} ClientAngerySteve instance
         */
        ClientAngerySteve.create = function create(properties) {
            return new ClientAngerySteve(properties);
        };

        /**
         * Encodes the specified ClientAngerySteve message. Does not implicitly {@link NT.ClientAngerySteve.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {NT.IClientAngerySteve} message ClientAngerySteve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientAngerySteve.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idk != null && Object.hasOwnProperty.call(message, "idk"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.idk);
            return writer;
        };

        /**
         * Encodes the specified ClientAngerySteve message, length delimited. Does not implicitly {@link NT.ClientAngerySteve.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {NT.IClientAngerySteve} message ClientAngerySteve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientAngerySteve.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientAngerySteve message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientAngerySteve} ClientAngerySteve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientAngerySteve.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientAngerySteve();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idk = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientAngerySteve message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientAngerySteve} ClientAngerySteve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientAngerySteve.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientAngerySteve message.
         * @function verify
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientAngerySteve.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idk != null && message.hasOwnProperty("idk"))
                if (typeof message.idk !== "boolean")
                    return "idk: boolean expected";
            return null;
        };

        /**
         * Creates a ClientAngerySteve message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientAngerySteve} ClientAngerySteve
         */
        ClientAngerySteve.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientAngerySteve)
                return object;
            let message = new $root.NT.ClientAngerySteve();
            if (object.idk != null)
                message.idk = Boolean(object.idk);
            return message;
        };

        /**
         * Creates a plain object from a ClientAngerySteve message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {NT.ClientAngerySteve} message ClientAngerySteve
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientAngerySteve.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.idk = false;
            if (message.idk != null && message.hasOwnProperty("idk"))
                object.idk = message.idk;
            return object;
        };

        /**
         * Converts this ClientAngerySteve to JSON.
         * @function toJSON
         * @memberof NT.ClientAngerySteve
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientAngerySteve.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientAngerySteve
         * @function getTypeUrl
         * @memberof NT.ClientAngerySteve
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientAngerySteve.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientAngerySteve";
        };

        return ClientAngerySteve;
    })();

    NT.ServerAngerySteve = (function() {

        /**
         * Properties of a ServerAngerySteve.
         * @memberof NT
         * @interface IServerAngerySteve
         * @property {string|null} [userId] ServerAngerySteve userId
         */

        /**
         * Constructs a new ServerAngerySteve.
         * @memberof NT
         * @classdesc Represents a ServerAngerySteve.
         * @implements IServerAngerySteve
         * @constructor
         * @param {NT.IServerAngerySteve=} [properties] Properties to set
         */
        function ServerAngerySteve(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerAngerySteve userId.
         * @member {string} userId
         * @memberof NT.ServerAngerySteve
         * @instance
         */
        ServerAngerySteve.prototype.userId = "";

        /**
         * Creates a new ServerAngerySteve instance using the specified properties.
         * @function create
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {NT.IServerAngerySteve=} [properties] Properties to set
         * @returns {NT.ServerAngerySteve} ServerAngerySteve instance
         */
        ServerAngerySteve.create = function create(properties) {
            return new ServerAngerySteve(properties);
        };

        /**
         * Encodes the specified ServerAngerySteve message. Does not implicitly {@link NT.ServerAngerySteve.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {NT.IServerAngerySteve} message ServerAngerySteve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerAngerySteve.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ServerAngerySteve message, length delimited. Does not implicitly {@link NT.ServerAngerySteve.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {NT.IServerAngerySteve} message ServerAngerySteve message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerAngerySteve.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerAngerySteve message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerAngerySteve} ServerAngerySteve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerAngerySteve.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerAngerySteve();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerAngerySteve message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerAngerySteve} ServerAngerySteve
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerAngerySteve.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerAngerySteve message.
         * @function verify
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerAngerySteve.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ServerAngerySteve message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerAngerySteve} ServerAngerySteve
         */
        ServerAngerySteve.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerAngerySteve)
                return object;
            let message = new $root.NT.ServerAngerySteve();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ServerAngerySteve message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {NT.ServerAngerySteve} message ServerAngerySteve
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerAngerySteve.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ServerAngerySteve to JSON.
         * @function toJSON
         * @memberof NT.ServerAngerySteve
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerAngerySteve.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerAngerySteve
         * @function getTypeUrl
         * @memberof NT.ServerAngerySteve
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerAngerySteve.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerAngerySteve";
        };

        return ServerAngerySteve;
    })();

    NT.Wand = (function() {

        /**
         * Properties of a Wand.
         * @memberof NT
         * @interface IWand
         * @property {string|null} [id] Wand id
         * @property {NT.Wand.IWandStats|null} [stats] Wand stats
         * @property {Array.<NT.ISpell>|null} [alwaysCast] Wand alwaysCast
         * @property {Array.<NT.ISpell>|null} [deck] Wand deck
         * @property {string|null} [sentBy] Wand sentBy
         * @property {string|null} [contributedBy] Wand contributedBy
         */

        /**
         * Constructs a new Wand.
         * @memberof NT
         * @classdesc Represents a Wand.
         * @implements IWand
         * @constructor
         * @param {NT.IWand=} [properties] Properties to set
         */
        function Wand(properties) {
            this.alwaysCast = [];
            this.deck = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Wand id.
         * @member {string} id
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.id = "";

        /**
         * Wand stats.
         * @member {NT.Wand.IWandStats|null|undefined} stats
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.stats = null;

        /**
         * Wand alwaysCast.
         * @member {Array.<NT.ISpell>} alwaysCast
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.alwaysCast = $util.emptyArray;

        /**
         * Wand deck.
         * @member {Array.<NT.ISpell>} deck
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.deck = $util.emptyArray;

        /**
         * Wand sentBy.
         * @member {string|null|undefined} sentBy
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.sentBy = null;

        /**
         * Wand contributedBy.
         * @member {string|null|undefined} contributedBy
         * @memberof NT.Wand
         * @instance
         */
        Wand.prototype.contributedBy = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Wand _sentBy.
         * @member {"sentBy"|undefined} _sentBy
         * @memberof NT.Wand
         * @instance
         */
        Object.defineProperty(Wand.prototype, "_sentBy", {
            get: $util.oneOfGetter($oneOfFields = ["sentBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Wand _contributedBy.
         * @member {"contributedBy"|undefined} _contributedBy
         * @memberof NT.Wand
         * @instance
         */
        Object.defineProperty(Wand.prototype, "_contributedBy", {
            get: $util.oneOfGetter($oneOfFields = ["contributedBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Wand instance using the specified properties.
         * @function create
         * @memberof NT.Wand
         * @static
         * @param {NT.IWand=} [properties] Properties to set
         * @returns {NT.Wand} Wand instance
         */
        Wand.create = function create(properties) {
            return new Wand(properties);
        };

        /**
         * Encodes the specified Wand message. Does not implicitly {@link NT.Wand.verify|verify} messages.
         * @function encode
         * @memberof NT.Wand
         * @static
         * @param {NT.IWand} message Wand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.stats != null && Object.hasOwnProperty.call(message, "stats"))
                $root.NT.Wand.WandStats.encode(message.stats, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.alwaysCast != null && message.alwaysCast.length)
                for (let i = 0; i < message.alwaysCast.length; ++i)
                    $root.NT.Spell.encode(message.alwaysCast[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.deck != null && message.deck.length)
                for (let i = 0; i < message.deck.length; ++i)
                    $root.NT.Spell.encode(message.deck[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.sentBy != null && Object.hasOwnProperty.call(message, "sentBy"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.sentBy);
            if (message.contributedBy != null && Object.hasOwnProperty.call(message, "contributedBy"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.contributedBy);
            return writer;
        };

        /**
         * Encodes the specified Wand message, length delimited. Does not implicitly {@link NT.Wand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.Wand
         * @static
         * @param {NT.IWand} message Wand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Wand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Wand message from the specified reader or buffer.
         * @function decode
         * @memberof NT.Wand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.Wand} Wand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Wand();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.stats = $root.NT.Wand.WandStats.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.alwaysCast && message.alwaysCast.length))
                            message.alwaysCast = [];
                        message.alwaysCast.push($root.NT.Spell.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        if (!(message.deck && message.deck.length))
                            message.deck = [];
                        message.deck.push($root.NT.Spell.decode(reader, reader.uint32()));
                        break;
                    }
                case 5: {
                        message.sentBy = reader.string();
                        break;
                    }
                case 6: {
                        message.contributedBy = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Wand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.Wand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.Wand} Wand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Wand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Wand message.
         * @function verify
         * @memberof NT.Wand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Wand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.stats != null && message.hasOwnProperty("stats")) {
                let error = $root.NT.Wand.WandStats.verify(message.stats);
                if (error)
                    return "stats." + error;
            }
            if (message.alwaysCast != null && message.hasOwnProperty("alwaysCast")) {
                if (!Array.isArray(message.alwaysCast))
                    return "alwaysCast: array expected";
                for (let i = 0; i < message.alwaysCast.length; ++i) {
                    let error = $root.NT.Spell.verify(message.alwaysCast[i]);
                    if (error)
                        return "alwaysCast." + error;
                }
            }
            if (message.deck != null && message.hasOwnProperty("deck")) {
                if (!Array.isArray(message.deck))
                    return "deck: array expected";
                for (let i = 0; i < message.deck.length; ++i) {
                    let error = $root.NT.Spell.verify(message.deck[i]);
                    if (error)
                        return "deck." + error;
                }
            }
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                properties._sentBy = 1;
                if (!$util.isString(message.sentBy))
                    return "sentBy: string expected";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                properties._contributedBy = 1;
                if (!$util.isString(message.contributedBy))
                    return "contributedBy: string expected";
            }
            return null;
        };

        /**
         * Creates a Wand message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.Wand
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.Wand} Wand
         */
        Wand.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.Wand)
                return object;
            let message = new $root.NT.Wand();
            if (object.id != null)
                message.id = String(object.id);
            if (object.stats != null) {
                if (typeof object.stats !== "object")
                    throw TypeError(".NT.Wand.stats: object expected");
                message.stats = $root.NT.Wand.WandStats.fromObject(object.stats);
            }
            if (object.alwaysCast) {
                if (!Array.isArray(object.alwaysCast))
                    throw TypeError(".NT.Wand.alwaysCast: array expected");
                message.alwaysCast = [];
                for (let i = 0; i < object.alwaysCast.length; ++i) {
                    if (typeof object.alwaysCast[i] !== "object")
                        throw TypeError(".NT.Wand.alwaysCast: object expected");
                    message.alwaysCast[i] = $root.NT.Spell.fromObject(object.alwaysCast[i]);
                }
            }
            if (object.deck) {
                if (!Array.isArray(object.deck))
                    throw TypeError(".NT.Wand.deck: array expected");
                message.deck = [];
                for (let i = 0; i < object.deck.length; ++i) {
                    if (typeof object.deck[i] !== "object")
                        throw TypeError(".NT.Wand.deck: object expected");
                    message.deck[i] = $root.NT.Spell.fromObject(object.deck[i]);
                }
            }
            if (object.sentBy != null)
                message.sentBy = String(object.sentBy);
            if (object.contributedBy != null)
                message.contributedBy = String(object.contributedBy);
            return message;
        };

        /**
         * Creates a plain object from a Wand message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.Wand
         * @static
         * @param {NT.Wand} message Wand
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Wand.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object.alwaysCast = [];
                object.deck = [];
            }
            if (options.defaults) {
                object.id = "";
                object.stats = null;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.stats != null && message.hasOwnProperty("stats"))
                object.stats = $root.NT.Wand.WandStats.toObject(message.stats, options);
            if (message.alwaysCast && message.alwaysCast.length) {
                object.alwaysCast = [];
                for (let j = 0; j < message.alwaysCast.length; ++j)
                    object.alwaysCast[j] = $root.NT.Spell.toObject(message.alwaysCast[j], options);
            }
            if (message.deck && message.deck.length) {
                object.deck = [];
                for (let j = 0; j < message.deck.length; ++j)
                    object.deck[j] = $root.NT.Spell.toObject(message.deck[j], options);
            }
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                object.sentBy = message.sentBy;
                if (options.oneofs)
                    object._sentBy = "sentBy";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                object.contributedBy = message.contributedBy;
                if (options.oneofs)
                    object._contributedBy = "contributedBy";
            }
            return object;
        };

        /**
         * Converts this Wand to JSON.
         * @function toJSON
         * @memberof NT.Wand
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Wand.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Wand
         * @function getTypeUrl
         * @memberof NT.Wand
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Wand.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.Wand";
        };

        Wand.WandStats = (function() {

            /**
             * Properties of a WandStats.
             * @memberof NT.Wand
             * @interface IWandStats
             * @property {string|null} [sprite] WandStats sprite
             * @property {boolean|null} [named] WandStats named
             * @property {string|null} [uiName] WandStats uiName
             * @property {number|null} [manaMax] WandStats manaMax
             * @property {number|null} [manaChargeSpeed] WandStats manaChargeSpeed
             * @property {number|null} [reloadTime] WandStats reloadTime
             * @property {number|null} [actionsPerRound] WandStats actionsPerRound
             * @property {number|null} [deckCapacity] WandStats deckCapacity
             * @property {boolean|null} [shuffleDeckWhenEmpty] WandStats shuffleDeckWhenEmpty
             * @property {number|null} [spreadDegrees] WandStats spreadDegrees
             * @property {number|null} [speedMultiplier] WandStats speedMultiplier
             * @property {number|null} [fireRateWait] WandStats fireRateWait
             * @property {number|null} [tipX] WandStats tipX
             * @property {number|null} [tipY] WandStats tipY
             * @property {number|null} [gripX] WandStats gripX
             * @property {number|null} [gripY] WandStats gripY
             */

            /**
             * Constructs a new WandStats.
             * @memberof NT.Wand
             * @classdesc Represents a WandStats.
             * @implements IWandStats
             * @constructor
             * @param {NT.Wand.IWandStats=} [properties] Properties to set
             */
            function WandStats(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * WandStats sprite.
             * @member {string} sprite
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.sprite = "";

            /**
             * WandStats named.
             * @member {boolean} named
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.named = false;

            /**
             * WandStats uiName.
             * @member {string} uiName
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.uiName = "";

            /**
             * WandStats manaMax.
             * @member {number} manaMax
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.manaMax = 0;

            /**
             * WandStats manaChargeSpeed.
             * @member {number} manaChargeSpeed
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.manaChargeSpeed = 0;

            /**
             * WandStats reloadTime.
             * @member {number} reloadTime
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.reloadTime = 0;

            /**
             * WandStats actionsPerRound.
             * @member {number} actionsPerRound
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.actionsPerRound = 0;

            /**
             * WandStats deckCapacity.
             * @member {number} deckCapacity
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.deckCapacity = 0;

            /**
             * WandStats shuffleDeckWhenEmpty.
             * @member {boolean} shuffleDeckWhenEmpty
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.shuffleDeckWhenEmpty = false;

            /**
             * WandStats spreadDegrees.
             * @member {number} spreadDegrees
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.spreadDegrees = 0;

            /**
             * WandStats speedMultiplier.
             * @member {number} speedMultiplier
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.speedMultiplier = 0;

            /**
             * WandStats fireRateWait.
             * @member {number} fireRateWait
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.fireRateWait = 0;

            /**
             * WandStats tipX.
             * @member {number} tipX
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.tipX = 0;

            /**
             * WandStats tipY.
             * @member {number} tipY
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.tipY = 0;

            /**
             * WandStats gripX.
             * @member {number} gripX
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.gripX = 0;

            /**
             * WandStats gripY.
             * @member {number} gripY
             * @memberof NT.Wand.WandStats
             * @instance
             */
            WandStats.prototype.gripY = 0;

            /**
             * Creates a new WandStats instance using the specified properties.
             * @function create
             * @memberof NT.Wand.WandStats
             * @static
             * @param {NT.Wand.IWandStats=} [properties] Properties to set
             * @returns {NT.Wand.WandStats} WandStats instance
             */
            WandStats.create = function create(properties) {
                return new WandStats(properties);
            };

            /**
             * Encodes the specified WandStats message. Does not implicitly {@link NT.Wand.WandStats.verify|verify} messages.
             * @function encode
             * @memberof NT.Wand.WandStats
             * @static
             * @param {NT.Wand.IWandStats} message WandStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WandStats.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.sprite != null && Object.hasOwnProperty.call(message, "sprite"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.sprite);
                if (message.named != null && Object.hasOwnProperty.call(message, "named"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.named);
                if (message.uiName != null && Object.hasOwnProperty.call(message, "uiName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.uiName);
                if (message.manaMax != null && Object.hasOwnProperty.call(message, "manaMax"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.manaMax);
                if (message.manaChargeSpeed != null && Object.hasOwnProperty.call(message, "manaChargeSpeed"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.manaChargeSpeed);
                if (message.reloadTime != null && Object.hasOwnProperty.call(message, "reloadTime"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.reloadTime);
                if (message.actionsPerRound != null && Object.hasOwnProperty.call(message, "actionsPerRound"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.actionsPerRound);
                if (message.deckCapacity != null && Object.hasOwnProperty.call(message, "deckCapacity"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.deckCapacity);
                if (message.shuffleDeckWhenEmpty != null && Object.hasOwnProperty.call(message, "shuffleDeckWhenEmpty"))
                    writer.uint32(/* id 9, wireType 0 =*/72).bool(message.shuffleDeckWhenEmpty);
                if (message.spreadDegrees != null && Object.hasOwnProperty.call(message, "spreadDegrees"))
                    writer.uint32(/* id 10, wireType 5 =*/85).float(message.spreadDegrees);
                if (message.speedMultiplier != null && Object.hasOwnProperty.call(message, "speedMultiplier"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.speedMultiplier);
                if (message.fireRateWait != null && Object.hasOwnProperty.call(message, "fireRateWait"))
                    writer.uint32(/* id 12, wireType 0 =*/96).int32(message.fireRateWait);
                if (message.tipX != null && Object.hasOwnProperty.call(message, "tipX"))
                    writer.uint32(/* id 13, wireType 5 =*/109).float(message.tipX);
                if (message.tipY != null && Object.hasOwnProperty.call(message, "tipY"))
                    writer.uint32(/* id 14, wireType 5 =*/117).float(message.tipY);
                if (message.gripX != null && Object.hasOwnProperty.call(message, "gripX"))
                    writer.uint32(/* id 15, wireType 5 =*/125).float(message.gripX);
                if (message.gripY != null && Object.hasOwnProperty.call(message, "gripY"))
                    writer.uint32(/* id 16, wireType 5 =*/133).float(message.gripY);
                return writer;
            };

            /**
             * Encodes the specified WandStats message, length delimited. Does not implicitly {@link NT.Wand.WandStats.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.Wand.WandStats
             * @static
             * @param {NT.Wand.IWandStats} message WandStats message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            WandStats.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a WandStats message from the specified reader or buffer.
             * @function decode
             * @memberof NT.Wand.WandStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.Wand.WandStats} WandStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WandStats.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Wand.WandStats();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.sprite = reader.string();
                            break;
                        }
                    case 2: {
                            message.named = reader.bool();
                            break;
                        }
                    case 3: {
                            message.uiName = reader.string();
                            break;
                        }
                    case 4: {
                            message.manaMax = reader.float();
                            break;
                        }
                    case 5: {
                            message.manaChargeSpeed = reader.float();
                            break;
                        }
                    case 6: {
                            message.reloadTime = reader.int32();
                            break;
                        }
                    case 7: {
                            message.actionsPerRound = reader.uint32();
                            break;
                        }
                    case 8: {
                            message.deckCapacity = reader.uint32();
                            break;
                        }
                    case 9: {
                            message.shuffleDeckWhenEmpty = reader.bool();
                            break;
                        }
                    case 10: {
                            message.spreadDegrees = reader.float();
                            break;
                        }
                    case 11: {
                            message.speedMultiplier = reader.float();
                            break;
                        }
                    case 12: {
                            message.fireRateWait = reader.int32();
                            break;
                        }
                    case 13: {
                            message.tipX = reader.float();
                            break;
                        }
                    case 14: {
                            message.tipY = reader.float();
                            break;
                        }
                    case 15: {
                            message.gripX = reader.float();
                            break;
                        }
                    case 16: {
                            message.gripY = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a WandStats message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.Wand.WandStats
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.Wand.WandStats} WandStats
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            WandStats.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a WandStats message.
             * @function verify
             * @memberof NT.Wand.WandStats
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            WandStats.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.sprite != null && message.hasOwnProperty("sprite"))
                    if (!$util.isString(message.sprite))
                        return "sprite: string expected";
                if (message.named != null && message.hasOwnProperty("named"))
                    if (typeof message.named !== "boolean")
                        return "named: boolean expected";
                if (message.uiName != null && message.hasOwnProperty("uiName"))
                    if (!$util.isString(message.uiName))
                        return "uiName: string expected";
                if (message.manaMax != null && message.hasOwnProperty("manaMax"))
                    if (typeof message.manaMax !== "number")
                        return "manaMax: number expected";
                if (message.manaChargeSpeed != null && message.hasOwnProperty("manaChargeSpeed"))
                    if (typeof message.manaChargeSpeed !== "number")
                        return "manaChargeSpeed: number expected";
                if (message.reloadTime != null && message.hasOwnProperty("reloadTime"))
                    if (!$util.isInteger(message.reloadTime))
                        return "reloadTime: integer expected";
                if (message.actionsPerRound != null && message.hasOwnProperty("actionsPerRound"))
                    if (!$util.isInteger(message.actionsPerRound))
                        return "actionsPerRound: integer expected";
                if (message.deckCapacity != null && message.hasOwnProperty("deckCapacity"))
                    if (!$util.isInteger(message.deckCapacity))
                        return "deckCapacity: integer expected";
                if (message.shuffleDeckWhenEmpty != null && message.hasOwnProperty("shuffleDeckWhenEmpty"))
                    if (typeof message.shuffleDeckWhenEmpty !== "boolean")
                        return "shuffleDeckWhenEmpty: boolean expected";
                if (message.spreadDegrees != null && message.hasOwnProperty("spreadDegrees"))
                    if (typeof message.spreadDegrees !== "number")
                        return "spreadDegrees: number expected";
                if (message.speedMultiplier != null && message.hasOwnProperty("speedMultiplier"))
                    if (typeof message.speedMultiplier !== "number")
                        return "speedMultiplier: number expected";
                if (message.fireRateWait != null && message.hasOwnProperty("fireRateWait"))
                    if (!$util.isInteger(message.fireRateWait))
                        return "fireRateWait: integer expected";
                if (message.tipX != null && message.hasOwnProperty("tipX"))
                    if (typeof message.tipX !== "number")
                        return "tipX: number expected";
                if (message.tipY != null && message.hasOwnProperty("tipY"))
                    if (typeof message.tipY !== "number")
                        return "tipY: number expected";
                if (message.gripX != null && message.hasOwnProperty("gripX"))
                    if (typeof message.gripX !== "number")
                        return "gripX: number expected";
                if (message.gripY != null && message.hasOwnProperty("gripY"))
                    if (typeof message.gripY !== "number")
                        return "gripY: number expected";
                return null;
            };

            /**
             * Creates a WandStats message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.Wand.WandStats
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.Wand.WandStats} WandStats
             */
            WandStats.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.Wand.WandStats)
                    return object;
                let message = new $root.NT.Wand.WandStats();
                if (object.sprite != null)
                    message.sprite = String(object.sprite);
                if (object.named != null)
                    message.named = Boolean(object.named);
                if (object.uiName != null)
                    message.uiName = String(object.uiName);
                if (object.manaMax != null)
                    message.manaMax = Number(object.manaMax);
                if (object.manaChargeSpeed != null)
                    message.manaChargeSpeed = Number(object.manaChargeSpeed);
                if (object.reloadTime != null)
                    message.reloadTime = object.reloadTime | 0;
                if (object.actionsPerRound != null)
                    message.actionsPerRound = object.actionsPerRound >>> 0;
                if (object.deckCapacity != null)
                    message.deckCapacity = object.deckCapacity >>> 0;
                if (object.shuffleDeckWhenEmpty != null)
                    message.shuffleDeckWhenEmpty = Boolean(object.shuffleDeckWhenEmpty);
                if (object.spreadDegrees != null)
                    message.spreadDegrees = Number(object.spreadDegrees);
                if (object.speedMultiplier != null)
                    message.speedMultiplier = Number(object.speedMultiplier);
                if (object.fireRateWait != null)
                    message.fireRateWait = object.fireRateWait | 0;
                if (object.tipX != null)
                    message.tipX = Number(object.tipX);
                if (object.tipY != null)
                    message.tipY = Number(object.tipY);
                if (object.gripX != null)
                    message.gripX = Number(object.gripX);
                if (object.gripY != null)
                    message.gripY = Number(object.gripY);
                return message;
            };

            /**
             * Creates a plain object from a WandStats message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.Wand.WandStats
             * @static
             * @param {NT.Wand.WandStats} message WandStats
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            WandStats.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.sprite = "";
                    object.named = false;
                    object.uiName = "";
                    object.manaMax = 0;
                    object.manaChargeSpeed = 0;
                    object.reloadTime = 0;
                    object.actionsPerRound = 0;
                    object.deckCapacity = 0;
                    object.shuffleDeckWhenEmpty = false;
                    object.spreadDegrees = 0;
                    object.speedMultiplier = 0;
                    object.fireRateWait = 0;
                    object.tipX = 0;
                    object.tipY = 0;
                    object.gripX = 0;
                    object.gripY = 0;
                }
                if (message.sprite != null && message.hasOwnProperty("sprite"))
                    object.sprite = message.sprite;
                if (message.named != null && message.hasOwnProperty("named"))
                    object.named = message.named;
                if (message.uiName != null && message.hasOwnProperty("uiName"))
                    object.uiName = message.uiName;
                if (message.manaMax != null && message.hasOwnProperty("manaMax"))
                    object.manaMax = options.json && !isFinite(message.manaMax) ? String(message.manaMax) : message.manaMax;
                if (message.manaChargeSpeed != null && message.hasOwnProperty("manaChargeSpeed"))
                    object.manaChargeSpeed = options.json && !isFinite(message.manaChargeSpeed) ? String(message.manaChargeSpeed) : message.manaChargeSpeed;
                if (message.reloadTime != null && message.hasOwnProperty("reloadTime"))
                    object.reloadTime = message.reloadTime;
                if (message.actionsPerRound != null && message.hasOwnProperty("actionsPerRound"))
                    object.actionsPerRound = message.actionsPerRound;
                if (message.deckCapacity != null && message.hasOwnProperty("deckCapacity"))
                    object.deckCapacity = message.deckCapacity;
                if (message.shuffleDeckWhenEmpty != null && message.hasOwnProperty("shuffleDeckWhenEmpty"))
                    object.shuffleDeckWhenEmpty = message.shuffleDeckWhenEmpty;
                if (message.spreadDegrees != null && message.hasOwnProperty("spreadDegrees"))
                    object.spreadDegrees = options.json && !isFinite(message.spreadDegrees) ? String(message.spreadDegrees) : message.spreadDegrees;
                if (message.speedMultiplier != null && message.hasOwnProperty("speedMultiplier"))
                    object.speedMultiplier = options.json && !isFinite(message.speedMultiplier) ? String(message.speedMultiplier) : message.speedMultiplier;
                if (message.fireRateWait != null && message.hasOwnProperty("fireRateWait"))
                    object.fireRateWait = message.fireRateWait;
                if (message.tipX != null && message.hasOwnProperty("tipX"))
                    object.tipX = options.json && !isFinite(message.tipX) ? String(message.tipX) : message.tipX;
                if (message.tipY != null && message.hasOwnProperty("tipY"))
                    object.tipY = options.json && !isFinite(message.tipY) ? String(message.tipY) : message.tipY;
                if (message.gripX != null && message.hasOwnProperty("gripX"))
                    object.gripX = options.json && !isFinite(message.gripX) ? String(message.gripX) : message.gripX;
                if (message.gripY != null && message.hasOwnProperty("gripY"))
                    object.gripY = options.json && !isFinite(message.gripY) ? String(message.gripY) : message.gripY;
                return object;
            };

            /**
             * Converts this WandStats to JSON.
             * @function toJSON
             * @memberof NT.Wand.WandStats
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            WandStats.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for WandStats
             * @function getTypeUrl
             * @memberof NT.Wand.WandStats
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            WandStats.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.Wand.WandStats";
            };

            return WandStats;
        })();

        return Wand;
    })();

    NT.Spell = (function() {

        /**
         * Properties of a Spell.
         * @memberof NT
         * @interface ISpell
         * @property {string|null} [id] Spell id
         * @property {string|null} [gameId] Spell gameId
         * @property {string|null} [sentBy] Spell sentBy
         * @property {string|null} [contributedBy] Spell contributedBy
         * @property {number|null} [usesRemaining] Spell usesRemaining
         */

        /**
         * Constructs a new Spell.
         * @memberof NT
         * @classdesc Represents a Spell.
         * @implements ISpell
         * @constructor
         * @param {NT.ISpell=} [properties] Properties to set
         */
        function Spell(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Spell id.
         * @member {string} id
         * @memberof NT.Spell
         * @instance
         */
        Spell.prototype.id = "";

        /**
         * Spell gameId.
         * @member {string} gameId
         * @memberof NT.Spell
         * @instance
         */
        Spell.prototype.gameId = "";

        /**
         * Spell sentBy.
         * @member {string|null|undefined} sentBy
         * @memberof NT.Spell
         * @instance
         */
        Spell.prototype.sentBy = null;

        /**
         * Spell contributedBy.
         * @member {string|null|undefined} contributedBy
         * @memberof NT.Spell
         * @instance
         */
        Spell.prototype.contributedBy = null;

        /**
         * Spell usesRemaining.
         * @member {number} usesRemaining
         * @memberof NT.Spell
         * @instance
         */
        Spell.prototype.usesRemaining = 0;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Spell _sentBy.
         * @member {"sentBy"|undefined} _sentBy
         * @memberof NT.Spell
         * @instance
         */
        Object.defineProperty(Spell.prototype, "_sentBy", {
            get: $util.oneOfGetter($oneOfFields = ["sentBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Spell _contributedBy.
         * @member {"contributedBy"|undefined} _contributedBy
         * @memberof NT.Spell
         * @instance
         */
        Object.defineProperty(Spell.prototype, "_contributedBy", {
            get: $util.oneOfGetter($oneOfFields = ["contributedBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Spell instance using the specified properties.
         * @function create
         * @memberof NT.Spell
         * @static
         * @param {NT.ISpell=} [properties] Properties to set
         * @returns {NT.Spell} Spell instance
         */
        Spell.create = function create(properties) {
            return new Spell(properties);
        };

        /**
         * Encodes the specified Spell message. Does not implicitly {@link NT.Spell.verify|verify} messages.
         * @function encode
         * @memberof NT.Spell
         * @static
         * @param {NT.ISpell} message Spell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spell.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.gameId != null && Object.hasOwnProperty.call(message, "gameId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.gameId);
            if (message.sentBy != null && Object.hasOwnProperty.call(message, "sentBy"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sentBy);
            if (message.contributedBy != null && Object.hasOwnProperty.call(message, "contributedBy"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.contributedBy);
            if (message.usesRemaining != null && Object.hasOwnProperty.call(message, "usesRemaining"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.usesRemaining);
            return writer;
        };

        /**
         * Encodes the specified Spell message, length delimited. Does not implicitly {@link NT.Spell.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.Spell
         * @static
         * @param {NT.ISpell} message Spell message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Spell.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Spell message from the specified reader or buffer.
         * @function decode
         * @memberof NT.Spell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.Spell} Spell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spell.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Spell();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.gameId = reader.string();
                        break;
                    }
                case 3: {
                        message.sentBy = reader.string();
                        break;
                    }
                case 4: {
                        message.contributedBy = reader.string();
                        break;
                    }
                case 5: {
                        message.usesRemaining = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Spell message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.Spell
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.Spell} Spell
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Spell.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Spell message.
         * @function verify
         * @memberof NT.Spell
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Spell.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                if (!$util.isString(message.gameId))
                    return "gameId: string expected";
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                properties._sentBy = 1;
                if (!$util.isString(message.sentBy))
                    return "sentBy: string expected";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                properties._contributedBy = 1;
                if (!$util.isString(message.contributedBy))
                    return "contributedBy: string expected";
            }
            if (message.usesRemaining != null && message.hasOwnProperty("usesRemaining"))
                if (!$util.isInteger(message.usesRemaining))
                    return "usesRemaining: integer expected";
            return null;
        };

        /**
         * Creates a Spell message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.Spell
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.Spell} Spell
         */
        Spell.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.Spell)
                return object;
            let message = new $root.NT.Spell();
            if (object.id != null)
                message.id = String(object.id);
            if (object.gameId != null)
                message.gameId = String(object.gameId);
            if (object.sentBy != null)
                message.sentBy = String(object.sentBy);
            if (object.contributedBy != null)
                message.contributedBy = String(object.contributedBy);
            if (object.usesRemaining != null)
                message.usesRemaining = object.usesRemaining | 0;
            return message;
        };

        /**
         * Creates a plain object from a Spell message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.Spell
         * @static
         * @param {NT.Spell} message Spell
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Spell.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.gameId = "";
                object.usesRemaining = 0;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.gameId != null && message.hasOwnProperty("gameId"))
                object.gameId = message.gameId;
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                object.sentBy = message.sentBy;
                if (options.oneofs)
                    object._sentBy = "sentBy";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                object.contributedBy = message.contributedBy;
                if (options.oneofs)
                    object._contributedBy = "contributedBy";
            }
            if (message.usesRemaining != null && message.hasOwnProperty("usesRemaining"))
                object.usesRemaining = message.usesRemaining;
            return object;
        };

        /**
         * Converts this Spell to JSON.
         * @function toJSON
         * @memberof NT.Spell
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Spell.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Spell
         * @function getTypeUrl
         * @memberof NT.Spell
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Spell.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.Spell";
        };

        return Spell;
    })();

    NT.Item = (function() {

        /**
         * Properties of an Item.
         * @memberof NT
         * @interface IItem
         * @property {string|null} [id] Item id
         * @property {NT.Item.IColor|null} [color] Item color
         * @property {Array.<NT.Item.IMaterial>|null} [content] Item content
         * @property {string|null} [sentBy] Item sentBy
         * @property {string|null} [contributedBy] Item contributedBy
         * @property {boolean|null} [isChest] Item isChest
         * @property {string|null} [itemType] Item itemType
         */

        /**
         * Constructs a new Item.
         * @memberof NT
         * @classdesc Represents an Item.
         * @implements IItem
         * @constructor
         * @param {NT.IItem=} [properties] Properties to set
         */
        function Item(properties) {
            this.content = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Item id.
         * @member {string} id
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.id = "";

        /**
         * Item color.
         * @member {NT.Item.IColor|null|undefined} color
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.color = null;

        /**
         * Item content.
         * @member {Array.<NT.Item.IMaterial>} content
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.content = $util.emptyArray;

        /**
         * Item sentBy.
         * @member {string|null|undefined} sentBy
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.sentBy = null;

        /**
         * Item contributedBy.
         * @member {string|null|undefined} contributedBy
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.contributedBy = null;

        /**
         * Item isChest.
         * @member {boolean} isChest
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.isChest = false;

        /**
         * Item itemType.
         * @member {string} itemType
         * @memberof NT.Item
         * @instance
         */
        Item.prototype.itemType = "";

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * Item _sentBy.
         * @member {"sentBy"|undefined} _sentBy
         * @memberof NT.Item
         * @instance
         */
        Object.defineProperty(Item.prototype, "_sentBy", {
            get: $util.oneOfGetter($oneOfFields = ["sentBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Item _contributedBy.
         * @member {"contributedBy"|undefined} _contributedBy
         * @memberof NT.Item
         * @instance
         */
        Object.defineProperty(Item.prototype, "_contributedBy", {
            get: $util.oneOfGetter($oneOfFields = ["contributedBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new Item instance using the specified properties.
         * @function create
         * @memberof NT.Item
         * @static
         * @param {NT.IItem=} [properties] Properties to set
         * @returns {NT.Item} Item instance
         */
        Item.create = function create(properties) {
            return new Item(properties);
        };

        /**
         * Encodes the specified Item message. Does not implicitly {@link NT.Item.verify|verify} messages.
         * @function encode
         * @memberof NT.Item
         * @static
         * @param {NT.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.color != null && Object.hasOwnProperty.call(message, "color"))
                $root.NT.Item.Color.encode(message.color, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.content != null && message.content.length)
                for (let i = 0; i < message.content.length; ++i)
                    $root.NT.Item.Material.encode(message.content[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.sentBy != null && Object.hasOwnProperty.call(message, "sentBy"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sentBy);
            if (message.contributedBy != null && Object.hasOwnProperty.call(message, "contributedBy"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.contributedBy);
            if (message.isChest != null && Object.hasOwnProperty.call(message, "isChest"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isChest);
            if (message.itemType != null && Object.hasOwnProperty.call(message, "itemType"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.itemType);
            return writer;
        };

        /**
         * Encodes the specified Item message, length delimited. Does not implicitly {@link NT.Item.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.Item
         * @static
         * @param {NT.IItem} message Item message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Item.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Item message from the specified reader or buffer.
         * @function decode
         * @memberof NT.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Item();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.color = $root.NT.Item.Color.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        if (!(message.content && message.content.length))
                            message.content = [];
                        message.content.push($root.NT.Item.Material.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.sentBy = reader.string();
                        break;
                    }
                case 5: {
                        message.contributedBy = reader.string();
                        break;
                    }
                case 6: {
                        message.isChest = reader.bool();
                        break;
                    }
                case 7: {
                        message.itemType = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Item message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.Item
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.Item} Item
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Item.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Item message.
         * @function verify
         * @memberof NT.Item
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Item.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.color != null && message.hasOwnProperty("color")) {
                let error = $root.NT.Item.Color.verify(message.color);
                if (error)
                    return "color." + error;
            }
            if (message.content != null && message.hasOwnProperty("content")) {
                if (!Array.isArray(message.content))
                    return "content: array expected";
                for (let i = 0; i < message.content.length; ++i) {
                    let error = $root.NT.Item.Material.verify(message.content[i]);
                    if (error)
                        return "content." + error;
                }
            }
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                properties._sentBy = 1;
                if (!$util.isString(message.sentBy))
                    return "sentBy: string expected";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                properties._contributedBy = 1;
                if (!$util.isString(message.contributedBy))
                    return "contributedBy: string expected";
            }
            if (message.isChest != null && message.hasOwnProperty("isChest"))
                if (typeof message.isChest !== "boolean")
                    return "isChest: boolean expected";
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                if (!$util.isString(message.itemType))
                    return "itemType: string expected";
            return null;
        };

        /**
         * Creates an Item message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.Item
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.Item} Item
         */
        Item.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.Item)
                return object;
            let message = new $root.NT.Item();
            if (object.id != null)
                message.id = String(object.id);
            if (object.color != null) {
                if (typeof object.color !== "object")
                    throw TypeError(".NT.Item.color: object expected");
                message.color = $root.NT.Item.Color.fromObject(object.color);
            }
            if (object.content) {
                if (!Array.isArray(object.content))
                    throw TypeError(".NT.Item.content: array expected");
                message.content = [];
                for (let i = 0; i < object.content.length; ++i) {
                    if (typeof object.content[i] !== "object")
                        throw TypeError(".NT.Item.content: object expected");
                    message.content[i] = $root.NT.Item.Material.fromObject(object.content[i]);
                }
            }
            if (object.sentBy != null)
                message.sentBy = String(object.sentBy);
            if (object.contributedBy != null)
                message.contributedBy = String(object.contributedBy);
            if (object.isChest != null)
                message.isChest = Boolean(object.isChest);
            if (object.itemType != null)
                message.itemType = String(object.itemType);
            return message;
        };

        /**
         * Creates a plain object from an Item message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.Item
         * @static
         * @param {NT.Item} message Item
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Item.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.content = [];
            if (options.defaults) {
                object.id = "";
                object.color = null;
                object.isChest = false;
                object.itemType = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.color != null && message.hasOwnProperty("color"))
                object.color = $root.NT.Item.Color.toObject(message.color, options);
            if (message.content && message.content.length) {
                object.content = [];
                for (let j = 0; j < message.content.length; ++j)
                    object.content[j] = $root.NT.Item.Material.toObject(message.content[j], options);
            }
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                object.sentBy = message.sentBy;
                if (options.oneofs)
                    object._sentBy = "sentBy";
            }
            if (message.contributedBy != null && message.hasOwnProperty("contributedBy")) {
                object.contributedBy = message.contributedBy;
                if (options.oneofs)
                    object._contributedBy = "contributedBy";
            }
            if (message.isChest != null && message.hasOwnProperty("isChest"))
                object.isChest = message.isChest;
            if (message.itemType != null && message.hasOwnProperty("itemType"))
                object.itemType = message.itemType;
            return object;
        };

        /**
         * Converts this Item to JSON.
         * @function toJSON
         * @memberof NT.Item
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Item.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Item
         * @function getTypeUrl
         * @memberof NT.Item
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Item.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.Item";
        };

        Item.Color = (function() {

            /**
             * Properties of a Color.
             * @memberof NT.Item
             * @interface IColor
             * @property {number|null} [r] Color r
             * @property {number|null} [g] Color g
             * @property {number|null} [b] Color b
             */

            /**
             * Constructs a new Color.
             * @memberof NT.Item
             * @classdesc Represents a Color.
             * @implements IColor
             * @constructor
             * @param {NT.Item.IColor=} [properties] Properties to set
             */
            function Color(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Color r.
             * @member {number} r
             * @memberof NT.Item.Color
             * @instance
             */
            Color.prototype.r = 0;

            /**
             * Color g.
             * @member {number} g
             * @memberof NT.Item.Color
             * @instance
             */
            Color.prototype.g = 0;

            /**
             * Color b.
             * @member {number} b
             * @memberof NT.Item.Color
             * @instance
             */
            Color.prototype.b = 0;

            /**
             * Creates a new Color instance using the specified properties.
             * @function create
             * @memberof NT.Item.Color
             * @static
             * @param {NT.Item.IColor=} [properties] Properties to set
             * @returns {NT.Item.Color} Color instance
             */
            Color.create = function create(properties) {
                return new Color(properties);
            };

            /**
             * Encodes the specified Color message. Does not implicitly {@link NT.Item.Color.verify|verify} messages.
             * @function encode
             * @memberof NT.Item.Color
             * @static
             * @param {NT.Item.IColor} message Color message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Color.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.r != null && Object.hasOwnProperty.call(message, "r"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.r);
                if (message.g != null && Object.hasOwnProperty.call(message, "g"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.g);
                if (message.b != null && Object.hasOwnProperty.call(message, "b"))
                    writer.uint32(/* id 3, wireType 5 =*/29).float(message.b);
                return writer;
            };

            /**
             * Encodes the specified Color message, length delimited. Does not implicitly {@link NT.Item.Color.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.Item.Color
             * @static
             * @param {NT.Item.IColor} message Color message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Color.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Color message from the specified reader or buffer.
             * @function decode
             * @memberof NT.Item.Color
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.Item.Color} Color
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Color.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Item.Color();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.r = reader.float();
                            break;
                        }
                    case 2: {
                            message.g = reader.float();
                            break;
                        }
                    case 3: {
                            message.b = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Color message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.Item.Color
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.Item.Color} Color
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Color.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Color message.
             * @function verify
             * @memberof NT.Item.Color
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Color.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.r != null && message.hasOwnProperty("r"))
                    if (typeof message.r !== "number")
                        return "r: number expected";
                if (message.g != null && message.hasOwnProperty("g"))
                    if (typeof message.g !== "number")
                        return "g: number expected";
                if (message.b != null && message.hasOwnProperty("b"))
                    if (typeof message.b !== "number")
                        return "b: number expected";
                return null;
            };

            /**
             * Creates a Color message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.Item.Color
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.Item.Color} Color
             */
            Color.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.Item.Color)
                    return object;
                let message = new $root.NT.Item.Color();
                if (object.r != null)
                    message.r = Number(object.r);
                if (object.g != null)
                    message.g = Number(object.g);
                if (object.b != null)
                    message.b = Number(object.b);
                return message;
            };

            /**
             * Creates a plain object from a Color message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.Item.Color
             * @static
             * @param {NT.Item.Color} message Color
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Color.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.r = 0;
                    object.g = 0;
                    object.b = 0;
                }
                if (message.r != null && message.hasOwnProperty("r"))
                    object.r = options.json && !isFinite(message.r) ? String(message.r) : message.r;
                if (message.g != null && message.hasOwnProperty("g"))
                    object.g = options.json && !isFinite(message.g) ? String(message.g) : message.g;
                if (message.b != null && message.hasOwnProperty("b"))
                    object.b = options.json && !isFinite(message.b) ? String(message.b) : message.b;
                return object;
            };

            /**
             * Converts this Color to JSON.
             * @function toJSON
             * @memberof NT.Item.Color
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Color.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Color
             * @function getTypeUrl
             * @memberof NT.Item.Color
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Color.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.Item.Color";
            };

            return Color;
        })();

        Item.Material = (function() {

            /**
             * Properties of a Material.
             * @memberof NT.Item
             * @interface IMaterial
             * @property {number|null} [id] Material id
             * @property {number|null} [amount] Material amount
             */

            /**
             * Constructs a new Material.
             * @memberof NT.Item
             * @classdesc Represents a Material.
             * @implements IMaterial
             * @constructor
             * @param {NT.Item.IMaterial=} [properties] Properties to set
             */
            function Material(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Material id.
             * @member {number} id
             * @memberof NT.Item.Material
             * @instance
             */
            Material.prototype.id = 0;

            /**
             * Material amount.
             * @member {number} amount
             * @memberof NT.Item.Material
             * @instance
             */
            Material.prototype.amount = 0;

            /**
             * Creates a new Material instance using the specified properties.
             * @function create
             * @memberof NT.Item.Material
             * @static
             * @param {NT.Item.IMaterial=} [properties] Properties to set
             * @returns {NT.Item.Material} Material instance
             */
            Material.create = function create(properties) {
                return new Material(properties);
            };

            /**
             * Encodes the specified Material message. Does not implicitly {@link NT.Item.Material.verify|verify} messages.
             * @function encode
             * @memberof NT.Item.Material
             * @static
             * @param {NT.Item.IMaterial} message Material message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Material.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.id);
                if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.amount);
                return writer;
            };

            /**
             * Encodes the specified Material message, length delimited. Does not implicitly {@link NT.Item.Material.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.Item.Material
             * @static
             * @param {NT.Item.IMaterial} message Material message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Material.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Material message from the specified reader or buffer.
             * @function decode
             * @memberof NT.Item.Material
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.Item.Material} Material
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Material.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.Item.Material();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.amount = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Material message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.Item.Material
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.Item.Material} Material
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Material.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Material message.
             * @function verify
             * @memberof NT.Item.Material
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Material.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isInteger(message.id))
                        return "id: integer expected";
                if (message.amount != null && message.hasOwnProperty("amount"))
                    if (!$util.isInteger(message.amount))
                        return "amount: integer expected";
                return null;
            };

            /**
             * Creates a Material message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.Item.Material
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.Item.Material} Material
             */
            Material.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.Item.Material)
                    return object;
                let message = new $root.NT.Item.Material();
                if (object.id != null)
                    message.id = object.id >>> 0;
                if (object.amount != null)
                    message.amount = object.amount >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a Material message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.Item.Material
             * @static
             * @param {NT.Item.Material} message Material
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Material.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = 0;
                    object.amount = 0;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.amount != null && message.hasOwnProperty("amount"))
                    object.amount = message.amount;
                return object;
            };

            /**
             * Converts this Material to JSON.
             * @function toJSON
             * @memberof NT.Item.Material
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Material.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Material
             * @function getTypeUrl
             * @memberof NT.Item.Material
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Material.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.Item.Material";
            };

            return Material;
        })();

        return Item;
    })();

    NT.EntityItem = (function() {

        /**
         * Properties of an EntityItem.
         * @memberof NT
         * @interface IEntityItem
         * @property {string|null} [id] EntityItem id
         * @property {string|null} [path] EntityItem path
         * @property {string|null} [sprite] EntityItem sprite
         * @property {string|null} [sentBy] EntityItem sentBy
         */

        /**
         * Constructs a new EntityItem.
         * @memberof NT
         * @classdesc Represents an EntityItem.
         * @implements IEntityItem
         * @constructor
         * @param {NT.IEntityItem=} [properties] Properties to set
         */
        function EntityItem(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EntityItem id.
         * @member {string} id
         * @memberof NT.EntityItem
         * @instance
         */
        EntityItem.prototype.id = "";

        /**
         * EntityItem path.
         * @member {string} path
         * @memberof NT.EntityItem
         * @instance
         */
        EntityItem.prototype.path = "";

        /**
         * EntityItem sprite.
         * @member {string} sprite
         * @memberof NT.EntityItem
         * @instance
         */
        EntityItem.prototype.sprite = "";

        /**
         * EntityItem sentBy.
         * @member {string|null|undefined} sentBy
         * @memberof NT.EntityItem
         * @instance
         */
        EntityItem.prototype.sentBy = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * EntityItem _sentBy.
         * @member {"sentBy"|undefined} _sentBy
         * @memberof NT.EntityItem
         * @instance
         */
        Object.defineProperty(EntityItem.prototype, "_sentBy", {
            get: $util.oneOfGetter($oneOfFields = ["sentBy"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new EntityItem instance using the specified properties.
         * @function create
         * @memberof NT.EntityItem
         * @static
         * @param {NT.IEntityItem=} [properties] Properties to set
         * @returns {NT.EntityItem} EntityItem instance
         */
        EntityItem.create = function create(properties) {
            return new EntityItem(properties);
        };

        /**
         * Encodes the specified EntityItem message. Does not implicitly {@link NT.EntityItem.verify|verify} messages.
         * @function encode
         * @memberof NT.EntityItem
         * @static
         * @param {NT.IEntityItem} message EntityItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
            if (message.sprite != null && Object.hasOwnProperty.call(message, "sprite"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sprite);
            if (message.sentBy != null && Object.hasOwnProperty.call(message, "sentBy"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.sentBy);
            return writer;
        };

        /**
         * Encodes the specified EntityItem message, length delimited. Does not implicitly {@link NT.EntityItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.EntityItem
         * @static
         * @param {NT.IEntityItem} message EntityItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EntityItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EntityItem message from the specified reader or buffer.
         * @function decode
         * @memberof NT.EntityItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.EntityItem} EntityItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.EntityItem();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.path = reader.string();
                        break;
                    }
                case 3: {
                        message.sprite = reader.string();
                        break;
                    }
                case 4: {
                        message.sentBy = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EntityItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.EntityItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.EntityItem} EntityItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EntityItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EntityItem message.
         * @function verify
         * @memberof NT.EntityItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EntityItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.path != null && message.hasOwnProperty("path"))
                if (!$util.isString(message.path))
                    return "path: string expected";
            if (message.sprite != null && message.hasOwnProperty("sprite"))
                if (!$util.isString(message.sprite))
                    return "sprite: string expected";
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                properties._sentBy = 1;
                if (!$util.isString(message.sentBy))
                    return "sentBy: string expected";
            }
            return null;
        };

        /**
         * Creates an EntityItem message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.EntityItem
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.EntityItem} EntityItem
         */
        EntityItem.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.EntityItem)
                return object;
            let message = new $root.NT.EntityItem();
            if (object.id != null)
                message.id = String(object.id);
            if (object.path != null)
                message.path = String(object.path);
            if (object.sprite != null)
                message.sprite = String(object.sprite);
            if (object.sentBy != null)
                message.sentBy = String(object.sentBy);
            return message;
        };

        /**
         * Creates a plain object from an EntityItem message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.EntityItem
         * @static
         * @param {NT.EntityItem} message EntityItem
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EntityItem.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.id = "";
                object.path = "";
                object.sprite = "";
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.path != null && message.hasOwnProperty("path"))
                object.path = message.path;
            if (message.sprite != null && message.hasOwnProperty("sprite"))
                object.sprite = message.sprite;
            if (message.sentBy != null && message.hasOwnProperty("sentBy")) {
                object.sentBy = message.sentBy;
                if (options.oneofs)
                    object._sentBy = "sentBy";
            }
            return object;
        };

        /**
         * Converts this EntityItem to JSON.
         * @function toJSON
         * @memberof NT.EntityItem
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EntityItem.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EntityItem
         * @function getTypeUrl
         * @memberof NT.EntityItem
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EntityItem.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.EntityItem";
        };

        return EntityItem;
    })();

    NT.LobbyAction = (function() {

        /**
         * Properties of a LobbyAction.
         * @memberof NT
         * @interface ILobbyAction
         * @property {NT.IClientRoomCreate|null} [cRoomCreate] LobbyAction cRoomCreate
         * @property {NT.IServerRoomCreated|null} [sRoomCreated] LobbyAction sRoomCreated
         * @property {NT.IServerRoomCreateFailed|null} [sRoomCreateFailed] LobbyAction sRoomCreateFailed
         * @property {NT.IClientRoomUpdate|null} [cRoomUpdate] LobbyAction cRoomUpdate
         * @property {NT.IServerRoomUpdated|null} [sRoomUpdated] LobbyAction sRoomUpdated
         * @property {NT.IServerRoomUpdateFailed|null} [sRoomUpdateFailed] LobbyAction sRoomUpdateFailed
         * @property {NT.IClientRoomFlagsUpdate|null} [cRoomFlagsUpdate] LobbyAction cRoomFlagsUpdate
         * @property {NT.IServerRoomFlagsUpdated|null} [sRoomFlagsUpdated] LobbyAction sRoomFlagsUpdated
         * @property {NT.IServerRoomFlagsUpdateFailed|null} [sRoomFlagsUpdateFailed] LobbyAction sRoomFlagsUpdateFailed
         * @property {NT.IClientRoomDelete|null} [cRoomDelete] LobbyAction cRoomDelete
         * @property {NT.IServerRoomDeleted|null} [sRoomDeleted] LobbyAction sRoomDeleted
         * @property {NT.IClientJoinRoom|null} [cJoinRoom] LobbyAction cJoinRoom
         * @property {NT.IServerJoinRoomSuccess|null} [sJoinRoomSuccess] LobbyAction sJoinRoomSuccess
         * @property {NT.IServerJoinRoomFailed|null} [sJoinRoomFailed] LobbyAction sJoinRoomFailed
         * @property {NT.IServerUserJoinedRoom|null} [sUserJoinedRoom] LobbyAction sUserJoinedRoom
         * @property {NT.IClientLeaveRoom|null} [cLeaveRoom] LobbyAction cLeaveRoom
         * @property {NT.IServerUserLeftRoom|null} [sUserLeftRoom] LobbyAction sUserLeftRoom
         * @property {NT.IClientKickUser|null} [cKickUser] LobbyAction cKickUser
         * @property {NT.IServerUserKicked|null} [sUserKicked] LobbyAction sUserKicked
         * @property {NT.IClientBanUser|null} [cBanUser] LobbyAction cBanUser
         * @property {NT.IServerUserBanned|null} [sUserBanned] LobbyAction sUserBanned
         * @property {NT.IClientReadyState|null} [cReadyState] LobbyAction cReadyState
         * @property {NT.IServerUserReadyState|null} [sUserReadyState] LobbyAction sUserReadyState
         * @property {NT.IClientStartRun|null} [cStartRun] LobbyAction cStartRun
         * @property {NT.IServerHostStart|null} [sHostStart] LobbyAction sHostStart
         * @property {NT.IClientRequestRoomList|null} [cRequestRoomList] LobbyAction cRequestRoomList
         * @property {NT.IServerRoomList|null} [sRoomList] LobbyAction sRoomList
         * @property {NT.IServerDisconnected|null} [sDisconnected] LobbyAction sDisconnected
         * @property {NT.IServerRoomAddToList|null} [sRoomAddToList] LobbyAction sRoomAddToList
         * @property {NT.IClientRunOver|null} [cRunOver] LobbyAction cRunOver
         */

        /**
         * Constructs a new LobbyAction.
         * @memberof NT
         * @classdesc Represents a LobbyAction.
         * @implements ILobbyAction
         * @constructor
         * @param {NT.ILobbyAction=} [properties] Properties to set
         */
        function LobbyAction(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LobbyAction cRoomCreate.
         * @member {NT.IClientRoomCreate|null|undefined} cRoomCreate
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRoomCreate = null;

        /**
         * LobbyAction sRoomCreated.
         * @member {NT.IServerRoomCreated|null|undefined} sRoomCreated
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomCreated = null;

        /**
         * LobbyAction sRoomCreateFailed.
         * @member {NT.IServerRoomCreateFailed|null|undefined} sRoomCreateFailed
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomCreateFailed = null;

        /**
         * LobbyAction cRoomUpdate.
         * @member {NT.IClientRoomUpdate|null|undefined} cRoomUpdate
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRoomUpdate = null;

        /**
         * LobbyAction sRoomUpdated.
         * @member {NT.IServerRoomUpdated|null|undefined} sRoomUpdated
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomUpdated = null;

        /**
         * LobbyAction sRoomUpdateFailed.
         * @member {NT.IServerRoomUpdateFailed|null|undefined} sRoomUpdateFailed
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomUpdateFailed = null;

        /**
         * LobbyAction cRoomFlagsUpdate.
         * @member {NT.IClientRoomFlagsUpdate|null|undefined} cRoomFlagsUpdate
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRoomFlagsUpdate = null;

        /**
         * LobbyAction sRoomFlagsUpdated.
         * @member {NT.IServerRoomFlagsUpdated|null|undefined} sRoomFlagsUpdated
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomFlagsUpdated = null;

        /**
         * LobbyAction sRoomFlagsUpdateFailed.
         * @member {NT.IServerRoomFlagsUpdateFailed|null|undefined} sRoomFlagsUpdateFailed
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomFlagsUpdateFailed = null;

        /**
         * LobbyAction cRoomDelete.
         * @member {NT.IClientRoomDelete|null|undefined} cRoomDelete
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRoomDelete = null;

        /**
         * LobbyAction sRoomDeleted.
         * @member {NT.IServerRoomDeleted|null|undefined} sRoomDeleted
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomDeleted = null;

        /**
         * LobbyAction cJoinRoom.
         * @member {NT.IClientJoinRoom|null|undefined} cJoinRoom
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cJoinRoom = null;

        /**
         * LobbyAction sJoinRoomSuccess.
         * @member {NT.IServerJoinRoomSuccess|null|undefined} sJoinRoomSuccess
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sJoinRoomSuccess = null;

        /**
         * LobbyAction sJoinRoomFailed.
         * @member {NT.IServerJoinRoomFailed|null|undefined} sJoinRoomFailed
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sJoinRoomFailed = null;

        /**
         * LobbyAction sUserJoinedRoom.
         * @member {NT.IServerUserJoinedRoom|null|undefined} sUserJoinedRoom
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sUserJoinedRoom = null;

        /**
         * LobbyAction cLeaveRoom.
         * @member {NT.IClientLeaveRoom|null|undefined} cLeaveRoom
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cLeaveRoom = null;

        /**
         * LobbyAction sUserLeftRoom.
         * @member {NT.IServerUserLeftRoom|null|undefined} sUserLeftRoom
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sUserLeftRoom = null;

        /**
         * LobbyAction cKickUser.
         * @member {NT.IClientKickUser|null|undefined} cKickUser
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cKickUser = null;

        /**
         * LobbyAction sUserKicked.
         * @member {NT.IServerUserKicked|null|undefined} sUserKicked
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sUserKicked = null;

        /**
         * LobbyAction cBanUser.
         * @member {NT.IClientBanUser|null|undefined} cBanUser
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cBanUser = null;

        /**
         * LobbyAction sUserBanned.
         * @member {NT.IServerUserBanned|null|undefined} sUserBanned
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sUserBanned = null;

        /**
         * LobbyAction cReadyState.
         * @member {NT.IClientReadyState|null|undefined} cReadyState
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cReadyState = null;

        /**
         * LobbyAction sUserReadyState.
         * @member {NT.IServerUserReadyState|null|undefined} sUserReadyState
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sUserReadyState = null;

        /**
         * LobbyAction cStartRun.
         * @member {NT.IClientStartRun|null|undefined} cStartRun
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cStartRun = null;

        /**
         * LobbyAction sHostStart.
         * @member {NT.IServerHostStart|null|undefined} sHostStart
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sHostStart = null;

        /**
         * LobbyAction cRequestRoomList.
         * @member {NT.IClientRequestRoomList|null|undefined} cRequestRoomList
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRequestRoomList = null;

        /**
         * LobbyAction sRoomList.
         * @member {NT.IServerRoomList|null|undefined} sRoomList
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomList = null;

        /**
         * LobbyAction sDisconnected.
         * @member {NT.IServerDisconnected|null|undefined} sDisconnected
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sDisconnected = null;

        /**
         * LobbyAction sRoomAddToList.
         * @member {NT.IServerRoomAddToList|null|undefined} sRoomAddToList
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.sRoomAddToList = null;

        /**
         * LobbyAction cRunOver.
         * @member {NT.IClientRunOver|null|undefined} cRunOver
         * @memberof NT.LobbyAction
         * @instance
         */
        LobbyAction.prototype.cRunOver = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * LobbyAction action.
         * @member {"cRoomCreate"|"sRoomCreated"|"sRoomCreateFailed"|"cRoomUpdate"|"sRoomUpdated"|"sRoomUpdateFailed"|"cRoomFlagsUpdate"|"sRoomFlagsUpdated"|"sRoomFlagsUpdateFailed"|"cRoomDelete"|"sRoomDeleted"|"cJoinRoom"|"sJoinRoomSuccess"|"sJoinRoomFailed"|"sUserJoinedRoom"|"cLeaveRoom"|"sUserLeftRoom"|"cKickUser"|"sUserKicked"|"cBanUser"|"sUserBanned"|"cReadyState"|"sUserReadyState"|"cStartRun"|"sHostStart"|"cRequestRoomList"|"sRoomList"|"sDisconnected"|"sRoomAddToList"|"cRunOver"|undefined} action
         * @memberof NT.LobbyAction
         * @instance
         */
        Object.defineProperty(LobbyAction.prototype, "action", {
            get: $util.oneOfGetter($oneOfFields = ["cRoomCreate", "sRoomCreated", "sRoomCreateFailed", "cRoomUpdate", "sRoomUpdated", "sRoomUpdateFailed", "cRoomFlagsUpdate", "sRoomFlagsUpdated", "sRoomFlagsUpdateFailed", "cRoomDelete", "sRoomDeleted", "cJoinRoom", "sJoinRoomSuccess", "sJoinRoomFailed", "sUserJoinedRoom", "cLeaveRoom", "sUserLeftRoom", "cKickUser", "sUserKicked", "cBanUser", "sUserBanned", "cReadyState", "sUserReadyState", "cStartRun", "sHostStart", "cRequestRoomList", "sRoomList", "sDisconnected", "sRoomAddToList", "cRunOver"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new LobbyAction instance using the specified properties.
         * @function create
         * @memberof NT.LobbyAction
         * @static
         * @param {NT.ILobbyAction=} [properties] Properties to set
         * @returns {NT.LobbyAction} LobbyAction instance
         */
        LobbyAction.create = function create(properties) {
            return new LobbyAction(properties);
        };

        /**
         * Encodes the specified LobbyAction message. Does not implicitly {@link NT.LobbyAction.verify|verify} messages.
         * @function encode
         * @memberof NT.LobbyAction
         * @static
         * @param {NT.ILobbyAction} message LobbyAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LobbyAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cRoomCreate != null && Object.hasOwnProperty.call(message, "cRoomCreate"))
                $root.NT.ClientRoomCreate.encode(message.cRoomCreate, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.sRoomCreated != null && Object.hasOwnProperty.call(message, "sRoomCreated"))
                $root.NT.ServerRoomCreated.encode(message.sRoomCreated, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.sRoomCreateFailed != null && Object.hasOwnProperty.call(message, "sRoomCreateFailed"))
                $root.NT.ServerRoomCreateFailed.encode(message.sRoomCreateFailed, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.cRoomUpdate != null && Object.hasOwnProperty.call(message, "cRoomUpdate"))
                $root.NT.ClientRoomUpdate.encode(message.cRoomUpdate, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.sRoomUpdated != null && Object.hasOwnProperty.call(message, "sRoomUpdated"))
                $root.NT.ServerRoomUpdated.encode(message.sRoomUpdated, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.sRoomUpdateFailed != null && Object.hasOwnProperty.call(message, "sRoomUpdateFailed"))
                $root.NT.ServerRoomUpdateFailed.encode(message.sRoomUpdateFailed, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.cRoomFlagsUpdate != null && Object.hasOwnProperty.call(message, "cRoomFlagsUpdate"))
                $root.NT.ClientRoomFlagsUpdate.encode(message.cRoomFlagsUpdate, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.sRoomFlagsUpdated != null && Object.hasOwnProperty.call(message, "sRoomFlagsUpdated"))
                $root.NT.ServerRoomFlagsUpdated.encode(message.sRoomFlagsUpdated, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.sRoomFlagsUpdateFailed != null && Object.hasOwnProperty.call(message, "sRoomFlagsUpdateFailed"))
                $root.NT.ServerRoomFlagsUpdateFailed.encode(message.sRoomFlagsUpdateFailed, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.cRoomDelete != null && Object.hasOwnProperty.call(message, "cRoomDelete"))
                $root.NT.ClientRoomDelete.encode(message.cRoomDelete, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.sRoomDeleted != null && Object.hasOwnProperty.call(message, "sRoomDeleted"))
                $root.NT.ServerRoomDeleted.encode(message.sRoomDeleted, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.cJoinRoom != null && Object.hasOwnProperty.call(message, "cJoinRoom"))
                $root.NT.ClientJoinRoom.encode(message.cJoinRoom, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.sJoinRoomSuccess != null && Object.hasOwnProperty.call(message, "sJoinRoomSuccess"))
                $root.NT.ServerJoinRoomSuccess.encode(message.sJoinRoomSuccess, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.sJoinRoomFailed != null && Object.hasOwnProperty.call(message, "sJoinRoomFailed"))
                $root.NT.ServerJoinRoomFailed.encode(message.sJoinRoomFailed, writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.sUserJoinedRoom != null && Object.hasOwnProperty.call(message, "sUserJoinedRoom"))
                $root.NT.ServerUserJoinedRoom.encode(message.sUserJoinedRoom, writer.uint32(/* id 15, wireType 2 =*/122).fork()).ldelim();
            if (message.cLeaveRoom != null && Object.hasOwnProperty.call(message, "cLeaveRoom"))
                $root.NT.ClientLeaveRoom.encode(message.cLeaveRoom, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.sUserLeftRoom != null && Object.hasOwnProperty.call(message, "sUserLeftRoom"))
                $root.NT.ServerUserLeftRoom.encode(message.sUserLeftRoom, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.cKickUser != null && Object.hasOwnProperty.call(message, "cKickUser"))
                $root.NT.ClientKickUser.encode(message.cKickUser, writer.uint32(/* id 18, wireType 2 =*/146).fork()).ldelim();
            if (message.sUserKicked != null && Object.hasOwnProperty.call(message, "sUserKicked"))
                $root.NT.ServerUserKicked.encode(message.sUserKicked, writer.uint32(/* id 19, wireType 2 =*/154).fork()).ldelim();
            if (message.cBanUser != null && Object.hasOwnProperty.call(message, "cBanUser"))
                $root.NT.ClientBanUser.encode(message.cBanUser, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.sUserBanned != null && Object.hasOwnProperty.call(message, "sUserBanned"))
                $root.NT.ServerUserBanned.encode(message.sUserBanned, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
            if (message.cReadyState != null && Object.hasOwnProperty.call(message, "cReadyState"))
                $root.NT.ClientReadyState.encode(message.cReadyState, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.sUserReadyState != null && Object.hasOwnProperty.call(message, "sUserReadyState"))
                $root.NT.ServerUserReadyState.encode(message.sUserReadyState, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            if (message.cStartRun != null && Object.hasOwnProperty.call(message, "cStartRun"))
                $root.NT.ClientStartRun.encode(message.cStartRun, writer.uint32(/* id 24, wireType 2 =*/194).fork()).ldelim();
            if (message.sHostStart != null && Object.hasOwnProperty.call(message, "sHostStart"))
                $root.NT.ServerHostStart.encode(message.sHostStart, writer.uint32(/* id 25, wireType 2 =*/202).fork()).ldelim();
            if (message.cRequestRoomList != null && Object.hasOwnProperty.call(message, "cRequestRoomList"))
                $root.NT.ClientRequestRoomList.encode(message.cRequestRoomList, writer.uint32(/* id 27, wireType 2 =*/218).fork()).ldelim();
            if (message.sRoomList != null && Object.hasOwnProperty.call(message, "sRoomList"))
                $root.NT.ServerRoomList.encode(message.sRoomList, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.sDisconnected != null && Object.hasOwnProperty.call(message, "sDisconnected"))
                $root.NT.ServerDisconnected.encode(message.sDisconnected, writer.uint32(/* id 31, wireType 2 =*/250).fork()).ldelim();
            if (message.sRoomAddToList != null && Object.hasOwnProperty.call(message, "sRoomAddToList"))
                $root.NT.ServerRoomAddToList.encode(message.sRoomAddToList, writer.uint32(/* id 32, wireType 2 =*/258).fork()).ldelim();
            if (message.cRunOver != null && Object.hasOwnProperty.call(message, "cRunOver"))
                $root.NT.ClientRunOver.encode(message.cRunOver, writer.uint32(/* id 33, wireType 2 =*/266).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LobbyAction message, length delimited. Does not implicitly {@link NT.LobbyAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.LobbyAction
         * @static
         * @param {NT.ILobbyAction} message LobbyAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LobbyAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LobbyAction message from the specified reader or buffer.
         * @function decode
         * @memberof NT.LobbyAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.LobbyAction} LobbyAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LobbyAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.LobbyAction();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cRoomCreate = $root.NT.ClientRoomCreate.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.sRoomCreated = $root.NT.ServerRoomCreated.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.sRoomCreateFailed = $root.NT.ServerRoomCreateFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.cRoomUpdate = $root.NT.ClientRoomUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        message.sRoomUpdated = $root.NT.ServerRoomUpdated.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.sRoomUpdateFailed = $root.NT.ServerRoomUpdateFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 7: {
                        message.cRoomFlagsUpdate = $root.NT.ClientRoomFlagsUpdate.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.sRoomFlagsUpdated = $root.NT.ServerRoomFlagsUpdated.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.sRoomFlagsUpdateFailed = $root.NT.ServerRoomFlagsUpdateFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.cRoomDelete = $root.NT.ClientRoomDelete.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        message.sRoomDeleted = $root.NT.ServerRoomDeleted.decode(reader, reader.uint32());
                        break;
                    }
                case 12: {
                        message.cJoinRoom = $root.NT.ClientJoinRoom.decode(reader, reader.uint32());
                        break;
                    }
                case 13: {
                        message.sJoinRoomSuccess = $root.NT.ServerJoinRoomSuccess.decode(reader, reader.uint32());
                        break;
                    }
                case 14: {
                        message.sJoinRoomFailed = $root.NT.ServerJoinRoomFailed.decode(reader, reader.uint32());
                        break;
                    }
                case 15: {
                        message.sUserJoinedRoom = $root.NT.ServerUserJoinedRoom.decode(reader, reader.uint32());
                        break;
                    }
                case 16: {
                        message.cLeaveRoom = $root.NT.ClientLeaveRoom.decode(reader, reader.uint32());
                        break;
                    }
                case 17: {
                        message.sUserLeftRoom = $root.NT.ServerUserLeftRoom.decode(reader, reader.uint32());
                        break;
                    }
                case 18: {
                        message.cKickUser = $root.NT.ClientKickUser.decode(reader, reader.uint32());
                        break;
                    }
                case 19: {
                        message.sUserKicked = $root.NT.ServerUserKicked.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.cBanUser = $root.NT.ClientBanUser.decode(reader, reader.uint32());
                        break;
                    }
                case 21: {
                        message.sUserBanned = $root.NT.ServerUserBanned.decode(reader, reader.uint32());
                        break;
                    }
                case 22: {
                        message.cReadyState = $root.NT.ClientReadyState.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.sUserReadyState = $root.NT.ServerUserReadyState.decode(reader, reader.uint32());
                        break;
                    }
                case 24: {
                        message.cStartRun = $root.NT.ClientStartRun.decode(reader, reader.uint32());
                        break;
                    }
                case 25: {
                        message.sHostStart = $root.NT.ServerHostStart.decode(reader, reader.uint32());
                        break;
                    }
                case 27: {
                        message.cRequestRoomList = $root.NT.ClientRequestRoomList.decode(reader, reader.uint32());
                        break;
                    }
                case 28: {
                        message.sRoomList = $root.NT.ServerRoomList.decode(reader, reader.uint32());
                        break;
                    }
                case 31: {
                        message.sDisconnected = $root.NT.ServerDisconnected.decode(reader, reader.uint32());
                        break;
                    }
                case 32: {
                        message.sRoomAddToList = $root.NT.ServerRoomAddToList.decode(reader, reader.uint32());
                        break;
                    }
                case 33: {
                        message.cRunOver = $root.NT.ClientRunOver.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LobbyAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.LobbyAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.LobbyAction} LobbyAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LobbyAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LobbyAction message.
         * @function verify
         * @memberof NT.LobbyAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LobbyAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.cRoomCreate != null && message.hasOwnProperty("cRoomCreate")) {
                properties.action = 1;
                {
                    let error = $root.NT.ClientRoomCreate.verify(message.cRoomCreate);
                    if (error)
                        return "cRoomCreate." + error;
                }
            }
            if (message.sRoomCreated != null && message.hasOwnProperty("sRoomCreated")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomCreated.verify(message.sRoomCreated);
                    if (error)
                        return "sRoomCreated." + error;
                }
            }
            if (message.sRoomCreateFailed != null && message.hasOwnProperty("sRoomCreateFailed")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomCreateFailed.verify(message.sRoomCreateFailed);
                    if (error)
                        return "sRoomCreateFailed." + error;
                }
            }
            if (message.cRoomUpdate != null && message.hasOwnProperty("cRoomUpdate")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRoomUpdate.verify(message.cRoomUpdate);
                    if (error)
                        return "cRoomUpdate." + error;
                }
            }
            if (message.sRoomUpdated != null && message.hasOwnProperty("sRoomUpdated")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomUpdated.verify(message.sRoomUpdated);
                    if (error)
                        return "sRoomUpdated." + error;
                }
            }
            if (message.sRoomUpdateFailed != null && message.hasOwnProperty("sRoomUpdateFailed")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomUpdateFailed.verify(message.sRoomUpdateFailed);
                    if (error)
                        return "sRoomUpdateFailed." + error;
                }
            }
            if (message.cRoomFlagsUpdate != null && message.hasOwnProperty("cRoomFlagsUpdate")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRoomFlagsUpdate.verify(message.cRoomFlagsUpdate);
                    if (error)
                        return "cRoomFlagsUpdate." + error;
                }
            }
            if (message.sRoomFlagsUpdated != null && message.hasOwnProperty("sRoomFlagsUpdated")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomFlagsUpdated.verify(message.sRoomFlagsUpdated);
                    if (error)
                        return "sRoomFlagsUpdated." + error;
                }
            }
            if (message.sRoomFlagsUpdateFailed != null && message.hasOwnProperty("sRoomFlagsUpdateFailed")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomFlagsUpdateFailed.verify(message.sRoomFlagsUpdateFailed);
                    if (error)
                        return "sRoomFlagsUpdateFailed." + error;
                }
            }
            if (message.cRoomDelete != null && message.hasOwnProperty("cRoomDelete")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRoomDelete.verify(message.cRoomDelete);
                    if (error)
                        return "cRoomDelete." + error;
                }
            }
            if (message.sRoomDeleted != null && message.hasOwnProperty("sRoomDeleted")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomDeleted.verify(message.sRoomDeleted);
                    if (error)
                        return "sRoomDeleted." + error;
                }
            }
            if (message.cJoinRoom != null && message.hasOwnProperty("cJoinRoom")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientJoinRoom.verify(message.cJoinRoom);
                    if (error)
                        return "cJoinRoom." + error;
                }
            }
            if (message.sJoinRoomSuccess != null && message.hasOwnProperty("sJoinRoomSuccess")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerJoinRoomSuccess.verify(message.sJoinRoomSuccess);
                    if (error)
                        return "sJoinRoomSuccess." + error;
                }
            }
            if (message.sJoinRoomFailed != null && message.hasOwnProperty("sJoinRoomFailed")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerJoinRoomFailed.verify(message.sJoinRoomFailed);
                    if (error)
                        return "sJoinRoomFailed." + error;
                }
            }
            if (message.sUserJoinedRoom != null && message.hasOwnProperty("sUserJoinedRoom")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerUserJoinedRoom.verify(message.sUserJoinedRoom);
                    if (error)
                        return "sUserJoinedRoom." + error;
                }
            }
            if (message.cLeaveRoom != null && message.hasOwnProperty("cLeaveRoom")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientLeaveRoom.verify(message.cLeaveRoom);
                    if (error)
                        return "cLeaveRoom." + error;
                }
            }
            if (message.sUserLeftRoom != null && message.hasOwnProperty("sUserLeftRoom")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerUserLeftRoom.verify(message.sUserLeftRoom);
                    if (error)
                        return "sUserLeftRoom." + error;
                }
            }
            if (message.cKickUser != null && message.hasOwnProperty("cKickUser")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientKickUser.verify(message.cKickUser);
                    if (error)
                        return "cKickUser." + error;
                }
            }
            if (message.sUserKicked != null && message.hasOwnProperty("sUserKicked")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerUserKicked.verify(message.sUserKicked);
                    if (error)
                        return "sUserKicked." + error;
                }
            }
            if (message.cBanUser != null && message.hasOwnProperty("cBanUser")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientBanUser.verify(message.cBanUser);
                    if (error)
                        return "cBanUser." + error;
                }
            }
            if (message.sUserBanned != null && message.hasOwnProperty("sUserBanned")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerUserBanned.verify(message.sUserBanned);
                    if (error)
                        return "sUserBanned." + error;
                }
            }
            if (message.cReadyState != null && message.hasOwnProperty("cReadyState")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientReadyState.verify(message.cReadyState);
                    if (error)
                        return "cReadyState." + error;
                }
            }
            if (message.sUserReadyState != null && message.hasOwnProperty("sUserReadyState")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerUserReadyState.verify(message.sUserReadyState);
                    if (error)
                        return "sUserReadyState." + error;
                }
            }
            if (message.cStartRun != null && message.hasOwnProperty("cStartRun")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientStartRun.verify(message.cStartRun);
                    if (error)
                        return "cStartRun." + error;
                }
            }
            if (message.sHostStart != null && message.hasOwnProperty("sHostStart")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerHostStart.verify(message.sHostStart);
                    if (error)
                        return "sHostStart." + error;
                }
            }
            if (message.cRequestRoomList != null && message.hasOwnProperty("cRequestRoomList")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRequestRoomList.verify(message.cRequestRoomList);
                    if (error)
                        return "cRequestRoomList." + error;
                }
            }
            if (message.sRoomList != null && message.hasOwnProperty("sRoomList")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomList.verify(message.sRoomList);
                    if (error)
                        return "sRoomList." + error;
                }
            }
            if (message.sDisconnected != null && message.hasOwnProperty("sDisconnected")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerDisconnected.verify(message.sDisconnected);
                    if (error)
                        return "sDisconnected." + error;
                }
            }
            if (message.sRoomAddToList != null && message.hasOwnProperty("sRoomAddToList")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ServerRoomAddToList.verify(message.sRoomAddToList);
                    if (error)
                        return "sRoomAddToList." + error;
                }
            }
            if (message.cRunOver != null && message.hasOwnProperty("cRunOver")) {
                if (properties.action === 1)
                    return "action: multiple values";
                properties.action = 1;
                {
                    let error = $root.NT.ClientRunOver.verify(message.cRunOver);
                    if (error)
                        return "cRunOver." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LobbyAction message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.LobbyAction
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.LobbyAction} LobbyAction
         */
        LobbyAction.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.LobbyAction)
                return object;
            let message = new $root.NT.LobbyAction();
            if (object.cRoomCreate != null) {
                if (typeof object.cRoomCreate !== "object")
                    throw TypeError(".NT.LobbyAction.cRoomCreate: object expected");
                message.cRoomCreate = $root.NT.ClientRoomCreate.fromObject(object.cRoomCreate);
            }
            if (object.sRoomCreated != null) {
                if (typeof object.sRoomCreated !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomCreated: object expected");
                message.sRoomCreated = $root.NT.ServerRoomCreated.fromObject(object.sRoomCreated);
            }
            if (object.sRoomCreateFailed != null) {
                if (typeof object.sRoomCreateFailed !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomCreateFailed: object expected");
                message.sRoomCreateFailed = $root.NT.ServerRoomCreateFailed.fromObject(object.sRoomCreateFailed);
            }
            if (object.cRoomUpdate != null) {
                if (typeof object.cRoomUpdate !== "object")
                    throw TypeError(".NT.LobbyAction.cRoomUpdate: object expected");
                message.cRoomUpdate = $root.NT.ClientRoomUpdate.fromObject(object.cRoomUpdate);
            }
            if (object.sRoomUpdated != null) {
                if (typeof object.sRoomUpdated !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomUpdated: object expected");
                message.sRoomUpdated = $root.NT.ServerRoomUpdated.fromObject(object.sRoomUpdated);
            }
            if (object.sRoomUpdateFailed != null) {
                if (typeof object.sRoomUpdateFailed !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomUpdateFailed: object expected");
                message.sRoomUpdateFailed = $root.NT.ServerRoomUpdateFailed.fromObject(object.sRoomUpdateFailed);
            }
            if (object.cRoomFlagsUpdate != null) {
                if (typeof object.cRoomFlagsUpdate !== "object")
                    throw TypeError(".NT.LobbyAction.cRoomFlagsUpdate: object expected");
                message.cRoomFlagsUpdate = $root.NT.ClientRoomFlagsUpdate.fromObject(object.cRoomFlagsUpdate);
            }
            if (object.sRoomFlagsUpdated != null) {
                if (typeof object.sRoomFlagsUpdated !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomFlagsUpdated: object expected");
                message.sRoomFlagsUpdated = $root.NT.ServerRoomFlagsUpdated.fromObject(object.sRoomFlagsUpdated);
            }
            if (object.sRoomFlagsUpdateFailed != null) {
                if (typeof object.sRoomFlagsUpdateFailed !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomFlagsUpdateFailed: object expected");
                message.sRoomFlagsUpdateFailed = $root.NT.ServerRoomFlagsUpdateFailed.fromObject(object.sRoomFlagsUpdateFailed);
            }
            if (object.cRoomDelete != null) {
                if (typeof object.cRoomDelete !== "object")
                    throw TypeError(".NT.LobbyAction.cRoomDelete: object expected");
                message.cRoomDelete = $root.NT.ClientRoomDelete.fromObject(object.cRoomDelete);
            }
            if (object.sRoomDeleted != null) {
                if (typeof object.sRoomDeleted !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomDeleted: object expected");
                message.sRoomDeleted = $root.NT.ServerRoomDeleted.fromObject(object.sRoomDeleted);
            }
            if (object.cJoinRoom != null) {
                if (typeof object.cJoinRoom !== "object")
                    throw TypeError(".NT.LobbyAction.cJoinRoom: object expected");
                message.cJoinRoom = $root.NT.ClientJoinRoom.fromObject(object.cJoinRoom);
            }
            if (object.sJoinRoomSuccess != null) {
                if (typeof object.sJoinRoomSuccess !== "object")
                    throw TypeError(".NT.LobbyAction.sJoinRoomSuccess: object expected");
                message.sJoinRoomSuccess = $root.NT.ServerJoinRoomSuccess.fromObject(object.sJoinRoomSuccess);
            }
            if (object.sJoinRoomFailed != null) {
                if (typeof object.sJoinRoomFailed !== "object")
                    throw TypeError(".NT.LobbyAction.sJoinRoomFailed: object expected");
                message.sJoinRoomFailed = $root.NT.ServerJoinRoomFailed.fromObject(object.sJoinRoomFailed);
            }
            if (object.sUserJoinedRoom != null) {
                if (typeof object.sUserJoinedRoom !== "object")
                    throw TypeError(".NT.LobbyAction.sUserJoinedRoom: object expected");
                message.sUserJoinedRoom = $root.NT.ServerUserJoinedRoom.fromObject(object.sUserJoinedRoom);
            }
            if (object.cLeaveRoom != null) {
                if (typeof object.cLeaveRoom !== "object")
                    throw TypeError(".NT.LobbyAction.cLeaveRoom: object expected");
                message.cLeaveRoom = $root.NT.ClientLeaveRoom.fromObject(object.cLeaveRoom);
            }
            if (object.sUserLeftRoom != null) {
                if (typeof object.sUserLeftRoom !== "object")
                    throw TypeError(".NT.LobbyAction.sUserLeftRoom: object expected");
                message.sUserLeftRoom = $root.NT.ServerUserLeftRoom.fromObject(object.sUserLeftRoom);
            }
            if (object.cKickUser != null) {
                if (typeof object.cKickUser !== "object")
                    throw TypeError(".NT.LobbyAction.cKickUser: object expected");
                message.cKickUser = $root.NT.ClientKickUser.fromObject(object.cKickUser);
            }
            if (object.sUserKicked != null) {
                if (typeof object.sUserKicked !== "object")
                    throw TypeError(".NT.LobbyAction.sUserKicked: object expected");
                message.sUserKicked = $root.NT.ServerUserKicked.fromObject(object.sUserKicked);
            }
            if (object.cBanUser != null) {
                if (typeof object.cBanUser !== "object")
                    throw TypeError(".NT.LobbyAction.cBanUser: object expected");
                message.cBanUser = $root.NT.ClientBanUser.fromObject(object.cBanUser);
            }
            if (object.sUserBanned != null) {
                if (typeof object.sUserBanned !== "object")
                    throw TypeError(".NT.LobbyAction.sUserBanned: object expected");
                message.sUserBanned = $root.NT.ServerUserBanned.fromObject(object.sUserBanned);
            }
            if (object.cReadyState != null) {
                if (typeof object.cReadyState !== "object")
                    throw TypeError(".NT.LobbyAction.cReadyState: object expected");
                message.cReadyState = $root.NT.ClientReadyState.fromObject(object.cReadyState);
            }
            if (object.sUserReadyState != null) {
                if (typeof object.sUserReadyState !== "object")
                    throw TypeError(".NT.LobbyAction.sUserReadyState: object expected");
                message.sUserReadyState = $root.NT.ServerUserReadyState.fromObject(object.sUserReadyState);
            }
            if (object.cStartRun != null) {
                if (typeof object.cStartRun !== "object")
                    throw TypeError(".NT.LobbyAction.cStartRun: object expected");
                message.cStartRun = $root.NT.ClientStartRun.fromObject(object.cStartRun);
            }
            if (object.sHostStart != null) {
                if (typeof object.sHostStart !== "object")
                    throw TypeError(".NT.LobbyAction.sHostStart: object expected");
                message.sHostStart = $root.NT.ServerHostStart.fromObject(object.sHostStart);
            }
            if (object.cRequestRoomList != null) {
                if (typeof object.cRequestRoomList !== "object")
                    throw TypeError(".NT.LobbyAction.cRequestRoomList: object expected");
                message.cRequestRoomList = $root.NT.ClientRequestRoomList.fromObject(object.cRequestRoomList);
            }
            if (object.sRoomList != null) {
                if (typeof object.sRoomList !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomList: object expected");
                message.sRoomList = $root.NT.ServerRoomList.fromObject(object.sRoomList);
            }
            if (object.sDisconnected != null) {
                if (typeof object.sDisconnected !== "object")
                    throw TypeError(".NT.LobbyAction.sDisconnected: object expected");
                message.sDisconnected = $root.NT.ServerDisconnected.fromObject(object.sDisconnected);
            }
            if (object.sRoomAddToList != null) {
                if (typeof object.sRoomAddToList !== "object")
                    throw TypeError(".NT.LobbyAction.sRoomAddToList: object expected");
                message.sRoomAddToList = $root.NT.ServerRoomAddToList.fromObject(object.sRoomAddToList);
            }
            if (object.cRunOver != null) {
                if (typeof object.cRunOver !== "object")
                    throw TypeError(".NT.LobbyAction.cRunOver: object expected");
                message.cRunOver = $root.NT.ClientRunOver.fromObject(object.cRunOver);
            }
            return message;
        };

        /**
         * Creates a plain object from a LobbyAction message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.LobbyAction
         * @static
         * @param {NT.LobbyAction} message LobbyAction
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LobbyAction.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.cRoomCreate != null && message.hasOwnProperty("cRoomCreate")) {
                object.cRoomCreate = $root.NT.ClientRoomCreate.toObject(message.cRoomCreate, options);
                if (options.oneofs)
                    object.action = "cRoomCreate";
            }
            if (message.sRoomCreated != null && message.hasOwnProperty("sRoomCreated")) {
                object.sRoomCreated = $root.NT.ServerRoomCreated.toObject(message.sRoomCreated, options);
                if (options.oneofs)
                    object.action = "sRoomCreated";
            }
            if (message.sRoomCreateFailed != null && message.hasOwnProperty("sRoomCreateFailed")) {
                object.sRoomCreateFailed = $root.NT.ServerRoomCreateFailed.toObject(message.sRoomCreateFailed, options);
                if (options.oneofs)
                    object.action = "sRoomCreateFailed";
            }
            if (message.cRoomUpdate != null && message.hasOwnProperty("cRoomUpdate")) {
                object.cRoomUpdate = $root.NT.ClientRoomUpdate.toObject(message.cRoomUpdate, options);
                if (options.oneofs)
                    object.action = "cRoomUpdate";
            }
            if (message.sRoomUpdated != null && message.hasOwnProperty("sRoomUpdated")) {
                object.sRoomUpdated = $root.NT.ServerRoomUpdated.toObject(message.sRoomUpdated, options);
                if (options.oneofs)
                    object.action = "sRoomUpdated";
            }
            if (message.sRoomUpdateFailed != null && message.hasOwnProperty("sRoomUpdateFailed")) {
                object.sRoomUpdateFailed = $root.NT.ServerRoomUpdateFailed.toObject(message.sRoomUpdateFailed, options);
                if (options.oneofs)
                    object.action = "sRoomUpdateFailed";
            }
            if (message.cRoomFlagsUpdate != null && message.hasOwnProperty("cRoomFlagsUpdate")) {
                object.cRoomFlagsUpdate = $root.NT.ClientRoomFlagsUpdate.toObject(message.cRoomFlagsUpdate, options);
                if (options.oneofs)
                    object.action = "cRoomFlagsUpdate";
            }
            if (message.sRoomFlagsUpdated != null && message.hasOwnProperty("sRoomFlagsUpdated")) {
                object.sRoomFlagsUpdated = $root.NT.ServerRoomFlagsUpdated.toObject(message.sRoomFlagsUpdated, options);
                if (options.oneofs)
                    object.action = "sRoomFlagsUpdated";
            }
            if (message.sRoomFlagsUpdateFailed != null && message.hasOwnProperty("sRoomFlagsUpdateFailed")) {
                object.sRoomFlagsUpdateFailed = $root.NT.ServerRoomFlagsUpdateFailed.toObject(message.sRoomFlagsUpdateFailed, options);
                if (options.oneofs)
                    object.action = "sRoomFlagsUpdateFailed";
            }
            if (message.cRoomDelete != null && message.hasOwnProperty("cRoomDelete")) {
                object.cRoomDelete = $root.NT.ClientRoomDelete.toObject(message.cRoomDelete, options);
                if (options.oneofs)
                    object.action = "cRoomDelete";
            }
            if (message.sRoomDeleted != null && message.hasOwnProperty("sRoomDeleted")) {
                object.sRoomDeleted = $root.NT.ServerRoomDeleted.toObject(message.sRoomDeleted, options);
                if (options.oneofs)
                    object.action = "sRoomDeleted";
            }
            if (message.cJoinRoom != null && message.hasOwnProperty("cJoinRoom")) {
                object.cJoinRoom = $root.NT.ClientJoinRoom.toObject(message.cJoinRoom, options);
                if (options.oneofs)
                    object.action = "cJoinRoom";
            }
            if (message.sJoinRoomSuccess != null && message.hasOwnProperty("sJoinRoomSuccess")) {
                object.sJoinRoomSuccess = $root.NT.ServerJoinRoomSuccess.toObject(message.sJoinRoomSuccess, options);
                if (options.oneofs)
                    object.action = "sJoinRoomSuccess";
            }
            if (message.sJoinRoomFailed != null && message.hasOwnProperty("sJoinRoomFailed")) {
                object.sJoinRoomFailed = $root.NT.ServerJoinRoomFailed.toObject(message.sJoinRoomFailed, options);
                if (options.oneofs)
                    object.action = "sJoinRoomFailed";
            }
            if (message.sUserJoinedRoom != null && message.hasOwnProperty("sUserJoinedRoom")) {
                object.sUserJoinedRoom = $root.NT.ServerUserJoinedRoom.toObject(message.sUserJoinedRoom, options);
                if (options.oneofs)
                    object.action = "sUserJoinedRoom";
            }
            if (message.cLeaveRoom != null && message.hasOwnProperty("cLeaveRoom")) {
                object.cLeaveRoom = $root.NT.ClientLeaveRoom.toObject(message.cLeaveRoom, options);
                if (options.oneofs)
                    object.action = "cLeaveRoom";
            }
            if (message.sUserLeftRoom != null && message.hasOwnProperty("sUserLeftRoom")) {
                object.sUserLeftRoom = $root.NT.ServerUserLeftRoom.toObject(message.sUserLeftRoom, options);
                if (options.oneofs)
                    object.action = "sUserLeftRoom";
            }
            if (message.cKickUser != null && message.hasOwnProperty("cKickUser")) {
                object.cKickUser = $root.NT.ClientKickUser.toObject(message.cKickUser, options);
                if (options.oneofs)
                    object.action = "cKickUser";
            }
            if (message.sUserKicked != null && message.hasOwnProperty("sUserKicked")) {
                object.sUserKicked = $root.NT.ServerUserKicked.toObject(message.sUserKicked, options);
                if (options.oneofs)
                    object.action = "sUserKicked";
            }
            if (message.cBanUser != null && message.hasOwnProperty("cBanUser")) {
                object.cBanUser = $root.NT.ClientBanUser.toObject(message.cBanUser, options);
                if (options.oneofs)
                    object.action = "cBanUser";
            }
            if (message.sUserBanned != null && message.hasOwnProperty("sUserBanned")) {
                object.sUserBanned = $root.NT.ServerUserBanned.toObject(message.sUserBanned, options);
                if (options.oneofs)
                    object.action = "sUserBanned";
            }
            if (message.cReadyState != null && message.hasOwnProperty("cReadyState")) {
                object.cReadyState = $root.NT.ClientReadyState.toObject(message.cReadyState, options);
                if (options.oneofs)
                    object.action = "cReadyState";
            }
            if (message.sUserReadyState != null && message.hasOwnProperty("sUserReadyState")) {
                object.sUserReadyState = $root.NT.ServerUserReadyState.toObject(message.sUserReadyState, options);
                if (options.oneofs)
                    object.action = "sUserReadyState";
            }
            if (message.cStartRun != null && message.hasOwnProperty("cStartRun")) {
                object.cStartRun = $root.NT.ClientStartRun.toObject(message.cStartRun, options);
                if (options.oneofs)
                    object.action = "cStartRun";
            }
            if (message.sHostStart != null && message.hasOwnProperty("sHostStart")) {
                object.sHostStart = $root.NT.ServerHostStart.toObject(message.sHostStart, options);
                if (options.oneofs)
                    object.action = "sHostStart";
            }
            if (message.cRequestRoomList != null && message.hasOwnProperty("cRequestRoomList")) {
                object.cRequestRoomList = $root.NT.ClientRequestRoomList.toObject(message.cRequestRoomList, options);
                if (options.oneofs)
                    object.action = "cRequestRoomList";
            }
            if (message.sRoomList != null && message.hasOwnProperty("sRoomList")) {
                object.sRoomList = $root.NT.ServerRoomList.toObject(message.sRoomList, options);
                if (options.oneofs)
                    object.action = "sRoomList";
            }
            if (message.sDisconnected != null && message.hasOwnProperty("sDisconnected")) {
                object.sDisconnected = $root.NT.ServerDisconnected.toObject(message.sDisconnected, options);
                if (options.oneofs)
                    object.action = "sDisconnected";
            }
            if (message.sRoomAddToList != null && message.hasOwnProperty("sRoomAddToList")) {
                object.sRoomAddToList = $root.NT.ServerRoomAddToList.toObject(message.sRoomAddToList, options);
                if (options.oneofs)
                    object.action = "sRoomAddToList";
            }
            if (message.cRunOver != null && message.hasOwnProperty("cRunOver")) {
                object.cRunOver = $root.NT.ClientRunOver.toObject(message.cRunOver, options);
                if (options.oneofs)
                    object.action = "cRunOver";
            }
            return object;
        };

        /**
         * Converts this LobbyAction to JSON.
         * @function toJSON
         * @memberof NT.LobbyAction
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LobbyAction.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LobbyAction
         * @function getTypeUrl
         * @memberof NT.LobbyAction
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LobbyAction.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.LobbyAction";
        };

        return LobbyAction;
    })();

    NT.ClientRunOver = (function() {

        /**
         * Properties of a ClientRunOver.
         * @memberof NT
         * @interface IClientRunOver
         * @property {boolean|null} [idk] ClientRunOver idk
         */

        /**
         * Constructs a new ClientRunOver.
         * @memberof NT
         * @classdesc Represents a ClientRunOver.
         * @implements IClientRunOver
         * @constructor
         * @param {NT.IClientRunOver=} [properties] Properties to set
         */
        function ClientRunOver(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRunOver idk.
         * @member {boolean|null|undefined} idk
         * @memberof NT.ClientRunOver
         * @instance
         */
        ClientRunOver.prototype.idk = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientRunOver _idk.
         * @member {"idk"|undefined} _idk
         * @memberof NT.ClientRunOver
         * @instance
         */
        Object.defineProperty(ClientRunOver.prototype, "_idk", {
            get: $util.oneOfGetter($oneOfFields = ["idk"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientRunOver instance using the specified properties.
         * @function create
         * @memberof NT.ClientRunOver
         * @static
         * @param {NT.IClientRunOver=} [properties] Properties to set
         * @returns {NT.ClientRunOver} ClientRunOver instance
         */
        ClientRunOver.create = function create(properties) {
            return new ClientRunOver(properties);
        };

        /**
         * Encodes the specified ClientRunOver message. Does not implicitly {@link NT.ClientRunOver.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRunOver
         * @static
         * @param {NT.IClientRunOver} message ClientRunOver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRunOver.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idk != null && Object.hasOwnProperty.call(message, "idk"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.idk);
            return writer;
        };

        /**
         * Encodes the specified ClientRunOver message, length delimited. Does not implicitly {@link NT.ClientRunOver.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRunOver
         * @static
         * @param {NT.IClientRunOver} message ClientRunOver message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRunOver.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRunOver message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRunOver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRunOver} ClientRunOver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRunOver.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRunOver();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idk = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRunOver message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRunOver
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRunOver} ClientRunOver
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRunOver.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRunOver message.
         * @function verify
         * @memberof NT.ClientRunOver
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRunOver.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.idk != null && message.hasOwnProperty("idk")) {
                properties._idk = 1;
                if (typeof message.idk !== "boolean")
                    return "idk: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ClientRunOver message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRunOver
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRunOver} ClientRunOver
         */
        ClientRunOver.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRunOver)
                return object;
            let message = new $root.NT.ClientRunOver();
            if (object.idk != null)
                message.idk = Boolean(object.idk);
            return message;
        };

        /**
         * Creates a plain object from a ClientRunOver message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRunOver
         * @static
         * @param {NT.ClientRunOver} message ClientRunOver
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRunOver.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.idk != null && message.hasOwnProperty("idk")) {
                object.idk = message.idk;
                if (options.oneofs)
                    object._idk = "idk";
            }
            return object;
        };

        /**
         * Converts this ClientRunOver to JSON.
         * @function toJSON
         * @memberof NT.ClientRunOver
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRunOver.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRunOver
         * @function getTypeUrl
         * @memberof NT.ClientRunOver
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRunOver.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRunOver";
        };

        return ClientRunOver;
    })();

    NT.ServerDisconnected = (function() {

        /**
         * Properties of a ServerDisconnected.
         * @memberof NT
         * @interface IServerDisconnected
         * @property {string|null} [reason] ServerDisconnected reason
         */

        /**
         * Constructs a new ServerDisconnected.
         * @memberof NT
         * @classdesc Represents a ServerDisconnected.
         * @implements IServerDisconnected
         * @constructor
         * @param {NT.IServerDisconnected=} [properties] Properties to set
         */
        function ServerDisconnected(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerDisconnected reason.
         * @member {string} reason
         * @memberof NT.ServerDisconnected
         * @instance
         */
        ServerDisconnected.prototype.reason = "";

        /**
         * Creates a new ServerDisconnected instance using the specified properties.
         * @function create
         * @memberof NT.ServerDisconnected
         * @static
         * @param {NT.IServerDisconnected=} [properties] Properties to set
         * @returns {NT.ServerDisconnected} ServerDisconnected instance
         */
        ServerDisconnected.create = function create(properties) {
            return new ServerDisconnected(properties);
        };

        /**
         * Encodes the specified ServerDisconnected message. Does not implicitly {@link NT.ServerDisconnected.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerDisconnected
         * @static
         * @param {NT.IServerDisconnected} message ServerDisconnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerDisconnected.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ServerDisconnected message, length delimited. Does not implicitly {@link NT.ServerDisconnected.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerDisconnected
         * @static
         * @param {NT.IServerDisconnected} message ServerDisconnected message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerDisconnected.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerDisconnected message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerDisconnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerDisconnected} ServerDisconnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerDisconnected.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerDisconnected();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerDisconnected message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerDisconnected
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerDisconnected} ServerDisconnected
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerDisconnected.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerDisconnected message.
         * @function verify
         * @memberof NT.ServerDisconnected
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerDisconnected.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ServerDisconnected message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerDisconnected
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerDisconnected} ServerDisconnected
         */
        ServerDisconnected.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerDisconnected)
                return object;
            let message = new $root.NT.ServerDisconnected();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ServerDisconnected message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerDisconnected
         * @static
         * @param {NT.ServerDisconnected} message ServerDisconnected
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerDisconnected.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ServerDisconnected to JSON.
         * @function toJSON
         * @memberof NT.ServerDisconnected
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerDisconnected.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerDisconnected
         * @function getTypeUrl
         * @memberof NT.ServerDisconnected
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerDisconnected.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerDisconnected";
        };

        return ServerDisconnected;
    })();

    NT.ClientRoomDelete = (function() {

        /**
         * Properties of a ClientRoomDelete.
         * @memberof NT
         * @interface IClientRoomDelete
         * @property {string|null} [id] ClientRoomDelete id
         */

        /**
         * Constructs a new ClientRoomDelete.
         * @memberof NT
         * @classdesc Represents a ClientRoomDelete.
         * @implements IClientRoomDelete
         * @constructor
         * @param {NT.IClientRoomDelete=} [properties] Properties to set
         */
        function ClientRoomDelete(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRoomDelete id.
         * @member {string} id
         * @memberof NT.ClientRoomDelete
         * @instance
         */
        ClientRoomDelete.prototype.id = "";

        /**
         * Creates a new ClientRoomDelete instance using the specified properties.
         * @function create
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {NT.IClientRoomDelete=} [properties] Properties to set
         * @returns {NT.ClientRoomDelete} ClientRoomDelete instance
         */
        ClientRoomDelete.create = function create(properties) {
            return new ClientRoomDelete(properties);
        };

        /**
         * Encodes the specified ClientRoomDelete message. Does not implicitly {@link NT.ClientRoomDelete.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {NT.IClientRoomDelete} message ClientRoomDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomDelete.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ClientRoomDelete message, length delimited. Does not implicitly {@link NT.ClientRoomDelete.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {NT.IClientRoomDelete} message ClientRoomDelete message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomDelete.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRoomDelete message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRoomDelete} ClientRoomDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomDelete.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRoomDelete();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRoomDelete message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRoomDelete} ClientRoomDelete
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomDelete.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRoomDelete message.
         * @function verify
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRoomDelete.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ClientRoomDelete message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRoomDelete} ClientRoomDelete
         */
        ClientRoomDelete.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRoomDelete)
                return object;
            let message = new $root.NT.ClientRoomDelete();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ClientRoomDelete message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {NT.ClientRoomDelete} message ClientRoomDelete
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRoomDelete.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ClientRoomDelete to JSON.
         * @function toJSON
         * @memberof NT.ClientRoomDelete
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRoomDelete.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRoomDelete
         * @function getTypeUrl
         * @memberof NT.ClientRoomDelete
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRoomDelete.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRoomDelete";
        };

        return ClientRoomDelete;
    })();

    NT.ServerRoomDeleted = (function() {

        /**
         * Properties of a ServerRoomDeleted.
         * @memberof NT
         * @interface IServerRoomDeleted
         * @property {string|null} [id] ServerRoomDeleted id
         */

        /**
         * Constructs a new ServerRoomDeleted.
         * @memberof NT
         * @classdesc Represents a ServerRoomDeleted.
         * @implements IServerRoomDeleted
         * @constructor
         * @param {NT.IServerRoomDeleted=} [properties] Properties to set
         */
        function ServerRoomDeleted(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomDeleted id.
         * @member {string} id
         * @memberof NT.ServerRoomDeleted
         * @instance
         */
        ServerRoomDeleted.prototype.id = "";

        /**
         * Creates a new ServerRoomDeleted instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {NT.IServerRoomDeleted=} [properties] Properties to set
         * @returns {NT.ServerRoomDeleted} ServerRoomDeleted instance
         */
        ServerRoomDeleted.create = function create(properties) {
            return new ServerRoomDeleted(properties);
        };

        /**
         * Encodes the specified ServerRoomDeleted message. Does not implicitly {@link NT.ServerRoomDeleted.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {NT.IServerRoomDeleted} message ServerRoomDeleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomDeleted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomDeleted message, length delimited. Does not implicitly {@link NT.ServerRoomDeleted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {NT.IServerRoomDeleted} message ServerRoomDeleted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomDeleted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomDeleted message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomDeleted} ServerRoomDeleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomDeleted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomDeleted();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomDeleted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomDeleted} ServerRoomDeleted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomDeleted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomDeleted message.
         * @function verify
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomDeleted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        /**
         * Creates a ServerRoomDeleted message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomDeleted} ServerRoomDeleted
         */
        ServerRoomDeleted.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomDeleted)
                return object;
            let message = new $root.NT.ServerRoomDeleted();
            if (object.id != null)
                message.id = String(object.id);
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomDeleted message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {NT.ServerRoomDeleted} message ServerRoomDeleted
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomDeleted.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            return object;
        };

        /**
         * Converts this ServerRoomDeleted to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomDeleted
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomDeleted.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomDeleted
         * @function getTypeUrl
         * @memberof NT.ServerRoomDeleted
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomDeleted.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomDeleted";
        };

        return ServerRoomDeleted;
    })();

    NT.ClientRoomCreate = (function() {

        /**
         * Properties of a ClientRoomCreate.
         * @memberof NT
         * @interface IClientRoomCreate
         * @property {string|null} [name] ClientRoomCreate name
         * @property {number|null} [gamemode] ClientRoomCreate gamemode
         * @property {number|null} [maxUsers] ClientRoomCreate maxUsers
         * @property {string|null} [password] ClientRoomCreate password
         */

        /**
         * Constructs a new ClientRoomCreate.
         * @memberof NT
         * @classdesc Represents a ClientRoomCreate.
         * @implements IClientRoomCreate
         * @constructor
         * @param {NT.IClientRoomCreate=} [properties] Properties to set
         */
        function ClientRoomCreate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRoomCreate name.
         * @member {string} name
         * @memberof NT.ClientRoomCreate
         * @instance
         */
        ClientRoomCreate.prototype.name = "";

        /**
         * ClientRoomCreate gamemode.
         * @member {number} gamemode
         * @memberof NT.ClientRoomCreate
         * @instance
         */
        ClientRoomCreate.prototype.gamemode = 0;

        /**
         * ClientRoomCreate maxUsers.
         * @member {number} maxUsers
         * @memberof NT.ClientRoomCreate
         * @instance
         */
        ClientRoomCreate.prototype.maxUsers = 0;

        /**
         * ClientRoomCreate password.
         * @member {string|null|undefined} password
         * @memberof NT.ClientRoomCreate
         * @instance
         */
        ClientRoomCreate.prototype.password = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientRoomCreate _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ClientRoomCreate
         * @instance
         */
        Object.defineProperty(ClientRoomCreate.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientRoomCreate instance using the specified properties.
         * @function create
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {NT.IClientRoomCreate=} [properties] Properties to set
         * @returns {NT.ClientRoomCreate} ClientRoomCreate instance
         */
        ClientRoomCreate.create = function create(properties) {
            return new ClientRoomCreate(properties);
        };

        /**
         * Encodes the specified ClientRoomCreate message. Does not implicitly {@link NT.ClientRoomCreate.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {NT.IClientRoomCreate} message ClientRoomCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomCreate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gamemode);
            if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxUsers);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified ClientRoomCreate message, length delimited. Does not implicitly {@link NT.ClientRoomCreate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {NT.IClientRoomCreate} message ClientRoomCreate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomCreate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRoomCreate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRoomCreate} ClientRoomCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomCreate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRoomCreate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gamemode = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxUsers = reader.uint32();
                        break;
                    }
                case 4: {
                        message.password = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRoomCreate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRoomCreate} ClientRoomCreate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomCreate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRoomCreate message.
         * @function verify
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRoomCreate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isInteger(message.gamemode))
                    return "gamemode: integer expected";
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                if (!$util.isInteger(message.maxUsers))
                    return "maxUsers: integer expected";
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            return null;
        };

        /**
         * Creates a ClientRoomCreate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRoomCreate} ClientRoomCreate
         */
        ClientRoomCreate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRoomCreate)
                return object;
            let message = new $root.NT.ClientRoomCreate();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gamemode != null)
                message.gamemode = object.gamemode >>> 0;
            if (object.maxUsers != null)
                message.maxUsers = object.maxUsers >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a ClientRoomCreate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {NT.ClientRoomCreate} message ClientRoomCreate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRoomCreate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.name = "";
                object.gamemode = 0;
                object.maxUsers = 0;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                object.maxUsers = message.maxUsers;
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            return object;
        };

        /**
         * Converts this ClientRoomCreate to JSON.
         * @function toJSON
         * @memberof NT.ClientRoomCreate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRoomCreate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRoomCreate
         * @function getTypeUrl
         * @memberof NT.ClientRoomCreate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRoomCreate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRoomCreate";
        };

        return ClientRoomCreate;
    })();

    NT.ServerRoomCreated = (function() {

        /**
         * Properties of a ServerRoomCreated.
         * @memberof NT
         * @interface IServerRoomCreated
         * @property {string|null} [id] ServerRoomCreated id
         * @property {string|null} [name] ServerRoomCreated name
         * @property {number|null} [gamemode] ServerRoomCreated gamemode
         * @property {number|null} [maxUsers] ServerRoomCreated maxUsers
         * @property {string|null} [password] ServerRoomCreated password
         * @property {boolean|null} [locked] ServerRoomCreated locked
         * @property {Array.<NT.ServerRoomCreated.IUser>|null} [users] ServerRoomCreated users
         */

        /**
         * Constructs a new ServerRoomCreated.
         * @memberof NT
         * @classdesc Represents a ServerRoomCreated.
         * @implements IServerRoomCreated
         * @constructor
         * @param {NT.IServerRoomCreated=} [properties] Properties to set
         */
        function ServerRoomCreated(properties) {
            this.users = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomCreated id.
         * @member {string} id
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.id = "";

        /**
         * ServerRoomCreated name.
         * @member {string} name
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.name = "";

        /**
         * ServerRoomCreated gamemode.
         * @member {number} gamemode
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.gamemode = 0;

        /**
         * ServerRoomCreated maxUsers.
         * @member {number} maxUsers
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.maxUsers = 0;

        /**
         * ServerRoomCreated password.
         * @member {string|null|undefined} password
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.password = null;

        /**
         * ServerRoomCreated locked.
         * @member {boolean} locked
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.locked = false;

        /**
         * ServerRoomCreated users.
         * @member {Array.<NT.ServerRoomCreated.IUser>} users
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        ServerRoomCreated.prototype.users = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerRoomCreated _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ServerRoomCreated
         * @instance
         */
        Object.defineProperty(ServerRoomCreated.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerRoomCreated instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {NT.IServerRoomCreated=} [properties] Properties to set
         * @returns {NT.ServerRoomCreated} ServerRoomCreated instance
         */
        ServerRoomCreated.create = function create(properties) {
            return new ServerRoomCreated(properties);
        };

        /**
         * Encodes the specified ServerRoomCreated message. Does not implicitly {@link NT.ServerRoomCreated.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {NT.IServerRoomCreated} message ServerRoomCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomCreated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gamemode);
            if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maxUsers);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.locked);
            if (message.users != null && message.users.length)
                for (let i = 0; i < message.users.length; ++i)
                    $root.NT.ServerRoomCreated.User.encode(message.users[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerRoomCreated message, length delimited. Does not implicitly {@link NT.ServerRoomCreated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {NT.IServerRoomCreated} message ServerRoomCreated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomCreated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomCreated message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomCreated} ServerRoomCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomCreated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomCreated();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.gamemode = reader.uint32();
                        break;
                    }
                case 4: {
                        message.maxUsers = reader.uint32();
                        break;
                    }
                case 5: {
                        message.password = reader.string();
                        break;
                    }
                case 6: {
                        message.locked = reader.bool();
                        break;
                    }
                case 7: {
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push($root.NT.ServerRoomCreated.User.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomCreated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomCreated} ServerRoomCreated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomCreated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomCreated message.
         * @function verify
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomCreated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isInteger(message.gamemode))
                    return "gamemode: integer expected";
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                if (!$util.isInteger(message.maxUsers))
                    return "maxUsers: integer expected";
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            if (message.locked != null && message.hasOwnProperty("locked"))
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (let i = 0; i < message.users.length; ++i) {
                    let error = $root.NT.ServerRoomCreated.User.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerRoomCreated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomCreated} ServerRoomCreated
         */
        ServerRoomCreated.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomCreated)
                return object;
            let message = new $root.NT.ServerRoomCreated();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.gamemode != null)
                message.gamemode = object.gamemode >>> 0;
            if (object.maxUsers != null)
                message.maxUsers = object.maxUsers >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".NT.ServerRoomCreated.users: array expected");
                message.users = [];
                for (let i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".NT.ServerRoomCreated.users: object expected");
                    message.users[i] = $root.NT.ServerRoomCreated.User.fromObject(object.users[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomCreated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {NT.ServerRoomCreated} message ServerRoomCreated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomCreated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.users = [];
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.gamemode = 0;
                object.maxUsers = 0;
                object.locked = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                object.maxUsers = message.maxUsers;
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            if (message.locked != null && message.hasOwnProperty("locked"))
                object.locked = message.locked;
            if (message.users && message.users.length) {
                object.users = [];
                for (let j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.NT.ServerRoomCreated.User.toObject(message.users[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerRoomCreated to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomCreated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomCreated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomCreated
         * @function getTypeUrl
         * @memberof NT.ServerRoomCreated
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomCreated.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomCreated";
        };

        ServerRoomCreated.User = (function() {

            /**
             * Properties of a User.
             * @memberof NT.ServerRoomCreated
             * @interface IUser
             * @property {string|null} [userId] User userId
             * @property {string|null} [name] User name
             * @property {boolean|null} [ready] User ready
             * @property {boolean|null} [owner] User owner
             */

            /**
             * Constructs a new User.
             * @memberof NT.ServerRoomCreated
             * @classdesc Represents a User.
             * @implements IUser
             * @constructor
             * @param {NT.ServerRoomCreated.IUser=} [properties] Properties to set
             */
            function User(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * User userId.
             * @member {string} userId
             * @memberof NT.ServerRoomCreated.User
             * @instance
             */
            User.prototype.userId = "";

            /**
             * User name.
             * @member {string} name
             * @memberof NT.ServerRoomCreated.User
             * @instance
             */
            User.prototype.name = "";

            /**
             * User ready.
             * @member {boolean} ready
             * @memberof NT.ServerRoomCreated.User
             * @instance
             */
            User.prototype.ready = false;

            /**
             * User owner.
             * @member {boolean} owner
             * @memberof NT.ServerRoomCreated.User
             * @instance
             */
            User.prototype.owner = false;

            /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {NT.ServerRoomCreated.IUser=} [properties] Properties to set
             * @returns {NT.ServerRoomCreated.User} User instance
             */
            User.create = function create(properties) {
                return new User(properties);
            };

            /**
             * Encodes the specified User message. Does not implicitly {@link NT.ServerRoomCreated.User.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {NT.ServerRoomCreated.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ready);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.owner);
                return writer;
            };

            /**
             * Encodes the specified User message, length delimited. Does not implicitly {@link NT.ServerRoomCreated.User.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {NT.ServerRoomCreated.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerRoomCreated.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomCreated.User();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userId = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.ready = reader.bool();
                            break;
                        }
                    case 4: {
                            message.owner = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a User message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerRoomCreated.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a User message.
             * @function verify
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            User.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.ready != null && message.hasOwnProperty("ready"))
                    if (typeof message.ready !== "boolean")
                        return "ready: boolean expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner !== "boolean")
                        return "owner: boolean expected";
                return null;
            };

            /**
             * Creates a User message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerRoomCreated.User} User
             */
            User.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerRoomCreated.User)
                    return object;
                let message = new $root.NT.ServerRoomCreated.User();
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.ready != null)
                    message.ready = Boolean(object.ready);
                if (object.owner != null)
                    message.owner = Boolean(object.owner);
                return message;
            };

            /**
             * Creates a plain object from a User message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {NT.ServerRoomCreated.User} message User
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            User.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.userId = "";
                    object.name = "";
                    object.ready = false;
                    object.owner = false;
                }
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.ready != null && message.hasOwnProperty("ready"))
                    object.ready = message.ready;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                return object;
            };

            /**
             * Converts this User to JSON.
             * @function toJSON
             * @memberof NT.ServerRoomCreated.User
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            User.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for User
             * @function getTypeUrl
             * @memberof NT.ServerRoomCreated.User
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerRoomCreated.User";
            };

            return User;
        })();

        return ServerRoomCreated;
    })();

    NT.ServerRoomCreateFailed = (function() {

        /**
         * Properties of a ServerRoomCreateFailed.
         * @memberof NT
         * @interface IServerRoomCreateFailed
         * @property {string|null} [reason] ServerRoomCreateFailed reason
         */

        /**
         * Constructs a new ServerRoomCreateFailed.
         * @memberof NT
         * @classdesc Represents a ServerRoomCreateFailed.
         * @implements IServerRoomCreateFailed
         * @constructor
         * @param {NT.IServerRoomCreateFailed=} [properties] Properties to set
         */
        function ServerRoomCreateFailed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomCreateFailed reason.
         * @member {string} reason
         * @memberof NT.ServerRoomCreateFailed
         * @instance
         */
        ServerRoomCreateFailed.prototype.reason = "";

        /**
         * Creates a new ServerRoomCreateFailed instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {NT.IServerRoomCreateFailed=} [properties] Properties to set
         * @returns {NT.ServerRoomCreateFailed} ServerRoomCreateFailed instance
         */
        ServerRoomCreateFailed.create = function create(properties) {
            return new ServerRoomCreateFailed(properties);
        };

        /**
         * Encodes the specified ServerRoomCreateFailed message. Does not implicitly {@link NT.ServerRoomCreateFailed.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {NT.IServerRoomCreateFailed} message ServerRoomCreateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomCreateFailed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomCreateFailed message, length delimited. Does not implicitly {@link NT.ServerRoomCreateFailed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {NT.IServerRoomCreateFailed} message ServerRoomCreateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomCreateFailed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomCreateFailed message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomCreateFailed} ServerRoomCreateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomCreateFailed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomCreateFailed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomCreateFailed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomCreateFailed} ServerRoomCreateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomCreateFailed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomCreateFailed message.
         * @function verify
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomCreateFailed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ServerRoomCreateFailed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomCreateFailed} ServerRoomCreateFailed
         */
        ServerRoomCreateFailed.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomCreateFailed)
                return object;
            let message = new $root.NT.ServerRoomCreateFailed();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomCreateFailed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {NT.ServerRoomCreateFailed} message ServerRoomCreateFailed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomCreateFailed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ServerRoomCreateFailed to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomCreateFailed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomCreateFailed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomCreateFailed
         * @function getTypeUrl
         * @memberof NT.ServerRoomCreateFailed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomCreateFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomCreateFailed";
        };

        return ServerRoomCreateFailed;
    })();

    NT.ClientRoomUpdate = (function() {

        /**
         * Properties of a ClientRoomUpdate.
         * @memberof NT
         * @interface IClientRoomUpdate
         * @property {string|null} [name] ClientRoomUpdate name
         * @property {number|null} [gamemode] ClientRoomUpdate gamemode
         * @property {number|null} [maxUsers] ClientRoomUpdate maxUsers
         * @property {string|null} [password] ClientRoomUpdate password
         * @property {boolean|null} [locked] ClientRoomUpdate locked
         */

        /**
         * Constructs a new ClientRoomUpdate.
         * @memberof NT
         * @classdesc Represents a ClientRoomUpdate.
         * @implements IClientRoomUpdate
         * @constructor
         * @param {NT.IClientRoomUpdate=} [properties] Properties to set
         */
        function ClientRoomUpdate(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRoomUpdate name.
         * @member {string|null|undefined} name
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        ClientRoomUpdate.prototype.name = null;

        /**
         * ClientRoomUpdate gamemode.
         * @member {number|null|undefined} gamemode
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        ClientRoomUpdate.prototype.gamemode = null;

        /**
         * ClientRoomUpdate maxUsers.
         * @member {number|null|undefined} maxUsers
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        ClientRoomUpdate.prototype.maxUsers = null;

        /**
         * ClientRoomUpdate password.
         * @member {string|null|undefined} password
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        ClientRoomUpdate.prototype.password = null;

        /**
         * ClientRoomUpdate locked.
         * @member {boolean|null|undefined} locked
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        ClientRoomUpdate.prototype.locked = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientRoomUpdate _name.
         * @member {"name"|undefined} _name
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        Object.defineProperty(ClientRoomUpdate.prototype, "_name", {
            get: $util.oneOfGetter($oneOfFields = ["name"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientRoomUpdate _gamemode.
         * @member {"gamemode"|undefined} _gamemode
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        Object.defineProperty(ClientRoomUpdate.prototype, "_gamemode", {
            get: $util.oneOfGetter($oneOfFields = ["gamemode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientRoomUpdate _maxUsers.
         * @member {"maxUsers"|undefined} _maxUsers
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        Object.defineProperty(ClientRoomUpdate.prototype, "_maxUsers", {
            get: $util.oneOfGetter($oneOfFields = ["maxUsers"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientRoomUpdate _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        Object.defineProperty(ClientRoomUpdate.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientRoomUpdate _locked.
         * @member {"locked"|undefined} _locked
         * @memberof NT.ClientRoomUpdate
         * @instance
         */
        Object.defineProperty(ClientRoomUpdate.prototype, "_locked", {
            get: $util.oneOfGetter($oneOfFields = ["locked"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientRoomUpdate instance using the specified properties.
         * @function create
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {NT.IClientRoomUpdate=} [properties] Properties to set
         * @returns {NT.ClientRoomUpdate} ClientRoomUpdate instance
         */
        ClientRoomUpdate.create = function create(properties) {
            return new ClientRoomUpdate(properties);
        };

        /**
         * Encodes the specified ClientRoomUpdate message. Does not implicitly {@link NT.ClientRoomUpdate.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {NT.IClientRoomUpdate} message ClientRoomUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gamemode);
            if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxUsers);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.locked);
            return writer;
        };

        /**
         * Encodes the specified ClientRoomUpdate message, length delimited. Does not implicitly {@link NT.ClientRoomUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {NT.IClientRoomUpdate} message ClientRoomUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRoomUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRoomUpdate} ClientRoomUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRoomUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gamemode = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxUsers = reader.uint32();
                        break;
                    }
                case 4: {
                        message.password = reader.string();
                        break;
                    }
                case 5: {
                        message.locked = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRoomUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRoomUpdate} ClientRoomUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRoomUpdate message.
         * @function verify
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRoomUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name")) {
                properties._name = 1;
                if (!$util.isString(message.name))
                    return "name: string expected";
            }
            if (message.gamemode != null && message.hasOwnProperty("gamemode")) {
                properties._gamemode = 1;
                if (!$util.isInteger(message.gamemode))
                    return "gamemode: integer expected";
            }
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers")) {
                properties._maxUsers = 1;
                if (!$util.isInteger(message.maxUsers))
                    return "maxUsers: integer expected";
            }
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            if (message.locked != null && message.hasOwnProperty("locked")) {
                properties._locked = 1;
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ClientRoomUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRoomUpdate} ClientRoomUpdate
         */
        ClientRoomUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRoomUpdate)
                return object;
            let message = new $root.NT.ClientRoomUpdate();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gamemode != null)
                message.gamemode = object.gamemode >>> 0;
            if (object.maxUsers != null)
                message.maxUsers = object.maxUsers >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            return message;
        };

        /**
         * Creates a plain object from a ClientRoomUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {NT.ClientRoomUpdate} message ClientRoomUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRoomUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = message.name;
                if (options.oneofs)
                    object._name = "name";
            }
            if (message.gamemode != null && message.hasOwnProperty("gamemode")) {
                object.gamemode = message.gamemode;
                if (options.oneofs)
                    object._gamemode = "gamemode";
            }
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers")) {
                object.maxUsers = message.maxUsers;
                if (options.oneofs)
                    object._maxUsers = "maxUsers";
            }
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            if (message.locked != null && message.hasOwnProperty("locked")) {
                object.locked = message.locked;
                if (options.oneofs)
                    object._locked = "locked";
            }
            return object;
        };

        /**
         * Converts this ClientRoomUpdate to JSON.
         * @function toJSON
         * @memberof NT.ClientRoomUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRoomUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRoomUpdate
         * @function getTypeUrl
         * @memberof NT.ClientRoomUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRoomUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRoomUpdate";
        };

        return ClientRoomUpdate;
    })();

    NT.ServerRoomUpdated = (function() {

        /**
         * Properties of a ServerRoomUpdated.
         * @memberof NT
         * @interface IServerRoomUpdated
         * @property {string|null} [name] ServerRoomUpdated name
         * @property {number|null} [gamemode] ServerRoomUpdated gamemode
         * @property {number|null} [maxUsers] ServerRoomUpdated maxUsers
         * @property {string|null} [password] ServerRoomUpdated password
         * @property {boolean|null} [locked] ServerRoomUpdated locked
         */

        /**
         * Constructs a new ServerRoomUpdated.
         * @memberof NT
         * @classdesc Represents a ServerRoomUpdated.
         * @implements IServerRoomUpdated
         * @constructor
         * @param {NT.IServerRoomUpdated=} [properties] Properties to set
         */
        function ServerRoomUpdated(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomUpdated name.
         * @member {string|null|undefined} name
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        ServerRoomUpdated.prototype.name = null;

        /**
         * ServerRoomUpdated gamemode.
         * @member {number|null|undefined} gamemode
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        ServerRoomUpdated.prototype.gamemode = null;

        /**
         * ServerRoomUpdated maxUsers.
         * @member {number|null|undefined} maxUsers
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        ServerRoomUpdated.prototype.maxUsers = null;

        /**
         * ServerRoomUpdated password.
         * @member {string|null|undefined} password
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        ServerRoomUpdated.prototype.password = null;

        /**
         * ServerRoomUpdated locked.
         * @member {boolean|null|undefined} locked
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        ServerRoomUpdated.prototype.locked = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerRoomUpdated _name.
         * @member {"name"|undefined} _name
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        Object.defineProperty(ServerRoomUpdated.prototype, "_name", {
            get: $util.oneOfGetter($oneOfFields = ["name"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerRoomUpdated _gamemode.
         * @member {"gamemode"|undefined} _gamemode
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        Object.defineProperty(ServerRoomUpdated.prototype, "_gamemode", {
            get: $util.oneOfGetter($oneOfFields = ["gamemode"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerRoomUpdated _maxUsers.
         * @member {"maxUsers"|undefined} _maxUsers
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        Object.defineProperty(ServerRoomUpdated.prototype, "_maxUsers", {
            get: $util.oneOfGetter($oneOfFields = ["maxUsers"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerRoomUpdated _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        Object.defineProperty(ServerRoomUpdated.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerRoomUpdated _locked.
         * @member {"locked"|undefined} _locked
         * @memberof NT.ServerRoomUpdated
         * @instance
         */
        Object.defineProperty(ServerRoomUpdated.prototype, "_locked", {
            get: $util.oneOfGetter($oneOfFields = ["locked"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerRoomUpdated instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {NT.IServerRoomUpdated=} [properties] Properties to set
         * @returns {NT.ServerRoomUpdated} ServerRoomUpdated instance
         */
        ServerRoomUpdated.create = function create(properties) {
            return new ServerRoomUpdated(properties);
        };

        /**
         * Encodes the specified ServerRoomUpdated message. Does not implicitly {@link NT.ServerRoomUpdated.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {NT.IServerRoomUpdated} message ServerRoomUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomUpdated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.gamemode);
            if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.maxUsers);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.password);
            if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.locked);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomUpdated message, length delimited. Does not implicitly {@link NT.ServerRoomUpdated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {NT.IServerRoomUpdated} message ServerRoomUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomUpdated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomUpdated message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomUpdated} ServerRoomUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomUpdated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomUpdated();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.gamemode = reader.uint32();
                        break;
                    }
                case 3: {
                        message.maxUsers = reader.uint32();
                        break;
                    }
                case 4: {
                        message.password = reader.string();
                        break;
                    }
                case 5: {
                        message.locked = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomUpdated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomUpdated} ServerRoomUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomUpdated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomUpdated message.
         * @function verify
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomUpdated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.name != null && message.hasOwnProperty("name")) {
                properties._name = 1;
                if (!$util.isString(message.name))
                    return "name: string expected";
            }
            if (message.gamemode != null && message.hasOwnProperty("gamemode")) {
                properties._gamemode = 1;
                if (!$util.isInteger(message.gamemode))
                    return "gamemode: integer expected";
            }
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers")) {
                properties._maxUsers = 1;
                if (!$util.isInteger(message.maxUsers))
                    return "maxUsers: integer expected";
            }
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            if (message.locked != null && message.hasOwnProperty("locked")) {
                properties._locked = 1;
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ServerRoomUpdated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomUpdated} ServerRoomUpdated
         */
        ServerRoomUpdated.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomUpdated)
                return object;
            let message = new $root.NT.ServerRoomUpdated();
            if (object.name != null)
                message.name = String(object.name);
            if (object.gamemode != null)
                message.gamemode = object.gamemode >>> 0;
            if (object.maxUsers != null)
                message.maxUsers = object.maxUsers >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomUpdated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {NT.ServerRoomUpdated} message ServerRoomUpdated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomUpdated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (message.name != null && message.hasOwnProperty("name")) {
                object.name = message.name;
                if (options.oneofs)
                    object._name = "name";
            }
            if (message.gamemode != null && message.hasOwnProperty("gamemode")) {
                object.gamemode = message.gamemode;
                if (options.oneofs)
                    object._gamemode = "gamemode";
            }
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers")) {
                object.maxUsers = message.maxUsers;
                if (options.oneofs)
                    object._maxUsers = "maxUsers";
            }
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            if (message.locked != null && message.hasOwnProperty("locked")) {
                object.locked = message.locked;
                if (options.oneofs)
                    object._locked = "locked";
            }
            return object;
        };

        /**
         * Converts this ServerRoomUpdated to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomUpdated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomUpdated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomUpdated
         * @function getTypeUrl
         * @memberof NT.ServerRoomUpdated
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomUpdated.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomUpdated";
        };

        return ServerRoomUpdated;
    })();

    NT.ServerRoomUpdateFailed = (function() {

        /**
         * Properties of a ServerRoomUpdateFailed.
         * @memberof NT
         * @interface IServerRoomUpdateFailed
         * @property {string|null} [reason] ServerRoomUpdateFailed reason
         */

        /**
         * Constructs a new ServerRoomUpdateFailed.
         * @memberof NT
         * @classdesc Represents a ServerRoomUpdateFailed.
         * @implements IServerRoomUpdateFailed
         * @constructor
         * @param {NT.IServerRoomUpdateFailed=} [properties] Properties to set
         */
        function ServerRoomUpdateFailed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomUpdateFailed reason.
         * @member {string} reason
         * @memberof NT.ServerRoomUpdateFailed
         * @instance
         */
        ServerRoomUpdateFailed.prototype.reason = "";

        /**
         * Creates a new ServerRoomUpdateFailed instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {NT.IServerRoomUpdateFailed=} [properties] Properties to set
         * @returns {NT.ServerRoomUpdateFailed} ServerRoomUpdateFailed instance
         */
        ServerRoomUpdateFailed.create = function create(properties) {
            return new ServerRoomUpdateFailed(properties);
        };

        /**
         * Encodes the specified ServerRoomUpdateFailed message. Does not implicitly {@link NT.ServerRoomUpdateFailed.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {NT.IServerRoomUpdateFailed} message ServerRoomUpdateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomUpdateFailed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomUpdateFailed message, length delimited. Does not implicitly {@link NT.ServerRoomUpdateFailed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {NT.IServerRoomUpdateFailed} message ServerRoomUpdateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomUpdateFailed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomUpdateFailed message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomUpdateFailed} ServerRoomUpdateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomUpdateFailed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomUpdateFailed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomUpdateFailed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomUpdateFailed} ServerRoomUpdateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomUpdateFailed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomUpdateFailed message.
         * @function verify
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomUpdateFailed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ServerRoomUpdateFailed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomUpdateFailed} ServerRoomUpdateFailed
         */
        ServerRoomUpdateFailed.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomUpdateFailed)
                return object;
            let message = new $root.NT.ServerRoomUpdateFailed();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomUpdateFailed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {NT.ServerRoomUpdateFailed} message ServerRoomUpdateFailed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomUpdateFailed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ServerRoomUpdateFailed to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomUpdateFailed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomUpdateFailed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomUpdateFailed
         * @function getTypeUrl
         * @memberof NT.ServerRoomUpdateFailed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomUpdateFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomUpdateFailed";
        };

        return ServerRoomUpdateFailed;
    })();

    NT.ClientRoomFlagsUpdate = (function() {

        /**
         * Properties of a ClientRoomFlagsUpdate.
         * @memberof NT
         * @interface IClientRoomFlagsUpdate
         * @property {Array.<NT.ClientRoomFlagsUpdate.IGameFlag>|null} [flags] ClientRoomFlagsUpdate flags
         */

        /**
         * Constructs a new ClientRoomFlagsUpdate.
         * @memberof NT
         * @classdesc Represents a ClientRoomFlagsUpdate.
         * @implements IClientRoomFlagsUpdate
         * @constructor
         * @param {NT.IClientRoomFlagsUpdate=} [properties] Properties to set
         */
        function ClientRoomFlagsUpdate(properties) {
            this.flags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRoomFlagsUpdate flags.
         * @member {Array.<NT.ClientRoomFlagsUpdate.IGameFlag>} flags
         * @memberof NT.ClientRoomFlagsUpdate
         * @instance
         */
        ClientRoomFlagsUpdate.prototype.flags = $util.emptyArray;

        /**
         * Creates a new ClientRoomFlagsUpdate instance using the specified properties.
         * @function create
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {NT.IClientRoomFlagsUpdate=} [properties] Properties to set
         * @returns {NT.ClientRoomFlagsUpdate} ClientRoomFlagsUpdate instance
         */
        ClientRoomFlagsUpdate.create = function create(properties) {
            return new ClientRoomFlagsUpdate(properties);
        };

        /**
         * Encodes the specified ClientRoomFlagsUpdate message. Does not implicitly {@link NT.ClientRoomFlagsUpdate.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {NT.IClientRoomFlagsUpdate} message ClientRoomFlagsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomFlagsUpdate.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flags != null && message.flags.length)
                for (let i = 0; i < message.flags.length; ++i)
                    $root.NT.ClientRoomFlagsUpdate.GameFlag.encode(message.flags[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ClientRoomFlagsUpdate message, length delimited. Does not implicitly {@link NT.ClientRoomFlagsUpdate.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {NT.IClientRoomFlagsUpdate} message ClientRoomFlagsUpdate message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRoomFlagsUpdate.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRoomFlagsUpdate message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRoomFlagsUpdate} ClientRoomFlagsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomFlagsUpdate.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRoomFlagsUpdate();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        message.flags.push($root.NT.ClientRoomFlagsUpdate.GameFlag.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRoomFlagsUpdate message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRoomFlagsUpdate} ClientRoomFlagsUpdate
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRoomFlagsUpdate.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRoomFlagsUpdate message.
         * @function verify
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRoomFlagsUpdate.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i) {
                    let error = $root.NT.ClientRoomFlagsUpdate.GameFlag.verify(message.flags[i]);
                    if (error)
                        return "flags." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ClientRoomFlagsUpdate message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRoomFlagsUpdate} ClientRoomFlagsUpdate
         */
        ClientRoomFlagsUpdate.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRoomFlagsUpdate)
                return object;
            let message = new $root.NT.ClientRoomFlagsUpdate();
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".NT.ClientRoomFlagsUpdate.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i) {
                    if (typeof object.flags[i] !== "object")
                        throw TypeError(".NT.ClientRoomFlagsUpdate.flags: object expected");
                    message.flags[i] = $root.NT.ClientRoomFlagsUpdate.GameFlag.fromObject(object.flags[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ClientRoomFlagsUpdate message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {NT.ClientRoomFlagsUpdate} message ClientRoomFlagsUpdate
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRoomFlagsUpdate.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.flags = [];
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = $root.NT.ClientRoomFlagsUpdate.GameFlag.toObject(message.flags[j], options);
            }
            return object;
        };

        /**
         * Converts this ClientRoomFlagsUpdate to JSON.
         * @function toJSON
         * @memberof NT.ClientRoomFlagsUpdate
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRoomFlagsUpdate.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRoomFlagsUpdate
         * @function getTypeUrl
         * @memberof NT.ClientRoomFlagsUpdate
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRoomFlagsUpdate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRoomFlagsUpdate";
        };

        ClientRoomFlagsUpdate.GameFlag = (function() {

            /**
             * Properties of a GameFlag.
             * @memberof NT.ClientRoomFlagsUpdate
             * @interface IGameFlag
             * @property {string|null} [flag] GameFlag flag
             * @property {number|null} [intVal] GameFlag intVal
             * @property {string|null} [strVal] GameFlag strVal
             * @property {number|null} [floatVal] GameFlag floatVal
             * @property {boolean|null} [boolVal] GameFlag boolVal
             * @property {number|null} [uIntVal] GameFlag uIntVal
             */

            /**
             * Constructs a new GameFlag.
             * @memberof NT.ClientRoomFlagsUpdate
             * @classdesc Represents a GameFlag.
             * @implements IGameFlag
             * @constructor
             * @param {NT.ClientRoomFlagsUpdate.IGameFlag=} [properties] Properties to set
             */
            function GameFlag(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameFlag flag.
             * @member {string} flag
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.flag = "";

            /**
             * GameFlag intVal.
             * @member {number|null|undefined} intVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.intVal = null;

            /**
             * GameFlag strVal.
             * @member {string|null|undefined} strVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.strVal = null;

            /**
             * GameFlag floatVal.
             * @member {number|null|undefined} floatVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.floatVal = null;

            /**
             * GameFlag boolVal.
             * @member {boolean|null|undefined} boolVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.boolVal = null;

            /**
             * GameFlag uIntVal.
             * @member {number|null|undefined} uIntVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            GameFlag.prototype.uIntVal = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GameFlag _intVal.
             * @member {"intVal"|undefined} _intVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_intVal", {
                get: $util.oneOfGetter($oneOfFields = ["intVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _strVal.
             * @member {"strVal"|undefined} _strVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_strVal", {
                get: $util.oneOfGetter($oneOfFields = ["strVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _floatVal.
             * @member {"floatVal"|undefined} _floatVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_floatVal", {
                get: $util.oneOfGetter($oneOfFields = ["floatVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _boolVal.
             * @member {"boolVal"|undefined} _boolVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_boolVal", {
                get: $util.oneOfGetter($oneOfFields = ["boolVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _uIntVal.
             * @member {"uIntVal"|undefined} _uIntVal
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_uIntVal", {
                get: $util.oneOfGetter($oneOfFields = ["uIntVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GameFlag instance using the specified properties.
             * @function create
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {NT.ClientRoomFlagsUpdate.IGameFlag=} [properties] Properties to set
             * @returns {NT.ClientRoomFlagsUpdate.GameFlag} GameFlag instance
             */
            GameFlag.create = function create(properties) {
                return new GameFlag(properties);
            };

            /**
             * Encodes the specified GameFlag message. Does not implicitly {@link NT.ClientRoomFlagsUpdate.GameFlag.verify|verify} messages.
             * @function encode
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {NT.ClientRoomFlagsUpdate.IGameFlag} message GameFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.flag);
                if (message.intVal != null && Object.hasOwnProperty.call(message, "intVal"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.intVal);
                if (message.strVal != null && Object.hasOwnProperty.call(message, "strVal"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.strVal);
                if (message.floatVal != null && Object.hasOwnProperty.call(message, "floatVal"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.floatVal);
                if (message.boolVal != null && Object.hasOwnProperty.call(message, "boolVal"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.boolVal);
                if (message.uIntVal != null && Object.hasOwnProperty.call(message, "uIntVal"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uIntVal);
                return writer;
            };

            /**
             * Encodes the specified GameFlag message, length delimited. Does not implicitly {@link NT.ClientRoomFlagsUpdate.GameFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {NT.ClientRoomFlagsUpdate.IGameFlag} message GameFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameFlag message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ClientRoomFlagsUpdate.GameFlag} GameFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRoomFlagsUpdate.GameFlag();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.string();
                            break;
                        }
                    case 2: {
                            message.intVal = reader.int32();
                            break;
                        }
                    case 3: {
                            message.strVal = reader.string();
                            break;
                        }
                    case 4: {
                            message.floatVal = reader.float();
                            break;
                        }
                    case 5: {
                            message.boolVal = reader.bool();
                            break;
                        }
                    case 6: {
                            message.uIntVal = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GameFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ClientRoomFlagsUpdate.GameFlag} GameFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameFlag message.
             * @function verify
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GameFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                if (message.intVal != null && message.hasOwnProperty("intVal")) {
                    properties._intVal = 1;
                    if (!$util.isInteger(message.intVal))
                        return "intVal: integer expected";
                }
                if (message.strVal != null && message.hasOwnProperty("strVal")) {
                    properties._strVal = 1;
                    if (!$util.isString(message.strVal))
                        return "strVal: string expected";
                }
                if (message.floatVal != null && message.hasOwnProperty("floatVal")) {
                    properties._floatVal = 1;
                    if (typeof message.floatVal !== "number")
                        return "floatVal: number expected";
                }
                if (message.boolVal != null && message.hasOwnProperty("boolVal")) {
                    properties._boolVal = 1;
                    if (typeof message.boolVal !== "boolean")
                        return "boolVal: boolean expected";
                }
                if (message.uIntVal != null && message.hasOwnProperty("uIntVal")) {
                    properties._uIntVal = 1;
                    if (!$util.isInteger(message.uIntVal))
                        return "uIntVal: integer expected";
                }
                return null;
            };

            /**
             * Creates a GameFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ClientRoomFlagsUpdate.GameFlag} GameFlag
             */
            GameFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ClientRoomFlagsUpdate.GameFlag)
                    return object;
                let message = new $root.NT.ClientRoomFlagsUpdate.GameFlag();
                if (object.flag != null)
                    message.flag = String(object.flag);
                if (object.intVal != null)
                    message.intVal = object.intVal | 0;
                if (object.strVal != null)
                    message.strVal = String(object.strVal);
                if (object.floatVal != null)
                    message.floatVal = Number(object.floatVal);
                if (object.boolVal != null)
                    message.boolVal = Boolean(object.boolVal);
                if (object.uIntVal != null)
                    message.uIntVal = object.uIntVal >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GameFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {NT.ClientRoomFlagsUpdate.GameFlag} message GameFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameFlag.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = "";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.intVal != null && message.hasOwnProperty("intVal")) {
                    object.intVal = message.intVal;
                    if (options.oneofs)
                        object._intVal = "intVal";
                }
                if (message.strVal != null && message.hasOwnProperty("strVal")) {
                    object.strVal = message.strVal;
                    if (options.oneofs)
                        object._strVal = "strVal";
                }
                if (message.floatVal != null && message.hasOwnProperty("floatVal")) {
                    object.floatVal = options.json && !isFinite(message.floatVal) ? String(message.floatVal) : message.floatVal;
                    if (options.oneofs)
                        object._floatVal = "floatVal";
                }
                if (message.boolVal != null && message.hasOwnProperty("boolVal")) {
                    object.boolVal = message.boolVal;
                    if (options.oneofs)
                        object._boolVal = "boolVal";
                }
                if (message.uIntVal != null && message.hasOwnProperty("uIntVal")) {
                    object.uIntVal = message.uIntVal;
                    if (options.oneofs)
                        object._uIntVal = "uIntVal";
                }
                return object;
            };

            /**
             * Converts this GameFlag to JSON.
             * @function toJSON
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GameFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GameFlag
             * @function getTypeUrl
             * @memberof NT.ClientRoomFlagsUpdate.GameFlag
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GameFlag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ClientRoomFlagsUpdate.GameFlag";
            };

            return GameFlag;
        })();

        return ClientRoomFlagsUpdate;
    })();

    NT.ServerRoomFlagsUpdated = (function() {

        /**
         * Properties of a ServerRoomFlagsUpdated.
         * @memberof NT
         * @interface IServerRoomFlagsUpdated
         * @property {Array.<NT.ServerRoomFlagsUpdated.IGameFlag>|null} [flags] ServerRoomFlagsUpdated flags
         */

        /**
         * Constructs a new ServerRoomFlagsUpdated.
         * @memberof NT
         * @classdesc Represents a ServerRoomFlagsUpdated.
         * @implements IServerRoomFlagsUpdated
         * @constructor
         * @param {NT.IServerRoomFlagsUpdated=} [properties] Properties to set
         */
        function ServerRoomFlagsUpdated(properties) {
            this.flags = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomFlagsUpdated flags.
         * @member {Array.<NT.ServerRoomFlagsUpdated.IGameFlag>} flags
         * @memberof NT.ServerRoomFlagsUpdated
         * @instance
         */
        ServerRoomFlagsUpdated.prototype.flags = $util.emptyArray;

        /**
         * Creates a new ServerRoomFlagsUpdated instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {NT.IServerRoomFlagsUpdated=} [properties] Properties to set
         * @returns {NT.ServerRoomFlagsUpdated} ServerRoomFlagsUpdated instance
         */
        ServerRoomFlagsUpdated.create = function create(properties) {
            return new ServerRoomFlagsUpdated(properties);
        };

        /**
         * Encodes the specified ServerRoomFlagsUpdated message. Does not implicitly {@link NT.ServerRoomFlagsUpdated.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {NT.IServerRoomFlagsUpdated} message ServerRoomFlagsUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomFlagsUpdated.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.flags != null && message.flags.length)
                for (let i = 0; i < message.flags.length; ++i)
                    $root.NT.ServerRoomFlagsUpdated.GameFlag.encode(message.flags[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerRoomFlagsUpdated message, length delimited. Does not implicitly {@link NT.ServerRoomFlagsUpdated.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {NT.IServerRoomFlagsUpdated} message ServerRoomFlagsUpdated message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomFlagsUpdated.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomFlagsUpdated message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomFlagsUpdated} ServerRoomFlagsUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomFlagsUpdated.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomFlagsUpdated();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.flags && message.flags.length))
                            message.flags = [];
                        message.flags.push($root.NT.ServerRoomFlagsUpdated.GameFlag.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomFlagsUpdated message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomFlagsUpdated} ServerRoomFlagsUpdated
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomFlagsUpdated.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomFlagsUpdated message.
         * @function verify
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomFlagsUpdated.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.flags != null && message.hasOwnProperty("flags")) {
                if (!Array.isArray(message.flags))
                    return "flags: array expected";
                for (let i = 0; i < message.flags.length; ++i) {
                    let error = $root.NT.ServerRoomFlagsUpdated.GameFlag.verify(message.flags[i]);
                    if (error)
                        return "flags." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerRoomFlagsUpdated message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomFlagsUpdated} ServerRoomFlagsUpdated
         */
        ServerRoomFlagsUpdated.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomFlagsUpdated)
                return object;
            let message = new $root.NT.ServerRoomFlagsUpdated();
            if (object.flags) {
                if (!Array.isArray(object.flags))
                    throw TypeError(".NT.ServerRoomFlagsUpdated.flags: array expected");
                message.flags = [];
                for (let i = 0; i < object.flags.length; ++i) {
                    if (typeof object.flags[i] !== "object")
                        throw TypeError(".NT.ServerRoomFlagsUpdated.flags: object expected");
                    message.flags[i] = $root.NT.ServerRoomFlagsUpdated.GameFlag.fromObject(object.flags[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomFlagsUpdated message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {NT.ServerRoomFlagsUpdated} message ServerRoomFlagsUpdated
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomFlagsUpdated.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.flags = [];
            if (message.flags && message.flags.length) {
                object.flags = [];
                for (let j = 0; j < message.flags.length; ++j)
                    object.flags[j] = $root.NT.ServerRoomFlagsUpdated.GameFlag.toObject(message.flags[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerRoomFlagsUpdated to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomFlagsUpdated
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomFlagsUpdated.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomFlagsUpdated
         * @function getTypeUrl
         * @memberof NT.ServerRoomFlagsUpdated
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomFlagsUpdated.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomFlagsUpdated";
        };

        ServerRoomFlagsUpdated.GameFlag = (function() {

            /**
             * Properties of a GameFlag.
             * @memberof NT.ServerRoomFlagsUpdated
             * @interface IGameFlag
             * @property {string|null} [flag] GameFlag flag
             * @property {number|null} [intVal] GameFlag intVal
             * @property {string|null} [strVal] GameFlag strVal
             * @property {number|null} [floatVal] GameFlag floatVal
             * @property {boolean|null} [boolVal] GameFlag boolVal
             * @property {number|null} [uIntVal] GameFlag uIntVal
             */

            /**
             * Constructs a new GameFlag.
             * @memberof NT.ServerRoomFlagsUpdated
             * @classdesc Represents a GameFlag.
             * @implements IGameFlag
             * @constructor
             * @param {NT.ServerRoomFlagsUpdated.IGameFlag=} [properties] Properties to set
             */
            function GameFlag(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GameFlag flag.
             * @member {string} flag
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.flag = "";

            /**
             * GameFlag intVal.
             * @member {number|null|undefined} intVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.intVal = null;

            /**
             * GameFlag strVal.
             * @member {string|null|undefined} strVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.strVal = null;

            /**
             * GameFlag floatVal.
             * @member {number|null|undefined} floatVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.floatVal = null;

            /**
             * GameFlag boolVal.
             * @member {boolean|null|undefined} boolVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.boolVal = null;

            /**
             * GameFlag uIntVal.
             * @member {number|null|undefined} uIntVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            GameFlag.prototype.uIntVal = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * GameFlag _intVal.
             * @member {"intVal"|undefined} _intVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_intVal", {
                get: $util.oneOfGetter($oneOfFields = ["intVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _strVal.
             * @member {"strVal"|undefined} _strVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_strVal", {
                get: $util.oneOfGetter($oneOfFields = ["strVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _floatVal.
             * @member {"floatVal"|undefined} _floatVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_floatVal", {
                get: $util.oneOfGetter($oneOfFields = ["floatVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _boolVal.
             * @member {"boolVal"|undefined} _boolVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_boolVal", {
                get: $util.oneOfGetter($oneOfFields = ["boolVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * GameFlag _uIntVal.
             * @member {"uIntVal"|undefined} _uIntVal
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             */
            Object.defineProperty(GameFlag.prototype, "_uIntVal", {
                get: $util.oneOfGetter($oneOfFields = ["uIntVal"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new GameFlag instance using the specified properties.
             * @function create
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {NT.ServerRoomFlagsUpdated.IGameFlag=} [properties] Properties to set
             * @returns {NT.ServerRoomFlagsUpdated.GameFlag} GameFlag instance
             */
            GameFlag.create = function create(properties) {
                return new GameFlag(properties);
            };

            /**
             * Encodes the specified GameFlag message. Does not implicitly {@link NT.ServerRoomFlagsUpdated.GameFlag.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {NT.ServerRoomFlagsUpdated.IGameFlag} message GameFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameFlag.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.flag != null && Object.hasOwnProperty.call(message, "flag"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.flag);
                if (message.intVal != null && Object.hasOwnProperty.call(message, "intVal"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.intVal);
                if (message.strVal != null && Object.hasOwnProperty.call(message, "strVal"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.strVal);
                if (message.floatVal != null && Object.hasOwnProperty.call(message, "floatVal"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.floatVal);
                if (message.boolVal != null && Object.hasOwnProperty.call(message, "boolVal"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.boolVal);
                if (message.uIntVal != null && Object.hasOwnProperty.call(message, "uIntVal"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uIntVal);
                return writer;
            };

            /**
             * Encodes the specified GameFlag message, length delimited. Does not implicitly {@link NT.ServerRoomFlagsUpdated.GameFlag.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {NT.ServerRoomFlagsUpdated.IGameFlag} message GameFlag message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GameFlag.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GameFlag message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerRoomFlagsUpdated.GameFlag} GameFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameFlag.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomFlagsUpdated.GameFlag();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.flag = reader.string();
                            break;
                        }
                    case 2: {
                            message.intVal = reader.int32();
                            break;
                        }
                    case 3: {
                            message.strVal = reader.string();
                            break;
                        }
                    case 4: {
                            message.floatVal = reader.float();
                            break;
                        }
                    case 5: {
                            message.boolVal = reader.bool();
                            break;
                        }
                    case 6: {
                            message.uIntVal = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GameFlag message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerRoomFlagsUpdated.GameFlag} GameFlag
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GameFlag.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GameFlag message.
             * @function verify
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GameFlag.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.flag != null && message.hasOwnProperty("flag"))
                    if (!$util.isString(message.flag))
                        return "flag: string expected";
                if (message.intVal != null && message.hasOwnProperty("intVal")) {
                    properties._intVal = 1;
                    if (!$util.isInteger(message.intVal))
                        return "intVal: integer expected";
                }
                if (message.strVal != null && message.hasOwnProperty("strVal")) {
                    properties._strVal = 1;
                    if (!$util.isString(message.strVal))
                        return "strVal: string expected";
                }
                if (message.floatVal != null && message.hasOwnProperty("floatVal")) {
                    properties._floatVal = 1;
                    if (typeof message.floatVal !== "number")
                        return "floatVal: number expected";
                }
                if (message.boolVal != null && message.hasOwnProperty("boolVal")) {
                    properties._boolVal = 1;
                    if (typeof message.boolVal !== "boolean")
                        return "boolVal: boolean expected";
                }
                if (message.uIntVal != null && message.hasOwnProperty("uIntVal")) {
                    properties._uIntVal = 1;
                    if (!$util.isInteger(message.uIntVal))
                        return "uIntVal: integer expected";
                }
                return null;
            };

            /**
             * Creates a GameFlag message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerRoomFlagsUpdated.GameFlag} GameFlag
             */
            GameFlag.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerRoomFlagsUpdated.GameFlag)
                    return object;
                let message = new $root.NT.ServerRoomFlagsUpdated.GameFlag();
                if (object.flag != null)
                    message.flag = String(object.flag);
                if (object.intVal != null)
                    message.intVal = object.intVal | 0;
                if (object.strVal != null)
                    message.strVal = String(object.strVal);
                if (object.floatVal != null)
                    message.floatVal = Number(object.floatVal);
                if (object.boolVal != null)
                    message.boolVal = Boolean(object.boolVal);
                if (object.uIntVal != null)
                    message.uIntVal = object.uIntVal >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a GameFlag message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {NT.ServerRoomFlagsUpdated.GameFlag} message GameFlag
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GameFlag.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.flag = "";
                if (message.flag != null && message.hasOwnProperty("flag"))
                    object.flag = message.flag;
                if (message.intVal != null && message.hasOwnProperty("intVal")) {
                    object.intVal = message.intVal;
                    if (options.oneofs)
                        object._intVal = "intVal";
                }
                if (message.strVal != null && message.hasOwnProperty("strVal")) {
                    object.strVal = message.strVal;
                    if (options.oneofs)
                        object._strVal = "strVal";
                }
                if (message.floatVal != null && message.hasOwnProperty("floatVal")) {
                    object.floatVal = options.json && !isFinite(message.floatVal) ? String(message.floatVal) : message.floatVal;
                    if (options.oneofs)
                        object._floatVal = "floatVal";
                }
                if (message.boolVal != null && message.hasOwnProperty("boolVal")) {
                    object.boolVal = message.boolVal;
                    if (options.oneofs)
                        object._boolVal = "boolVal";
                }
                if (message.uIntVal != null && message.hasOwnProperty("uIntVal")) {
                    object.uIntVal = message.uIntVal;
                    if (options.oneofs)
                        object._uIntVal = "uIntVal";
                }
                return object;
            };

            /**
             * Converts this GameFlag to JSON.
             * @function toJSON
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GameFlag.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for GameFlag
             * @function getTypeUrl
             * @memberof NT.ServerRoomFlagsUpdated.GameFlag
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            GameFlag.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerRoomFlagsUpdated.GameFlag";
            };

            return GameFlag;
        })();

        return ServerRoomFlagsUpdated;
    })();

    NT.ServerRoomFlagsUpdateFailed = (function() {

        /**
         * Properties of a ServerRoomFlagsUpdateFailed.
         * @memberof NT
         * @interface IServerRoomFlagsUpdateFailed
         * @property {string|null} [reason] ServerRoomFlagsUpdateFailed reason
         */

        /**
         * Constructs a new ServerRoomFlagsUpdateFailed.
         * @memberof NT
         * @classdesc Represents a ServerRoomFlagsUpdateFailed.
         * @implements IServerRoomFlagsUpdateFailed
         * @constructor
         * @param {NT.IServerRoomFlagsUpdateFailed=} [properties] Properties to set
         */
        function ServerRoomFlagsUpdateFailed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomFlagsUpdateFailed reason.
         * @member {string} reason
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @instance
         */
        ServerRoomFlagsUpdateFailed.prototype.reason = "";

        /**
         * Creates a new ServerRoomFlagsUpdateFailed instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {NT.IServerRoomFlagsUpdateFailed=} [properties] Properties to set
         * @returns {NT.ServerRoomFlagsUpdateFailed} ServerRoomFlagsUpdateFailed instance
         */
        ServerRoomFlagsUpdateFailed.create = function create(properties) {
            return new ServerRoomFlagsUpdateFailed(properties);
        };

        /**
         * Encodes the specified ServerRoomFlagsUpdateFailed message. Does not implicitly {@link NT.ServerRoomFlagsUpdateFailed.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {NT.IServerRoomFlagsUpdateFailed} message ServerRoomFlagsUpdateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomFlagsUpdateFailed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomFlagsUpdateFailed message, length delimited. Does not implicitly {@link NT.ServerRoomFlagsUpdateFailed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {NT.IServerRoomFlagsUpdateFailed} message ServerRoomFlagsUpdateFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomFlagsUpdateFailed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomFlagsUpdateFailed message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomFlagsUpdateFailed} ServerRoomFlagsUpdateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomFlagsUpdateFailed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomFlagsUpdateFailed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomFlagsUpdateFailed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomFlagsUpdateFailed} ServerRoomFlagsUpdateFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomFlagsUpdateFailed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomFlagsUpdateFailed message.
         * @function verify
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomFlagsUpdateFailed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ServerRoomFlagsUpdateFailed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomFlagsUpdateFailed} ServerRoomFlagsUpdateFailed
         */
        ServerRoomFlagsUpdateFailed.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomFlagsUpdateFailed)
                return object;
            let message = new $root.NT.ServerRoomFlagsUpdateFailed();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomFlagsUpdateFailed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {NT.ServerRoomFlagsUpdateFailed} message ServerRoomFlagsUpdateFailed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomFlagsUpdateFailed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ServerRoomFlagsUpdateFailed to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomFlagsUpdateFailed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomFlagsUpdateFailed
         * @function getTypeUrl
         * @memberof NT.ServerRoomFlagsUpdateFailed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomFlagsUpdateFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomFlagsUpdateFailed";
        };

        return ServerRoomFlagsUpdateFailed;
    })();

    NT.ClientJoinRoom = (function() {

        /**
         * Properties of a ClientJoinRoom.
         * @memberof NT
         * @interface IClientJoinRoom
         * @property {string|null} [id] ClientJoinRoom id
         * @property {string|null} [password] ClientJoinRoom password
         */

        /**
         * Constructs a new ClientJoinRoom.
         * @memberof NT
         * @classdesc Represents a ClientJoinRoom.
         * @implements IClientJoinRoom
         * @constructor
         * @param {NT.IClientJoinRoom=} [properties] Properties to set
         */
        function ClientJoinRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientJoinRoom id.
         * @member {string} id
         * @memberof NT.ClientJoinRoom
         * @instance
         */
        ClientJoinRoom.prototype.id = "";

        /**
         * ClientJoinRoom password.
         * @member {string|null|undefined} password
         * @memberof NT.ClientJoinRoom
         * @instance
         */
        ClientJoinRoom.prototype.password = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientJoinRoom _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ClientJoinRoom
         * @instance
         */
        Object.defineProperty(ClientJoinRoom.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientJoinRoom instance using the specified properties.
         * @function create
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {NT.IClientJoinRoom=} [properties] Properties to set
         * @returns {NT.ClientJoinRoom} ClientJoinRoom instance
         */
        ClientJoinRoom.create = function create(properties) {
            return new ClientJoinRoom(properties);
        };

        /**
         * Encodes the specified ClientJoinRoom message. Does not implicitly {@link NT.ClientJoinRoom.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {NT.IClientJoinRoom} message ClientJoinRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientJoinRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);
            return writer;
        };

        /**
         * Encodes the specified ClientJoinRoom message, length delimited. Does not implicitly {@link NT.ClientJoinRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {NT.IClientJoinRoom} message ClientJoinRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientJoinRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientJoinRoom message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientJoinRoom} ClientJoinRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientJoinRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientJoinRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.password = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientJoinRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientJoinRoom} ClientJoinRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientJoinRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientJoinRoom message.
         * @function verify
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientJoinRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            return null;
        };

        /**
         * Creates a ClientJoinRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientJoinRoom} ClientJoinRoom
         */
        ClientJoinRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientJoinRoom)
                return object;
            let message = new $root.NT.ClientJoinRoom();
            if (object.id != null)
                message.id = String(object.id);
            if (object.password != null)
                message.password = String(object.password);
            return message;
        };

        /**
         * Creates a plain object from a ClientJoinRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {NT.ClientJoinRoom} message ClientJoinRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientJoinRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.id = "";
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            return object;
        };

        /**
         * Converts this ClientJoinRoom to JSON.
         * @function toJSON
         * @memberof NT.ClientJoinRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientJoinRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientJoinRoom
         * @function getTypeUrl
         * @memberof NT.ClientJoinRoom
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientJoinRoom.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientJoinRoom";
        };

        return ClientJoinRoom;
    })();

    NT.ServerJoinRoomSuccess = (function() {

        /**
         * Properties of a ServerJoinRoomSuccess.
         * @memberof NT
         * @interface IServerJoinRoomSuccess
         * @property {string|null} [id] ServerJoinRoomSuccess id
         * @property {string|null} [name] ServerJoinRoomSuccess name
         * @property {number|null} [gamemode] ServerJoinRoomSuccess gamemode
         * @property {number|null} [maxUsers] ServerJoinRoomSuccess maxUsers
         * @property {string|null} [password] ServerJoinRoomSuccess password
         * @property {boolean|null} [locked] ServerJoinRoomSuccess locked
         * @property {Array.<NT.ServerJoinRoomSuccess.IUser>|null} [users] ServerJoinRoomSuccess users
         */

        /**
         * Constructs a new ServerJoinRoomSuccess.
         * @memberof NT
         * @classdesc Represents a ServerJoinRoomSuccess.
         * @implements IServerJoinRoomSuccess
         * @constructor
         * @param {NT.IServerJoinRoomSuccess=} [properties] Properties to set
         */
        function ServerJoinRoomSuccess(properties) {
            this.users = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerJoinRoomSuccess id.
         * @member {string} id
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.id = "";

        /**
         * ServerJoinRoomSuccess name.
         * @member {string} name
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.name = "";

        /**
         * ServerJoinRoomSuccess gamemode.
         * @member {number} gamemode
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.gamemode = 0;

        /**
         * ServerJoinRoomSuccess maxUsers.
         * @member {number} maxUsers
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.maxUsers = 0;

        /**
         * ServerJoinRoomSuccess password.
         * @member {string|null|undefined} password
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.password = null;

        /**
         * ServerJoinRoomSuccess locked.
         * @member {boolean} locked
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.locked = false;

        /**
         * ServerJoinRoomSuccess users.
         * @member {Array.<NT.ServerJoinRoomSuccess.IUser>} users
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        ServerJoinRoomSuccess.prototype.users = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerJoinRoomSuccess _password.
         * @member {"password"|undefined} _password
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         */
        Object.defineProperty(ServerJoinRoomSuccess.prototype, "_password", {
            get: $util.oneOfGetter($oneOfFields = ["password"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerJoinRoomSuccess instance using the specified properties.
         * @function create
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {NT.IServerJoinRoomSuccess=} [properties] Properties to set
         * @returns {NT.ServerJoinRoomSuccess} ServerJoinRoomSuccess instance
         */
        ServerJoinRoomSuccess.create = function create(properties) {
            return new ServerJoinRoomSuccess(properties);
        };

        /**
         * Encodes the specified ServerJoinRoomSuccess message. Does not implicitly {@link NT.ServerJoinRoomSuccess.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {NT.IServerJoinRoomSuccess} message ServerJoinRoomSuccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerJoinRoomSuccess.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gamemode);
            if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.maxUsers);
            if (message.password != null && Object.hasOwnProperty.call(message, "password"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.password);
            if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.locked);
            if (message.users != null && message.users.length)
                for (let i = 0; i < message.users.length; ++i)
                    $root.NT.ServerJoinRoomSuccess.User.encode(message.users[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerJoinRoomSuccess message, length delimited. Does not implicitly {@link NT.ServerJoinRoomSuccess.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {NT.IServerJoinRoomSuccess} message ServerJoinRoomSuccess message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerJoinRoomSuccess.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerJoinRoomSuccess message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerJoinRoomSuccess} ServerJoinRoomSuccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerJoinRoomSuccess.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerJoinRoomSuccess();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                case 3: {
                        message.gamemode = reader.uint32();
                        break;
                    }
                case 4: {
                        message.maxUsers = reader.uint32();
                        break;
                    }
                case 5: {
                        message.password = reader.string();
                        break;
                    }
                case 6: {
                        message.locked = reader.bool();
                        break;
                    }
                case 7: {
                        if (!(message.users && message.users.length))
                            message.users = [];
                        message.users.push($root.NT.ServerJoinRoomSuccess.User.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerJoinRoomSuccess message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerJoinRoomSuccess} ServerJoinRoomSuccess
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerJoinRoomSuccess.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerJoinRoomSuccess message.
         * @function verify
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerJoinRoomSuccess.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                if (!$util.isInteger(message.gamemode))
                    return "gamemode: integer expected";
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                if (!$util.isInteger(message.maxUsers))
                    return "maxUsers: integer expected";
            if (message.password != null && message.hasOwnProperty("password")) {
                properties._password = 1;
                if (!$util.isString(message.password))
                    return "password: string expected";
            }
            if (message.locked != null && message.hasOwnProperty("locked"))
                if (typeof message.locked !== "boolean")
                    return "locked: boolean expected";
            if (message.users != null && message.hasOwnProperty("users")) {
                if (!Array.isArray(message.users))
                    return "users: array expected";
                for (let i = 0; i < message.users.length; ++i) {
                    let error = $root.NT.ServerJoinRoomSuccess.User.verify(message.users[i]);
                    if (error)
                        return "users." + error;
                }
            }
            return null;
        };

        /**
         * Creates a ServerJoinRoomSuccess message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerJoinRoomSuccess} ServerJoinRoomSuccess
         */
        ServerJoinRoomSuccess.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerJoinRoomSuccess)
                return object;
            let message = new $root.NT.ServerJoinRoomSuccess();
            if (object.id != null)
                message.id = String(object.id);
            if (object.name != null)
                message.name = String(object.name);
            if (object.gamemode != null)
                message.gamemode = object.gamemode >>> 0;
            if (object.maxUsers != null)
                message.maxUsers = object.maxUsers >>> 0;
            if (object.password != null)
                message.password = String(object.password);
            if (object.locked != null)
                message.locked = Boolean(object.locked);
            if (object.users) {
                if (!Array.isArray(object.users))
                    throw TypeError(".NT.ServerJoinRoomSuccess.users: array expected");
                message.users = [];
                for (let i = 0; i < object.users.length; ++i) {
                    if (typeof object.users[i] !== "object")
                        throw TypeError(".NT.ServerJoinRoomSuccess.users: object expected");
                    message.users[i] = $root.NT.ServerJoinRoomSuccess.User.fromObject(object.users[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerJoinRoomSuccess message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {NT.ServerJoinRoomSuccess} message ServerJoinRoomSuccess
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerJoinRoomSuccess.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.users = [];
            if (options.defaults) {
                object.id = "";
                object.name = "";
                object.gamemode = 0;
                object.maxUsers = 0;
                object.locked = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                object.gamemode = message.gamemode;
            if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                object.maxUsers = message.maxUsers;
            if (message.password != null && message.hasOwnProperty("password")) {
                object.password = message.password;
                if (options.oneofs)
                    object._password = "password";
            }
            if (message.locked != null && message.hasOwnProperty("locked"))
                object.locked = message.locked;
            if (message.users && message.users.length) {
                object.users = [];
                for (let j = 0; j < message.users.length; ++j)
                    object.users[j] = $root.NT.ServerJoinRoomSuccess.User.toObject(message.users[j], options);
            }
            return object;
        };

        /**
         * Converts this ServerJoinRoomSuccess to JSON.
         * @function toJSON
         * @memberof NT.ServerJoinRoomSuccess
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerJoinRoomSuccess.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerJoinRoomSuccess
         * @function getTypeUrl
         * @memberof NT.ServerJoinRoomSuccess
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerJoinRoomSuccess.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerJoinRoomSuccess";
        };

        ServerJoinRoomSuccess.User = (function() {

            /**
             * Properties of a User.
             * @memberof NT.ServerJoinRoomSuccess
             * @interface IUser
             * @property {string|null} [userId] User userId
             * @property {string|null} [name] User name
             * @property {boolean|null} [ready] User ready
             * @property {boolean|null} [owner] User owner
             */

            /**
             * Constructs a new User.
             * @memberof NT.ServerJoinRoomSuccess
             * @classdesc Represents a User.
             * @implements IUser
             * @constructor
             * @param {NT.ServerJoinRoomSuccess.IUser=} [properties] Properties to set
             */
            function User(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * User userId.
             * @member {string} userId
             * @memberof NT.ServerJoinRoomSuccess.User
             * @instance
             */
            User.prototype.userId = "";

            /**
             * User name.
             * @member {string} name
             * @memberof NT.ServerJoinRoomSuccess.User
             * @instance
             */
            User.prototype.name = "";

            /**
             * User ready.
             * @member {boolean} ready
             * @memberof NT.ServerJoinRoomSuccess.User
             * @instance
             */
            User.prototype.ready = false;

            /**
             * User owner.
             * @member {boolean} owner
             * @memberof NT.ServerJoinRoomSuccess.User
             * @instance
             */
            User.prototype.owner = false;

            /**
             * Creates a new User instance using the specified properties.
             * @function create
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {NT.ServerJoinRoomSuccess.IUser=} [properties] Properties to set
             * @returns {NT.ServerJoinRoomSuccess.User} User instance
             */
            User.create = function create(properties) {
                return new User(properties);
            };

            /**
             * Encodes the specified User message. Does not implicitly {@link NT.ServerJoinRoomSuccess.User.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {NT.ServerJoinRoomSuccess.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.ready);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 4, wireType 0 =*/32).bool(message.owner);
                return writer;
            };

            /**
             * Encodes the specified User message, length delimited. Does not implicitly {@link NT.ServerJoinRoomSuccess.User.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {NT.ServerJoinRoomSuccess.IUser} message User message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            User.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a User message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerJoinRoomSuccess.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerJoinRoomSuccess.User();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.userId = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.ready = reader.bool();
                            break;
                        }
                    case 4: {
                            message.owner = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a User message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerJoinRoomSuccess.User} User
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            User.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a User message.
             * @function verify
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            User.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.userId != null && message.hasOwnProperty("userId"))
                    if (!$util.isString(message.userId))
                        return "userId: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.ready != null && message.hasOwnProperty("ready"))
                    if (typeof message.ready !== "boolean")
                        return "ready: boolean expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (typeof message.owner !== "boolean")
                        return "owner: boolean expected";
                return null;
            };

            /**
             * Creates a User message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerJoinRoomSuccess.User} User
             */
            User.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerJoinRoomSuccess.User)
                    return object;
                let message = new $root.NT.ServerJoinRoomSuccess.User();
                if (object.userId != null)
                    message.userId = String(object.userId);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.ready != null)
                    message.ready = Boolean(object.ready);
                if (object.owner != null)
                    message.owner = Boolean(object.owner);
                return message;
            };

            /**
             * Creates a plain object from a User message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {NT.ServerJoinRoomSuccess.User} message User
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            User.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.userId = "";
                    object.name = "";
                    object.ready = false;
                    object.owner = false;
                }
                if (message.userId != null && message.hasOwnProperty("userId"))
                    object.userId = message.userId;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.ready != null && message.hasOwnProperty("ready"))
                    object.ready = message.ready;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                return object;
            };

            /**
             * Converts this User to JSON.
             * @function toJSON
             * @memberof NT.ServerJoinRoomSuccess.User
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            User.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for User
             * @function getTypeUrl
             * @memberof NT.ServerJoinRoomSuccess.User
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            User.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerJoinRoomSuccess.User";
            };

            return User;
        })();

        return ServerJoinRoomSuccess;
    })();

    NT.ServerJoinRoomFailed = (function() {

        /**
         * Properties of a ServerJoinRoomFailed.
         * @memberof NT
         * @interface IServerJoinRoomFailed
         * @property {string|null} [reason] ServerJoinRoomFailed reason
         */

        /**
         * Constructs a new ServerJoinRoomFailed.
         * @memberof NT
         * @classdesc Represents a ServerJoinRoomFailed.
         * @implements IServerJoinRoomFailed
         * @constructor
         * @param {NT.IServerJoinRoomFailed=} [properties] Properties to set
         */
        function ServerJoinRoomFailed(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerJoinRoomFailed reason.
         * @member {string} reason
         * @memberof NT.ServerJoinRoomFailed
         * @instance
         */
        ServerJoinRoomFailed.prototype.reason = "";

        /**
         * Creates a new ServerJoinRoomFailed instance using the specified properties.
         * @function create
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {NT.IServerJoinRoomFailed=} [properties] Properties to set
         * @returns {NT.ServerJoinRoomFailed} ServerJoinRoomFailed instance
         */
        ServerJoinRoomFailed.create = function create(properties) {
            return new ServerJoinRoomFailed(properties);
        };

        /**
         * Encodes the specified ServerJoinRoomFailed message. Does not implicitly {@link NT.ServerJoinRoomFailed.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {NT.IServerJoinRoomFailed} message ServerJoinRoomFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerJoinRoomFailed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.reason != null && Object.hasOwnProperty.call(message, "reason"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.reason);
            return writer;
        };

        /**
         * Encodes the specified ServerJoinRoomFailed message, length delimited. Does not implicitly {@link NT.ServerJoinRoomFailed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {NT.IServerJoinRoomFailed} message ServerJoinRoomFailed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerJoinRoomFailed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerJoinRoomFailed message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerJoinRoomFailed} ServerJoinRoomFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerJoinRoomFailed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerJoinRoomFailed();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.reason = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerJoinRoomFailed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerJoinRoomFailed} ServerJoinRoomFailed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerJoinRoomFailed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerJoinRoomFailed message.
         * @function verify
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerJoinRoomFailed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.reason != null && message.hasOwnProperty("reason"))
                if (!$util.isString(message.reason))
                    return "reason: string expected";
            return null;
        };

        /**
         * Creates a ServerJoinRoomFailed message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerJoinRoomFailed} ServerJoinRoomFailed
         */
        ServerJoinRoomFailed.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerJoinRoomFailed)
                return object;
            let message = new $root.NT.ServerJoinRoomFailed();
            if (object.reason != null)
                message.reason = String(object.reason);
            return message;
        };

        /**
         * Creates a plain object from a ServerJoinRoomFailed message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {NT.ServerJoinRoomFailed} message ServerJoinRoomFailed
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerJoinRoomFailed.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.reason = "";
            if (message.reason != null && message.hasOwnProperty("reason"))
                object.reason = message.reason;
            return object;
        };

        /**
         * Converts this ServerJoinRoomFailed to JSON.
         * @function toJSON
         * @memberof NT.ServerJoinRoomFailed
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerJoinRoomFailed.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerJoinRoomFailed
         * @function getTypeUrl
         * @memberof NT.ServerJoinRoomFailed
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerJoinRoomFailed.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerJoinRoomFailed";
        };

        return ServerJoinRoomFailed;
    })();

    NT.ServerUserJoinedRoom = (function() {

        /**
         * Properties of a ServerUserJoinedRoom.
         * @memberof NT
         * @interface IServerUserJoinedRoom
         * @property {string|null} [userId] ServerUserJoinedRoom userId
         * @property {string|null} [name] ServerUserJoinedRoom name
         */

        /**
         * Constructs a new ServerUserJoinedRoom.
         * @memberof NT
         * @classdesc Represents a ServerUserJoinedRoom.
         * @implements IServerUserJoinedRoom
         * @constructor
         * @param {NT.IServerUserJoinedRoom=} [properties] Properties to set
         */
        function ServerUserJoinedRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerUserJoinedRoom userId.
         * @member {string} userId
         * @memberof NT.ServerUserJoinedRoom
         * @instance
         */
        ServerUserJoinedRoom.prototype.userId = "";

        /**
         * ServerUserJoinedRoom name.
         * @member {string} name
         * @memberof NT.ServerUserJoinedRoom
         * @instance
         */
        ServerUserJoinedRoom.prototype.name = "";

        /**
         * Creates a new ServerUserJoinedRoom instance using the specified properties.
         * @function create
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {NT.IServerUserJoinedRoom=} [properties] Properties to set
         * @returns {NT.ServerUserJoinedRoom} ServerUserJoinedRoom instance
         */
        ServerUserJoinedRoom.create = function create(properties) {
            return new ServerUserJoinedRoom(properties);
        };

        /**
         * Encodes the specified ServerUserJoinedRoom message. Does not implicitly {@link NT.ServerUserJoinedRoom.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {NT.IServerUserJoinedRoom} message ServerUserJoinedRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserJoinedRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ServerUserJoinedRoom message, length delimited. Does not implicitly {@link NT.ServerUserJoinedRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {NT.IServerUserJoinedRoom} message ServerUserJoinedRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserJoinedRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerUserJoinedRoom message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerUserJoinedRoom} ServerUserJoinedRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserJoinedRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerUserJoinedRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.name = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerUserJoinedRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerUserJoinedRoom} ServerUserJoinedRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserJoinedRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerUserJoinedRoom message.
         * @function verify
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerUserJoinedRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        /**
         * Creates a ServerUserJoinedRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerUserJoinedRoom} ServerUserJoinedRoom
         */
        ServerUserJoinedRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerUserJoinedRoom)
                return object;
            let message = new $root.NT.ServerUserJoinedRoom();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.name != null)
                message.name = String(object.name);
            return message;
        };

        /**
         * Creates a plain object from a ServerUserJoinedRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {NT.ServerUserJoinedRoom} message ServerUserJoinedRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerUserJoinedRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.userId = "";
                object.name = "";
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            return object;
        };

        /**
         * Converts this ServerUserJoinedRoom to JSON.
         * @function toJSON
         * @memberof NT.ServerUserJoinedRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerUserJoinedRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerUserJoinedRoom
         * @function getTypeUrl
         * @memberof NT.ServerUserJoinedRoom
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerUserJoinedRoom.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerUserJoinedRoom";
        };

        return ServerUserJoinedRoom;
    })();

    NT.ClientLeaveRoom = (function() {

        /**
         * Properties of a ClientLeaveRoom.
         * @memberof NT
         * @interface IClientLeaveRoom
         * @property {string|null} [userId] ClientLeaveRoom userId
         */

        /**
         * Constructs a new ClientLeaveRoom.
         * @memberof NT
         * @classdesc Represents a ClientLeaveRoom.
         * @implements IClientLeaveRoom
         * @constructor
         * @param {NT.IClientLeaveRoom=} [properties] Properties to set
         */
        function ClientLeaveRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientLeaveRoom userId.
         * @member {string} userId
         * @memberof NT.ClientLeaveRoom
         * @instance
         */
        ClientLeaveRoom.prototype.userId = "";

        /**
         * Creates a new ClientLeaveRoom instance using the specified properties.
         * @function create
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {NT.IClientLeaveRoom=} [properties] Properties to set
         * @returns {NT.ClientLeaveRoom} ClientLeaveRoom instance
         */
        ClientLeaveRoom.create = function create(properties) {
            return new ClientLeaveRoom(properties);
        };

        /**
         * Encodes the specified ClientLeaveRoom message. Does not implicitly {@link NT.ClientLeaveRoom.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {NT.IClientLeaveRoom} message ClientLeaveRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLeaveRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ClientLeaveRoom message, length delimited. Does not implicitly {@link NT.ClientLeaveRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {NT.IClientLeaveRoom} message ClientLeaveRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLeaveRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientLeaveRoom message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientLeaveRoom} ClientLeaveRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLeaveRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientLeaveRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientLeaveRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientLeaveRoom} ClientLeaveRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLeaveRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientLeaveRoom message.
         * @function verify
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientLeaveRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ClientLeaveRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientLeaveRoom} ClientLeaveRoom
         */
        ClientLeaveRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientLeaveRoom)
                return object;
            let message = new $root.NT.ClientLeaveRoom();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ClientLeaveRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {NT.ClientLeaveRoom} message ClientLeaveRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientLeaveRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ClientLeaveRoom to JSON.
         * @function toJSON
         * @memberof NT.ClientLeaveRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientLeaveRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientLeaveRoom
         * @function getTypeUrl
         * @memberof NT.ClientLeaveRoom
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientLeaveRoom.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientLeaveRoom";
        };

        return ClientLeaveRoom;
    })();

    NT.ServerUserLeftRoom = (function() {

        /**
         * Properties of a ServerUserLeftRoom.
         * @memberof NT
         * @interface IServerUserLeftRoom
         * @property {string|null} [userId] ServerUserLeftRoom userId
         */

        /**
         * Constructs a new ServerUserLeftRoom.
         * @memberof NT
         * @classdesc Represents a ServerUserLeftRoom.
         * @implements IServerUserLeftRoom
         * @constructor
         * @param {NT.IServerUserLeftRoom=} [properties] Properties to set
         */
        function ServerUserLeftRoom(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerUserLeftRoom userId.
         * @member {string} userId
         * @memberof NT.ServerUserLeftRoom
         * @instance
         */
        ServerUserLeftRoom.prototype.userId = "";

        /**
         * Creates a new ServerUserLeftRoom instance using the specified properties.
         * @function create
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {NT.IServerUserLeftRoom=} [properties] Properties to set
         * @returns {NT.ServerUserLeftRoom} ServerUserLeftRoom instance
         */
        ServerUserLeftRoom.create = function create(properties) {
            return new ServerUserLeftRoom(properties);
        };

        /**
         * Encodes the specified ServerUserLeftRoom message. Does not implicitly {@link NT.ServerUserLeftRoom.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {NT.IServerUserLeftRoom} message ServerUserLeftRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserLeftRoom.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ServerUserLeftRoom message, length delimited. Does not implicitly {@link NT.ServerUserLeftRoom.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {NT.IServerUserLeftRoom} message ServerUserLeftRoom message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserLeftRoom.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerUserLeftRoom message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerUserLeftRoom} ServerUserLeftRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserLeftRoom.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerUserLeftRoom();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerUserLeftRoom message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerUserLeftRoom} ServerUserLeftRoom
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserLeftRoom.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerUserLeftRoom message.
         * @function verify
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerUserLeftRoom.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ServerUserLeftRoom message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerUserLeftRoom} ServerUserLeftRoom
         */
        ServerUserLeftRoom.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerUserLeftRoom)
                return object;
            let message = new $root.NT.ServerUserLeftRoom();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ServerUserLeftRoom message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {NT.ServerUserLeftRoom} message ServerUserLeftRoom
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerUserLeftRoom.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ServerUserLeftRoom to JSON.
         * @function toJSON
         * @memberof NT.ServerUserLeftRoom
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerUserLeftRoom.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerUserLeftRoom
         * @function getTypeUrl
         * @memberof NT.ServerUserLeftRoom
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerUserLeftRoom.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerUserLeftRoom";
        };

        return ServerUserLeftRoom;
    })();

    NT.ClientKickUser = (function() {

        /**
         * Properties of a ClientKickUser.
         * @memberof NT
         * @interface IClientKickUser
         * @property {string|null} [userId] ClientKickUser userId
         */

        /**
         * Constructs a new ClientKickUser.
         * @memberof NT
         * @classdesc Represents a ClientKickUser.
         * @implements IClientKickUser
         * @constructor
         * @param {NT.IClientKickUser=} [properties] Properties to set
         */
        function ClientKickUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientKickUser userId.
         * @member {string} userId
         * @memberof NT.ClientKickUser
         * @instance
         */
        ClientKickUser.prototype.userId = "";

        /**
         * Creates a new ClientKickUser instance using the specified properties.
         * @function create
         * @memberof NT.ClientKickUser
         * @static
         * @param {NT.IClientKickUser=} [properties] Properties to set
         * @returns {NT.ClientKickUser} ClientKickUser instance
         */
        ClientKickUser.create = function create(properties) {
            return new ClientKickUser(properties);
        };

        /**
         * Encodes the specified ClientKickUser message. Does not implicitly {@link NT.ClientKickUser.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientKickUser
         * @static
         * @param {NT.IClientKickUser} message ClientKickUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientKickUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ClientKickUser message, length delimited. Does not implicitly {@link NT.ClientKickUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientKickUser
         * @static
         * @param {NT.IClientKickUser} message ClientKickUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientKickUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientKickUser message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientKickUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientKickUser} ClientKickUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientKickUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientKickUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientKickUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientKickUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientKickUser} ClientKickUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientKickUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientKickUser message.
         * @function verify
         * @memberof NT.ClientKickUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientKickUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ClientKickUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientKickUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientKickUser} ClientKickUser
         */
        ClientKickUser.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientKickUser)
                return object;
            let message = new $root.NT.ClientKickUser();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ClientKickUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientKickUser
         * @static
         * @param {NT.ClientKickUser} message ClientKickUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientKickUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ClientKickUser to JSON.
         * @function toJSON
         * @memberof NT.ClientKickUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientKickUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientKickUser
         * @function getTypeUrl
         * @memberof NT.ClientKickUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientKickUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientKickUser";
        };

        return ClientKickUser;
    })();

    NT.ServerUserKicked = (function() {

        /**
         * Properties of a ServerUserKicked.
         * @memberof NT
         * @interface IServerUserKicked
         * @property {string|null} [userId] ServerUserKicked userId
         */

        /**
         * Constructs a new ServerUserKicked.
         * @memberof NT
         * @classdesc Represents a ServerUserKicked.
         * @implements IServerUserKicked
         * @constructor
         * @param {NT.IServerUserKicked=} [properties] Properties to set
         */
        function ServerUserKicked(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerUserKicked userId.
         * @member {string} userId
         * @memberof NT.ServerUserKicked
         * @instance
         */
        ServerUserKicked.prototype.userId = "";

        /**
         * Creates a new ServerUserKicked instance using the specified properties.
         * @function create
         * @memberof NT.ServerUserKicked
         * @static
         * @param {NT.IServerUserKicked=} [properties] Properties to set
         * @returns {NT.ServerUserKicked} ServerUserKicked instance
         */
        ServerUserKicked.create = function create(properties) {
            return new ServerUserKicked(properties);
        };

        /**
         * Encodes the specified ServerUserKicked message. Does not implicitly {@link NT.ServerUserKicked.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerUserKicked
         * @static
         * @param {NT.IServerUserKicked} message ServerUserKicked message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserKicked.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ServerUserKicked message, length delimited. Does not implicitly {@link NT.ServerUserKicked.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerUserKicked
         * @static
         * @param {NT.IServerUserKicked} message ServerUserKicked message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserKicked.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerUserKicked message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerUserKicked
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerUserKicked} ServerUserKicked
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserKicked.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerUserKicked();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerUserKicked message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerUserKicked
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerUserKicked} ServerUserKicked
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserKicked.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerUserKicked message.
         * @function verify
         * @memberof NT.ServerUserKicked
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerUserKicked.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ServerUserKicked message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerUserKicked
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerUserKicked} ServerUserKicked
         */
        ServerUserKicked.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerUserKicked)
                return object;
            let message = new $root.NT.ServerUserKicked();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ServerUserKicked message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerUserKicked
         * @static
         * @param {NT.ServerUserKicked} message ServerUserKicked
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerUserKicked.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ServerUserKicked to JSON.
         * @function toJSON
         * @memberof NT.ServerUserKicked
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerUserKicked.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerUserKicked
         * @function getTypeUrl
         * @memberof NT.ServerUserKicked
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerUserKicked.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerUserKicked";
        };

        return ServerUserKicked;
    })();

    NT.ClientBanUser = (function() {

        /**
         * Properties of a ClientBanUser.
         * @memberof NT
         * @interface IClientBanUser
         * @property {string|null} [userId] ClientBanUser userId
         */

        /**
         * Constructs a new ClientBanUser.
         * @memberof NT
         * @classdesc Represents a ClientBanUser.
         * @implements IClientBanUser
         * @constructor
         * @param {NT.IClientBanUser=} [properties] Properties to set
         */
        function ClientBanUser(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientBanUser userId.
         * @member {string} userId
         * @memberof NT.ClientBanUser
         * @instance
         */
        ClientBanUser.prototype.userId = "";

        /**
         * Creates a new ClientBanUser instance using the specified properties.
         * @function create
         * @memberof NT.ClientBanUser
         * @static
         * @param {NT.IClientBanUser=} [properties] Properties to set
         * @returns {NT.ClientBanUser} ClientBanUser instance
         */
        ClientBanUser.create = function create(properties) {
            return new ClientBanUser(properties);
        };

        /**
         * Encodes the specified ClientBanUser message. Does not implicitly {@link NT.ClientBanUser.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientBanUser
         * @static
         * @param {NT.IClientBanUser} message ClientBanUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientBanUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ClientBanUser message, length delimited. Does not implicitly {@link NT.ClientBanUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientBanUser
         * @static
         * @param {NT.IClientBanUser} message ClientBanUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientBanUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientBanUser message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientBanUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientBanUser} ClientBanUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientBanUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientBanUser();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientBanUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientBanUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientBanUser} ClientBanUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientBanUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientBanUser message.
         * @function verify
         * @memberof NT.ClientBanUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientBanUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ClientBanUser message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientBanUser
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientBanUser} ClientBanUser
         */
        ClientBanUser.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientBanUser)
                return object;
            let message = new $root.NT.ClientBanUser();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ClientBanUser message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientBanUser
         * @static
         * @param {NT.ClientBanUser} message ClientBanUser
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientBanUser.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ClientBanUser to JSON.
         * @function toJSON
         * @memberof NT.ClientBanUser
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientBanUser.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientBanUser
         * @function getTypeUrl
         * @memberof NT.ClientBanUser
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientBanUser.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientBanUser";
        };

        return ClientBanUser;
    })();

    NT.ServerUserBanned = (function() {

        /**
         * Properties of a ServerUserBanned.
         * @memberof NT
         * @interface IServerUserBanned
         * @property {string|null} [userId] ServerUserBanned userId
         */

        /**
         * Constructs a new ServerUserBanned.
         * @memberof NT
         * @classdesc Represents a ServerUserBanned.
         * @implements IServerUserBanned
         * @constructor
         * @param {NT.IServerUserBanned=} [properties] Properties to set
         */
        function ServerUserBanned(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerUserBanned userId.
         * @member {string} userId
         * @memberof NT.ServerUserBanned
         * @instance
         */
        ServerUserBanned.prototype.userId = "";

        /**
         * Creates a new ServerUserBanned instance using the specified properties.
         * @function create
         * @memberof NT.ServerUserBanned
         * @static
         * @param {NT.IServerUserBanned=} [properties] Properties to set
         * @returns {NT.ServerUserBanned} ServerUserBanned instance
         */
        ServerUserBanned.create = function create(properties) {
            return new ServerUserBanned(properties);
        };

        /**
         * Encodes the specified ServerUserBanned message. Does not implicitly {@link NT.ServerUserBanned.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerUserBanned
         * @static
         * @param {NT.IServerUserBanned} message ServerUserBanned message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserBanned.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            return writer;
        };

        /**
         * Encodes the specified ServerUserBanned message, length delimited. Does not implicitly {@link NT.ServerUserBanned.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerUserBanned
         * @static
         * @param {NT.IServerUserBanned} message ServerUserBanned message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserBanned.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerUserBanned message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerUserBanned
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerUserBanned} ServerUserBanned
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserBanned.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerUserBanned();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerUserBanned message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerUserBanned
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerUserBanned} ServerUserBanned
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserBanned.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerUserBanned message.
         * @function verify
         * @memberof NT.ServerUserBanned
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerUserBanned.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            return null;
        };

        /**
         * Creates a ServerUserBanned message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerUserBanned
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerUserBanned} ServerUserBanned
         */
        ServerUserBanned.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerUserBanned)
                return object;
            let message = new $root.NT.ServerUserBanned();
            if (object.userId != null)
                message.userId = String(object.userId);
            return message;
        };

        /**
         * Creates a plain object from a ServerUserBanned message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerUserBanned
         * @static
         * @param {NT.ServerUserBanned} message ServerUserBanned
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerUserBanned.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.userId = "";
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            return object;
        };

        /**
         * Converts this ServerUserBanned to JSON.
         * @function toJSON
         * @memberof NT.ServerUserBanned
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerUserBanned.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerUserBanned
         * @function getTypeUrl
         * @memberof NT.ServerUserBanned
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerUserBanned.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerUserBanned";
        };

        return ServerUserBanned;
    })();

    NT.ClientReadyState = (function() {

        /**
         * Properties of a ClientReadyState.
         * @memberof NT
         * @interface IClientReadyState
         * @property {boolean|null} [ready] ClientReadyState ready
         * @property {string|null} [seed] ClientReadyState seed
         * @property {Array.<string>|null} [mods] ClientReadyState mods
         * @property {string|null} [version] ClientReadyState version
         * @property {boolean|null} [beta] ClientReadyState beta
         */

        /**
         * Constructs a new ClientReadyState.
         * @memberof NT
         * @classdesc Represents a ClientReadyState.
         * @implements IClientReadyState
         * @constructor
         * @param {NT.IClientReadyState=} [properties] Properties to set
         */
        function ClientReadyState(properties) {
            this.mods = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientReadyState ready.
         * @member {boolean} ready
         * @memberof NT.ClientReadyState
         * @instance
         */
        ClientReadyState.prototype.ready = false;

        /**
         * ClientReadyState seed.
         * @member {string|null|undefined} seed
         * @memberof NT.ClientReadyState
         * @instance
         */
        ClientReadyState.prototype.seed = null;

        /**
         * ClientReadyState mods.
         * @member {Array.<string>} mods
         * @memberof NT.ClientReadyState
         * @instance
         */
        ClientReadyState.prototype.mods = $util.emptyArray;

        /**
         * ClientReadyState version.
         * @member {string|null|undefined} version
         * @memberof NT.ClientReadyState
         * @instance
         */
        ClientReadyState.prototype.version = null;

        /**
         * ClientReadyState beta.
         * @member {boolean|null|undefined} beta
         * @memberof NT.ClientReadyState
         * @instance
         */
        ClientReadyState.prototype.beta = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ClientReadyState _seed.
         * @member {"seed"|undefined} _seed
         * @memberof NT.ClientReadyState
         * @instance
         */
        Object.defineProperty(ClientReadyState.prototype, "_seed", {
            get: $util.oneOfGetter($oneOfFields = ["seed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientReadyState _version.
         * @member {"version"|undefined} _version
         * @memberof NT.ClientReadyState
         * @instance
         */
        Object.defineProperty(ClientReadyState.prototype, "_version", {
            get: $util.oneOfGetter($oneOfFields = ["version"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ClientReadyState _beta.
         * @member {"beta"|undefined} _beta
         * @memberof NT.ClientReadyState
         * @instance
         */
        Object.defineProperty(ClientReadyState.prototype, "_beta", {
            get: $util.oneOfGetter($oneOfFields = ["beta"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ClientReadyState instance using the specified properties.
         * @function create
         * @memberof NT.ClientReadyState
         * @static
         * @param {NT.IClientReadyState=} [properties] Properties to set
         * @returns {NT.ClientReadyState} ClientReadyState instance
         */
        ClientReadyState.create = function create(properties) {
            return new ClientReadyState(properties);
        };

        /**
         * Encodes the specified ClientReadyState message. Does not implicitly {@link NT.ClientReadyState.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientReadyState
         * @static
         * @param {NT.IClientReadyState} message ClientReadyState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientReadyState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ready);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.seed);
            if (message.mods != null && message.mods.length)
                for (let i = 0; i < message.mods.length; ++i)
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.mods[i]);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.version);
            if (message.beta != null && Object.hasOwnProperty.call(message, "beta"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.beta);
            return writer;
        };

        /**
         * Encodes the specified ClientReadyState message, length delimited. Does not implicitly {@link NT.ClientReadyState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientReadyState
         * @static
         * @param {NT.IClientReadyState} message ClientReadyState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientReadyState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientReadyState message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientReadyState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientReadyState} ClientReadyState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientReadyState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientReadyState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.ready = reader.bool();
                        break;
                    }
                case 2: {
                        message.seed = reader.string();
                        break;
                    }
                case 3: {
                        if (!(message.mods && message.mods.length))
                            message.mods = [];
                        message.mods.push(reader.string());
                        break;
                    }
                case 4: {
                        message.version = reader.string();
                        break;
                    }
                case 5: {
                        message.beta = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientReadyState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientReadyState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientReadyState} ClientReadyState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientReadyState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientReadyState message.
         * @function verify
         * @memberof NT.ClientReadyState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientReadyState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.ready != null && message.hasOwnProperty("ready"))
                if (typeof message.ready !== "boolean")
                    return "ready: boolean expected";
            if (message.seed != null && message.hasOwnProperty("seed")) {
                properties._seed = 1;
                if (!$util.isString(message.seed))
                    return "seed: string expected";
            }
            if (message.mods != null && message.hasOwnProperty("mods")) {
                if (!Array.isArray(message.mods))
                    return "mods: array expected";
                for (let i = 0; i < message.mods.length; ++i)
                    if (!$util.isString(message.mods[i]))
                        return "mods: string[] expected";
            }
            if (message.version != null && message.hasOwnProperty("version")) {
                properties._version = 1;
                if (!$util.isString(message.version))
                    return "version: string expected";
            }
            if (message.beta != null && message.hasOwnProperty("beta")) {
                properties._beta = 1;
                if (typeof message.beta !== "boolean")
                    return "beta: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ClientReadyState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientReadyState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientReadyState} ClientReadyState
         */
        ClientReadyState.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientReadyState)
                return object;
            let message = new $root.NT.ClientReadyState();
            if (object.ready != null)
                message.ready = Boolean(object.ready);
            if (object.seed != null)
                message.seed = String(object.seed);
            if (object.mods) {
                if (!Array.isArray(object.mods))
                    throw TypeError(".NT.ClientReadyState.mods: array expected");
                message.mods = [];
                for (let i = 0; i < object.mods.length; ++i)
                    message.mods[i] = String(object.mods[i]);
            }
            if (object.version != null)
                message.version = String(object.version);
            if (object.beta != null)
                message.beta = Boolean(object.beta);
            return message;
        };

        /**
         * Creates a plain object from a ClientReadyState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientReadyState
         * @static
         * @param {NT.ClientReadyState} message ClientReadyState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientReadyState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.mods = [];
            if (options.defaults)
                object.ready = false;
            if (message.ready != null && message.hasOwnProperty("ready"))
                object.ready = message.ready;
            if (message.seed != null && message.hasOwnProperty("seed")) {
                object.seed = message.seed;
                if (options.oneofs)
                    object._seed = "seed";
            }
            if (message.mods && message.mods.length) {
                object.mods = [];
                for (let j = 0; j < message.mods.length; ++j)
                    object.mods[j] = message.mods[j];
            }
            if (message.version != null && message.hasOwnProperty("version")) {
                object.version = message.version;
                if (options.oneofs)
                    object._version = "version";
            }
            if (message.beta != null && message.hasOwnProperty("beta")) {
                object.beta = message.beta;
                if (options.oneofs)
                    object._beta = "beta";
            }
            return object;
        };

        /**
         * Converts this ClientReadyState to JSON.
         * @function toJSON
         * @memberof NT.ClientReadyState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientReadyState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientReadyState
         * @function getTypeUrl
         * @memberof NT.ClientReadyState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientReadyState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientReadyState";
        };

        return ClientReadyState;
    })();

    NT.ServerUserReadyState = (function() {

        /**
         * Properties of a ServerUserReadyState.
         * @memberof NT
         * @interface IServerUserReadyState
         * @property {string|null} [userId] ServerUserReadyState userId
         * @property {boolean|null} [ready] ServerUserReadyState ready
         * @property {string|null} [seed] ServerUserReadyState seed
         * @property {Array.<string>|null} [mods] ServerUserReadyState mods
         * @property {string|null} [version] ServerUserReadyState version
         * @property {boolean|null} [beta] ServerUserReadyState beta
         */

        /**
         * Constructs a new ServerUserReadyState.
         * @memberof NT
         * @classdesc Represents a ServerUserReadyState.
         * @implements IServerUserReadyState
         * @constructor
         * @param {NT.IServerUserReadyState=} [properties] Properties to set
         */
        function ServerUserReadyState(properties) {
            this.mods = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerUserReadyState userId.
         * @member {string} userId
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.userId = "";

        /**
         * ServerUserReadyState ready.
         * @member {boolean} ready
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.ready = false;

        /**
         * ServerUserReadyState seed.
         * @member {string|null|undefined} seed
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.seed = null;

        /**
         * ServerUserReadyState mods.
         * @member {Array.<string>} mods
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.mods = $util.emptyArray;

        /**
         * ServerUserReadyState version.
         * @member {string|null|undefined} version
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.version = null;

        /**
         * ServerUserReadyState beta.
         * @member {boolean|null|undefined} beta
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        ServerUserReadyState.prototype.beta = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerUserReadyState _seed.
         * @member {"seed"|undefined} _seed
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        Object.defineProperty(ServerUserReadyState.prototype, "_seed", {
            get: $util.oneOfGetter($oneOfFields = ["seed"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerUserReadyState _version.
         * @member {"version"|undefined} _version
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        Object.defineProperty(ServerUserReadyState.prototype, "_version", {
            get: $util.oneOfGetter($oneOfFields = ["version"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * ServerUserReadyState _beta.
         * @member {"beta"|undefined} _beta
         * @memberof NT.ServerUserReadyState
         * @instance
         */
        Object.defineProperty(ServerUserReadyState.prototype, "_beta", {
            get: $util.oneOfGetter($oneOfFields = ["beta"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerUserReadyState instance using the specified properties.
         * @function create
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {NT.IServerUserReadyState=} [properties] Properties to set
         * @returns {NT.ServerUserReadyState} ServerUserReadyState instance
         */
        ServerUserReadyState.create = function create(properties) {
            return new ServerUserReadyState(properties);
        };

        /**
         * Encodes the specified ServerUserReadyState message. Does not implicitly {@link NT.ServerUserReadyState.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {NT.IServerUserReadyState} message ServerUserReadyState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserReadyState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.userId != null && Object.hasOwnProperty.call(message, "userId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.userId);
            if (message.ready != null && Object.hasOwnProperty.call(message, "ready"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ready);
            if (message.seed != null && Object.hasOwnProperty.call(message, "seed"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.seed);
            if (message.mods != null && message.mods.length)
                for (let i = 0; i < message.mods.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.mods[i]);
            if (message.version != null && Object.hasOwnProperty.call(message, "version"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.version);
            if (message.beta != null && Object.hasOwnProperty.call(message, "beta"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.beta);
            return writer;
        };

        /**
         * Encodes the specified ServerUserReadyState message, length delimited. Does not implicitly {@link NT.ServerUserReadyState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {NT.IServerUserReadyState} message ServerUserReadyState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerUserReadyState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerUserReadyState message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerUserReadyState} ServerUserReadyState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserReadyState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerUserReadyState();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.userId = reader.string();
                        break;
                    }
                case 2: {
                        message.ready = reader.bool();
                        break;
                    }
                case 3: {
                        message.seed = reader.string();
                        break;
                    }
                case 4: {
                        if (!(message.mods && message.mods.length))
                            message.mods = [];
                        message.mods.push(reader.string());
                        break;
                    }
                case 5: {
                        message.version = reader.string();
                        break;
                    }
                case 6: {
                        message.beta = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerUserReadyState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerUserReadyState} ServerUserReadyState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerUserReadyState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerUserReadyState message.
         * @function verify
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerUserReadyState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.userId != null && message.hasOwnProperty("userId"))
                if (!$util.isString(message.userId))
                    return "userId: string expected";
            if (message.ready != null && message.hasOwnProperty("ready"))
                if (typeof message.ready !== "boolean")
                    return "ready: boolean expected";
            if (message.seed != null && message.hasOwnProperty("seed")) {
                properties._seed = 1;
                if (!$util.isString(message.seed))
                    return "seed: string expected";
            }
            if (message.mods != null && message.hasOwnProperty("mods")) {
                if (!Array.isArray(message.mods))
                    return "mods: array expected";
                for (let i = 0; i < message.mods.length; ++i)
                    if (!$util.isString(message.mods[i]))
                        return "mods: string[] expected";
            }
            if (message.version != null && message.hasOwnProperty("version")) {
                properties._version = 1;
                if (!$util.isString(message.version))
                    return "version: string expected";
            }
            if (message.beta != null && message.hasOwnProperty("beta")) {
                properties._beta = 1;
                if (typeof message.beta !== "boolean")
                    return "beta: boolean expected";
            }
            return null;
        };

        /**
         * Creates a ServerUserReadyState message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerUserReadyState} ServerUserReadyState
         */
        ServerUserReadyState.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerUserReadyState)
                return object;
            let message = new $root.NT.ServerUserReadyState();
            if (object.userId != null)
                message.userId = String(object.userId);
            if (object.ready != null)
                message.ready = Boolean(object.ready);
            if (object.seed != null)
                message.seed = String(object.seed);
            if (object.mods) {
                if (!Array.isArray(object.mods))
                    throw TypeError(".NT.ServerUserReadyState.mods: array expected");
                message.mods = [];
                for (let i = 0; i < object.mods.length; ++i)
                    message.mods[i] = String(object.mods[i]);
            }
            if (object.version != null)
                message.version = String(object.version);
            if (object.beta != null)
                message.beta = Boolean(object.beta);
            return message;
        };

        /**
         * Creates a plain object from a ServerUserReadyState message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {NT.ServerUserReadyState} message ServerUserReadyState
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerUserReadyState.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.mods = [];
            if (options.defaults) {
                object.userId = "";
                object.ready = false;
            }
            if (message.userId != null && message.hasOwnProperty("userId"))
                object.userId = message.userId;
            if (message.ready != null && message.hasOwnProperty("ready"))
                object.ready = message.ready;
            if (message.seed != null && message.hasOwnProperty("seed")) {
                object.seed = message.seed;
                if (options.oneofs)
                    object._seed = "seed";
            }
            if (message.mods && message.mods.length) {
                object.mods = [];
                for (let j = 0; j < message.mods.length; ++j)
                    object.mods[j] = message.mods[j];
            }
            if (message.version != null && message.hasOwnProperty("version")) {
                object.version = message.version;
                if (options.oneofs)
                    object._version = "version";
            }
            if (message.beta != null && message.hasOwnProperty("beta")) {
                object.beta = message.beta;
                if (options.oneofs)
                    object._beta = "beta";
            }
            return object;
        };

        /**
         * Converts this ServerUserReadyState to JSON.
         * @function toJSON
         * @memberof NT.ServerUserReadyState
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerUserReadyState.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerUserReadyState
         * @function getTypeUrl
         * @memberof NT.ServerUserReadyState
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerUserReadyState.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerUserReadyState";
        };

        return ServerUserReadyState;
    })();

    NT.ClientStartRun = (function() {

        /**
         * Properties of a ClientStartRun.
         * @memberof NT
         * @interface IClientStartRun
         * @property {boolean|null} [forced] ClientStartRun forced
         */

        /**
         * Constructs a new ClientStartRun.
         * @memberof NT
         * @classdesc Represents a ClientStartRun.
         * @implements IClientStartRun
         * @constructor
         * @param {NT.IClientStartRun=} [properties] Properties to set
         */
        function ClientStartRun(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientStartRun forced.
         * @member {boolean} forced
         * @memberof NT.ClientStartRun
         * @instance
         */
        ClientStartRun.prototype.forced = false;

        /**
         * Creates a new ClientStartRun instance using the specified properties.
         * @function create
         * @memberof NT.ClientStartRun
         * @static
         * @param {NT.IClientStartRun=} [properties] Properties to set
         * @returns {NT.ClientStartRun} ClientStartRun instance
         */
        ClientStartRun.create = function create(properties) {
            return new ClientStartRun(properties);
        };

        /**
         * Encodes the specified ClientStartRun message. Does not implicitly {@link NT.ClientStartRun.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientStartRun
         * @static
         * @param {NT.IClientStartRun} message ClientStartRun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientStartRun.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forced != null && Object.hasOwnProperty.call(message, "forced"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.forced);
            return writer;
        };

        /**
         * Encodes the specified ClientStartRun message, length delimited. Does not implicitly {@link NT.ClientStartRun.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientStartRun
         * @static
         * @param {NT.IClientStartRun} message ClientStartRun message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientStartRun.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientStartRun message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientStartRun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientStartRun} ClientStartRun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientStartRun.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientStartRun();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.forced = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientStartRun message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientStartRun
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientStartRun} ClientStartRun
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientStartRun.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientStartRun message.
         * @function verify
         * @memberof NT.ClientStartRun
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientStartRun.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forced != null && message.hasOwnProperty("forced"))
                if (typeof message.forced !== "boolean")
                    return "forced: boolean expected";
            return null;
        };

        /**
         * Creates a ClientStartRun message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientStartRun
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientStartRun} ClientStartRun
         */
        ClientStartRun.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientStartRun)
                return object;
            let message = new $root.NT.ClientStartRun();
            if (object.forced != null)
                message.forced = Boolean(object.forced);
            return message;
        };

        /**
         * Creates a plain object from a ClientStartRun message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientStartRun
         * @static
         * @param {NT.ClientStartRun} message ClientStartRun
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientStartRun.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.forced = false;
            if (message.forced != null && message.hasOwnProperty("forced"))
                object.forced = message.forced;
            return object;
        };

        /**
         * Converts this ClientStartRun to JSON.
         * @function toJSON
         * @memberof NT.ClientStartRun
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientStartRun.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientStartRun
         * @function getTypeUrl
         * @memberof NT.ClientStartRun
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientStartRun.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientStartRun";
        };

        return ClientStartRun;
    })();

    NT.ServerHostStart = (function() {

        /**
         * Properties of a ServerHostStart.
         * @memberof NT
         * @interface IServerHostStart
         * @property {boolean|null} [forced] ServerHostStart forced
         */

        /**
         * Constructs a new ServerHostStart.
         * @memberof NT
         * @classdesc Represents a ServerHostStart.
         * @implements IServerHostStart
         * @constructor
         * @param {NT.IServerHostStart=} [properties] Properties to set
         */
        function ServerHostStart(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerHostStart forced.
         * @member {boolean} forced
         * @memberof NT.ServerHostStart
         * @instance
         */
        ServerHostStart.prototype.forced = false;

        /**
         * Creates a new ServerHostStart instance using the specified properties.
         * @function create
         * @memberof NT.ServerHostStart
         * @static
         * @param {NT.IServerHostStart=} [properties] Properties to set
         * @returns {NT.ServerHostStart} ServerHostStart instance
         */
        ServerHostStart.create = function create(properties) {
            return new ServerHostStart(properties);
        };

        /**
         * Encodes the specified ServerHostStart message. Does not implicitly {@link NT.ServerHostStart.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerHostStart
         * @static
         * @param {NT.IServerHostStart} message ServerHostStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostStart.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.forced != null && Object.hasOwnProperty.call(message, "forced"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.forced);
            return writer;
        };

        /**
         * Encodes the specified ServerHostStart message, length delimited. Does not implicitly {@link NT.ServerHostStart.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerHostStart
         * @static
         * @param {NT.IServerHostStart} message ServerHostStart message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerHostStart.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerHostStart message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerHostStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerHostStart} ServerHostStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostStart.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerHostStart();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.forced = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerHostStart message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerHostStart
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerHostStart} ServerHostStart
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerHostStart.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerHostStart message.
         * @function verify
         * @memberof NT.ServerHostStart
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerHostStart.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.forced != null && message.hasOwnProperty("forced"))
                if (typeof message.forced !== "boolean")
                    return "forced: boolean expected";
            return null;
        };

        /**
         * Creates a ServerHostStart message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerHostStart
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerHostStart} ServerHostStart
         */
        ServerHostStart.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerHostStart)
                return object;
            let message = new $root.NT.ServerHostStart();
            if (object.forced != null)
                message.forced = Boolean(object.forced);
            return message;
        };

        /**
         * Creates a plain object from a ServerHostStart message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerHostStart
         * @static
         * @param {NT.ServerHostStart} message ServerHostStart
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerHostStart.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.forced = false;
            if (message.forced != null && message.hasOwnProperty("forced"))
                object.forced = message.forced;
            return object;
        };

        /**
         * Converts this ServerHostStart to JSON.
         * @function toJSON
         * @memberof NT.ServerHostStart
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerHostStart.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerHostStart
         * @function getTypeUrl
         * @memberof NT.ServerHostStart
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerHostStart.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerHostStart";
        };

        return ServerHostStart;
    })();

    NT.ClientRequestRoomList = (function() {

        /**
         * Properties of a ClientRequestRoomList.
         * @memberof NT
         * @interface IClientRequestRoomList
         * @property {number|null} [page] ClientRequestRoomList page
         */

        /**
         * Constructs a new ClientRequestRoomList.
         * @memberof NT
         * @classdesc Represents a ClientRequestRoomList.
         * @implements IClientRequestRoomList
         * @constructor
         * @param {NT.IClientRequestRoomList=} [properties] Properties to set
         */
        function ClientRequestRoomList(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientRequestRoomList page.
         * @member {number} page
         * @memberof NT.ClientRequestRoomList
         * @instance
         */
        ClientRequestRoomList.prototype.page = 0;

        /**
         * Creates a new ClientRequestRoomList instance using the specified properties.
         * @function create
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {NT.IClientRequestRoomList=} [properties] Properties to set
         * @returns {NT.ClientRequestRoomList} ClientRequestRoomList instance
         */
        ClientRequestRoomList.create = function create(properties) {
            return new ClientRequestRoomList(properties);
        };

        /**
         * Encodes the specified ClientRequestRoomList message. Does not implicitly {@link NT.ClientRequestRoomList.verify|verify} messages.
         * @function encode
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {NT.IClientRequestRoomList} message ClientRequestRoomList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRequestRoomList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.page);
            return writer;
        };

        /**
         * Encodes the specified ClientRequestRoomList message, length delimited. Does not implicitly {@link NT.ClientRequestRoomList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {NT.IClientRequestRoomList} message ClientRequestRoomList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientRequestRoomList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientRequestRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ClientRequestRoomList} ClientRequestRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRequestRoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ClientRequestRoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.page = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientRequestRoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ClientRequestRoomList} ClientRequestRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientRequestRoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientRequestRoomList message.
         * @function verify
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientRequestRoomList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.page != null && message.hasOwnProperty("page"))
                if (!$util.isInteger(message.page))
                    return "page: integer expected";
            return null;
        };

        /**
         * Creates a ClientRequestRoomList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ClientRequestRoomList} ClientRequestRoomList
         */
        ClientRequestRoomList.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ClientRequestRoomList)
                return object;
            let message = new $root.NT.ClientRequestRoomList();
            if (object.page != null)
                message.page = object.page >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ClientRequestRoomList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {NT.ClientRequestRoomList} message ClientRequestRoomList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientRequestRoomList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.page = 0;
            if (message.page != null && message.hasOwnProperty("page"))
                object.page = message.page;
            return object;
        };

        /**
         * Converts this ClientRequestRoomList to JSON.
         * @function toJSON
         * @memberof NT.ClientRequestRoomList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientRequestRoomList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientRequestRoomList
         * @function getTypeUrl
         * @memberof NT.ClientRequestRoomList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientRequestRoomList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ClientRequestRoomList";
        };

        return ClientRequestRoomList;
    })();

    NT.ServerRoomList = (function() {

        /**
         * Properties of a ServerRoomList.
         * @memberof NT
         * @interface IServerRoomList
         * @property {Array.<NT.ServerRoomList.IRoom>|null} [rooms] ServerRoomList rooms
         * @property {number|null} [pages] ServerRoomList pages
         */

        /**
         * Constructs a new ServerRoomList.
         * @memberof NT
         * @classdesc Represents a ServerRoomList.
         * @implements IServerRoomList
         * @constructor
         * @param {NT.IServerRoomList=} [properties] Properties to set
         */
        function ServerRoomList(properties) {
            this.rooms = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomList rooms.
         * @member {Array.<NT.ServerRoomList.IRoom>} rooms
         * @memberof NT.ServerRoomList
         * @instance
         */
        ServerRoomList.prototype.rooms = $util.emptyArray;

        /**
         * ServerRoomList pages.
         * @member {number|null|undefined} pages
         * @memberof NT.ServerRoomList
         * @instance
         */
        ServerRoomList.prototype.pages = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * ServerRoomList _pages.
         * @member {"pages"|undefined} _pages
         * @memberof NT.ServerRoomList
         * @instance
         */
        Object.defineProperty(ServerRoomList.prototype, "_pages", {
            get: $util.oneOfGetter($oneOfFields = ["pages"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ServerRoomList instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomList
         * @static
         * @param {NT.IServerRoomList=} [properties] Properties to set
         * @returns {NT.ServerRoomList} ServerRoomList instance
         */
        ServerRoomList.create = function create(properties) {
            return new ServerRoomList(properties);
        };

        /**
         * Encodes the specified ServerRoomList message. Does not implicitly {@link NT.ServerRoomList.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomList
         * @static
         * @param {NT.IServerRoomList} message ServerRoomList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rooms != null && message.rooms.length)
                for (let i = 0; i < message.rooms.length; ++i)
                    $root.NT.ServerRoomList.Room.encode(message.rooms[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.pages != null && Object.hasOwnProperty.call(message, "pages"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.pages);
            return writer;
        };

        /**
         * Encodes the specified ServerRoomList message, length delimited. Does not implicitly {@link NT.ServerRoomList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomList
         * @static
         * @param {NT.IServerRoomList} message ServerRoomList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomList message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomList} ServerRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.rooms && message.rooms.length))
                            message.rooms = [];
                        message.rooms.push($root.NT.ServerRoomList.Room.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.pages = reader.uint32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomList} ServerRoomList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomList message.
         * @function verify
         * @memberof NT.ServerRoomList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.rooms != null && message.hasOwnProperty("rooms")) {
                if (!Array.isArray(message.rooms))
                    return "rooms: array expected";
                for (let i = 0; i < message.rooms.length; ++i) {
                    let error = $root.NT.ServerRoomList.Room.verify(message.rooms[i]);
                    if (error)
                        return "rooms." + error;
                }
            }
            if (message.pages != null && message.hasOwnProperty("pages")) {
                properties._pages = 1;
                if (!$util.isInteger(message.pages))
                    return "pages: integer expected";
            }
            return null;
        };

        /**
         * Creates a ServerRoomList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomList} ServerRoomList
         */
        ServerRoomList.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomList)
                return object;
            let message = new $root.NT.ServerRoomList();
            if (object.rooms) {
                if (!Array.isArray(object.rooms))
                    throw TypeError(".NT.ServerRoomList.rooms: array expected");
                message.rooms = [];
                for (let i = 0; i < object.rooms.length; ++i) {
                    if (typeof object.rooms[i] !== "object")
                        throw TypeError(".NT.ServerRoomList.rooms: object expected");
                    message.rooms[i] = $root.NT.ServerRoomList.Room.fromObject(object.rooms[i]);
                }
            }
            if (object.pages != null)
                message.pages = object.pages >>> 0;
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomList
         * @static
         * @param {NT.ServerRoomList} message ServerRoomList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults)
                object.rooms = [];
            if (message.rooms && message.rooms.length) {
                object.rooms = [];
                for (let j = 0; j < message.rooms.length; ++j)
                    object.rooms[j] = $root.NT.ServerRoomList.Room.toObject(message.rooms[j], options);
            }
            if (message.pages != null && message.hasOwnProperty("pages")) {
                object.pages = message.pages;
                if (options.oneofs)
                    object._pages = "pages";
            }
            return object;
        };

        /**
         * Converts this ServerRoomList to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomList
         * @function getTypeUrl
         * @memberof NT.ServerRoomList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomList";
        };

        ServerRoomList.Room = (function() {

            /**
             * Properties of a Room.
             * @memberof NT.ServerRoomList
             * @interface IRoom
             * @property {string|null} [id] Room id
             * @property {string|null} [name] Room name
             * @property {number|null} [gamemode] Room gamemode
             * @property {number|null} [curUsers] Room curUsers
             * @property {number|null} [maxUsers] Room maxUsers
             * @property {boolean|null} ["protected"] Room protected
             * @property {string|null} [owner] Room owner
             * @property {boolean|null} [locked] Room locked
             */

            /**
             * Constructs a new Room.
             * @memberof NT.ServerRoomList
             * @classdesc Represents a Room.
             * @implements IRoom
             * @constructor
             * @param {NT.ServerRoomList.IRoom=} [properties] Properties to set
             */
            function Room(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Room id.
             * @member {string} id
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.id = "";

            /**
             * Room name.
             * @member {string} name
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.name = "";

            /**
             * Room gamemode.
             * @member {number} gamemode
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.gamemode = 0;

            /**
             * Room curUsers.
             * @member {number} curUsers
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.curUsers = 0;

            /**
             * Room maxUsers.
             * @member {number} maxUsers
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.maxUsers = 0;

            /**
             * Room protected.
             * @member {boolean} protected
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype["protected"] = false;

            /**
             * Room owner.
             * @member {string} owner
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.owner = "";

            /**
             * Room locked.
             * @member {boolean} locked
             * @memberof NT.ServerRoomList.Room
             * @instance
             */
            Room.prototype.locked = false;

            /**
             * Creates a new Room instance using the specified properties.
             * @function create
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {NT.ServerRoomList.IRoom=} [properties] Properties to set
             * @returns {NT.ServerRoomList.Room} Room instance
             */
            Room.create = function create(properties) {
                return new Room(properties);
            };

            /**
             * Encodes the specified Room message. Does not implicitly {@link NT.ServerRoomList.Room.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {NT.ServerRoomList.IRoom} message Room message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Room.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gamemode);
                if (message.curUsers != null && Object.hasOwnProperty.call(message, "curUsers"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.curUsers);
                if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxUsers);
                if (message["protected"] != null && Object.hasOwnProperty.call(message, "protected"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message["protected"]);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.owner);
                if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.locked);
                return writer;
            };

            /**
             * Encodes the specified Room message, length delimited. Does not implicitly {@link NT.ServerRoomList.Room.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {NT.ServerRoomList.IRoom} message Room message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Room.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Room message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerRoomList.Room} Room
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Room.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomList.Room();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.gamemode = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.curUsers = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.maxUsers = reader.uint32();
                            break;
                        }
                    case 6: {
                            message["protected"] = reader.bool();
                            break;
                        }
                    case 7: {
                            message.owner = reader.string();
                            break;
                        }
                    case 8: {
                            message.locked = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Room message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerRoomList.Room} Room
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Room.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Room message.
             * @function verify
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Room.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                    if (!$util.isInteger(message.gamemode))
                        return "gamemode: integer expected";
                if (message.curUsers != null && message.hasOwnProperty("curUsers"))
                    if (!$util.isInteger(message.curUsers))
                        return "curUsers: integer expected";
                if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                    if (!$util.isInteger(message.maxUsers))
                        return "maxUsers: integer expected";
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    if (typeof message["protected"] !== "boolean")
                        return "protected: boolean expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isString(message.owner))
                        return "owner: string expected";
                if (message.locked != null && message.hasOwnProperty("locked"))
                    if (typeof message.locked !== "boolean")
                        return "locked: boolean expected";
                return null;
            };

            /**
             * Creates a Room message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerRoomList.Room} Room
             */
            Room.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerRoomList.Room)
                    return object;
                let message = new $root.NT.ServerRoomList.Room();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.gamemode != null)
                    message.gamemode = object.gamemode >>> 0;
                if (object.curUsers != null)
                    message.curUsers = object.curUsers >>> 0;
                if (object.maxUsers != null)
                    message.maxUsers = object.maxUsers >>> 0;
                if (object["protected"] != null)
                    message["protected"] = Boolean(object["protected"]);
                if (object.owner != null)
                    message.owner = String(object.owner);
                if (object.locked != null)
                    message.locked = Boolean(object.locked);
                return message;
            };

            /**
             * Creates a plain object from a Room message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {NT.ServerRoomList.Room} message Room
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Room.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.gamemode = 0;
                    object.curUsers = 0;
                    object.maxUsers = 0;
                    object["protected"] = false;
                    object.owner = "";
                    object.locked = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                    object.gamemode = message.gamemode;
                if (message.curUsers != null && message.hasOwnProperty("curUsers"))
                    object.curUsers = message.curUsers;
                if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                    object.maxUsers = message.maxUsers;
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    object["protected"] = message["protected"];
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                if (message.locked != null && message.hasOwnProperty("locked"))
                    object.locked = message.locked;
                return object;
            };

            /**
             * Converts this Room to JSON.
             * @function toJSON
             * @memberof NT.ServerRoomList.Room
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Room.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Room
             * @function getTypeUrl
             * @memberof NT.ServerRoomList.Room
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Room.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerRoomList.Room";
            };

            return Room;
        })();

        return ServerRoomList;
    })();

    NT.ServerRoomAddToList = (function() {

        /**
         * Properties of a ServerRoomAddToList.
         * @memberof NT
         * @interface IServerRoomAddToList
         * @property {NT.ServerRoomAddToList.IRoom|null} [room] ServerRoomAddToList room
         */

        /**
         * Constructs a new ServerRoomAddToList.
         * @memberof NT
         * @classdesc Represents a ServerRoomAddToList.
         * @implements IServerRoomAddToList
         * @constructor
         * @param {NT.IServerRoomAddToList=} [properties] Properties to set
         */
        function ServerRoomAddToList(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ServerRoomAddToList room.
         * @member {NT.ServerRoomAddToList.IRoom|null|undefined} room
         * @memberof NT.ServerRoomAddToList
         * @instance
         */
        ServerRoomAddToList.prototype.room = null;

        /**
         * Creates a new ServerRoomAddToList instance using the specified properties.
         * @function create
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {NT.IServerRoomAddToList=} [properties] Properties to set
         * @returns {NT.ServerRoomAddToList} ServerRoomAddToList instance
         */
        ServerRoomAddToList.create = function create(properties) {
            return new ServerRoomAddToList(properties);
        };

        /**
         * Encodes the specified ServerRoomAddToList message. Does not implicitly {@link NT.ServerRoomAddToList.verify|verify} messages.
         * @function encode
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {NT.IServerRoomAddToList} message ServerRoomAddToList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomAddToList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.room != null && Object.hasOwnProperty.call(message, "room"))
                $root.NT.ServerRoomAddToList.Room.encode(message.room, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ServerRoomAddToList message, length delimited. Does not implicitly {@link NT.ServerRoomAddToList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {NT.IServerRoomAddToList} message ServerRoomAddToList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ServerRoomAddToList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ServerRoomAddToList message from the specified reader or buffer.
         * @function decode
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {NT.ServerRoomAddToList} ServerRoomAddToList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomAddToList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomAddToList();
            while (reader.pos < end) {
                let tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.room = $root.NT.ServerRoomAddToList.Room.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ServerRoomAddToList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {NT.ServerRoomAddToList} ServerRoomAddToList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ServerRoomAddToList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ServerRoomAddToList message.
         * @function verify
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ServerRoomAddToList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.room != null && message.hasOwnProperty("room")) {
                let error = $root.NT.ServerRoomAddToList.Room.verify(message.room);
                if (error)
                    return "room." + error;
            }
            return null;
        };

        /**
         * Creates a ServerRoomAddToList message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {NT.ServerRoomAddToList} ServerRoomAddToList
         */
        ServerRoomAddToList.fromObject = function fromObject(object) {
            if (object instanceof $root.NT.ServerRoomAddToList)
                return object;
            let message = new $root.NT.ServerRoomAddToList();
            if (object.room != null) {
                if (typeof object.room !== "object")
                    throw TypeError(".NT.ServerRoomAddToList.room: object expected");
                message.room = $root.NT.ServerRoomAddToList.Room.fromObject(object.room);
            }
            return message;
        };

        /**
         * Creates a plain object from a ServerRoomAddToList message. Also converts values to other types if specified.
         * @function toObject
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {NT.ServerRoomAddToList} message ServerRoomAddToList
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ServerRoomAddToList.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.room = null;
            if (message.room != null && message.hasOwnProperty("room"))
                object.room = $root.NT.ServerRoomAddToList.Room.toObject(message.room, options);
            return object;
        };

        /**
         * Converts this ServerRoomAddToList to JSON.
         * @function toJSON
         * @memberof NT.ServerRoomAddToList
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ServerRoomAddToList.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ServerRoomAddToList
         * @function getTypeUrl
         * @memberof NT.ServerRoomAddToList
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ServerRoomAddToList.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/NT.ServerRoomAddToList";
        };

        ServerRoomAddToList.Room = (function() {

            /**
             * Properties of a Room.
             * @memberof NT.ServerRoomAddToList
             * @interface IRoom
             * @property {string|null} [id] Room id
             * @property {string|null} [name] Room name
             * @property {number|null} [gamemode] Room gamemode
             * @property {number|null} [curUsers] Room curUsers
             * @property {number|null} [maxUsers] Room maxUsers
             * @property {boolean|null} ["protected"] Room protected
             * @property {string|null} [owner] Room owner
             * @property {boolean|null} [locked] Room locked
             */

            /**
             * Constructs a new Room.
             * @memberof NT.ServerRoomAddToList
             * @classdesc Represents a Room.
             * @implements IRoom
             * @constructor
             * @param {NT.ServerRoomAddToList.IRoom=} [properties] Properties to set
             */
            function Room(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Room id.
             * @member {string} id
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.id = "";

            /**
             * Room name.
             * @member {string} name
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.name = "";

            /**
             * Room gamemode.
             * @member {number} gamemode
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.gamemode = 0;

            /**
             * Room curUsers.
             * @member {number} curUsers
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.curUsers = 0;

            /**
             * Room maxUsers.
             * @member {number} maxUsers
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.maxUsers = 0;

            /**
             * Room protected.
             * @member {boolean} protected
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype["protected"] = false;

            /**
             * Room owner.
             * @member {string} owner
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.owner = "";

            /**
             * Room locked.
             * @member {boolean} locked
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             */
            Room.prototype.locked = false;

            /**
             * Creates a new Room instance using the specified properties.
             * @function create
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {NT.ServerRoomAddToList.IRoom=} [properties] Properties to set
             * @returns {NT.ServerRoomAddToList.Room} Room instance
             */
            Room.create = function create(properties) {
                return new Room(properties);
            };

            /**
             * Encodes the specified Room message. Does not implicitly {@link NT.ServerRoomAddToList.Room.verify|verify} messages.
             * @function encode
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {NT.ServerRoomAddToList.IRoom} message Room message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Room.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.gamemode != null && Object.hasOwnProperty.call(message, "gamemode"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.gamemode);
                if (message.curUsers != null && Object.hasOwnProperty.call(message, "curUsers"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.curUsers);
                if (message.maxUsers != null && Object.hasOwnProperty.call(message, "maxUsers"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxUsers);
                if (message["protected"] != null && Object.hasOwnProperty.call(message, "protected"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message["protected"]);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.owner);
                if (message.locked != null && Object.hasOwnProperty.call(message, "locked"))
                    writer.uint32(/* id 8, wireType 0 =*/64).bool(message.locked);
                return writer;
            };

            /**
             * Encodes the specified Room message, length delimited. Does not implicitly {@link NT.ServerRoomAddToList.Room.verify|verify} messages.
             * @function encodeDelimited
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {NT.ServerRoomAddToList.IRoom} message Room message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Room.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Room message from the specified reader or buffer.
             * @function decode
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {NT.ServerRoomAddToList.Room} Room
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Room.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.NT.ServerRoomAddToList.Room();
                while (reader.pos < end) {
                    let tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = reader.string();
                            break;
                        }
                    case 2: {
                            message.name = reader.string();
                            break;
                        }
                    case 3: {
                            message.gamemode = reader.uint32();
                            break;
                        }
                    case 4: {
                            message.curUsers = reader.uint32();
                            break;
                        }
                    case 5: {
                            message.maxUsers = reader.uint32();
                            break;
                        }
                    case 6: {
                            message["protected"] = reader.bool();
                            break;
                        }
                    case 7: {
                            message.owner = reader.string();
                            break;
                        }
                    case 8: {
                            message.locked = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Room message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {NT.ServerRoomAddToList.Room} Room
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Room.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Room message.
             * @function verify
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Room.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!$util.isString(message.id))
                        return "id: string expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                    if (!$util.isInteger(message.gamemode))
                        return "gamemode: integer expected";
                if (message.curUsers != null && message.hasOwnProperty("curUsers"))
                    if (!$util.isInteger(message.curUsers))
                        return "curUsers: integer expected";
                if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                    if (!$util.isInteger(message.maxUsers))
                        return "maxUsers: integer expected";
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    if (typeof message["protected"] !== "boolean")
                        return "protected: boolean expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!$util.isString(message.owner))
                        return "owner: string expected";
                if (message.locked != null && message.hasOwnProperty("locked"))
                    if (typeof message.locked !== "boolean")
                        return "locked: boolean expected";
                return null;
            };

            /**
             * Creates a Room message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {NT.ServerRoomAddToList.Room} Room
             */
            Room.fromObject = function fromObject(object) {
                if (object instanceof $root.NT.ServerRoomAddToList.Room)
                    return object;
                let message = new $root.NT.ServerRoomAddToList.Room();
                if (object.id != null)
                    message.id = String(object.id);
                if (object.name != null)
                    message.name = String(object.name);
                if (object.gamemode != null)
                    message.gamemode = object.gamemode >>> 0;
                if (object.curUsers != null)
                    message.curUsers = object.curUsers >>> 0;
                if (object.maxUsers != null)
                    message.maxUsers = object.maxUsers >>> 0;
                if (object["protected"] != null)
                    message["protected"] = Boolean(object["protected"]);
                if (object.owner != null)
                    message.owner = String(object.owner);
                if (object.locked != null)
                    message.locked = Boolean(object.locked);
                return message;
            };

            /**
             * Creates a plain object from a Room message. Also converts values to other types if specified.
             * @function toObject
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {NT.ServerRoomAddToList.Room} message Room
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Room.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.id = "";
                    object.name = "";
                    object.gamemode = 0;
                    object.curUsers = 0;
                    object.maxUsers = 0;
                    object["protected"] = false;
                    object.owner = "";
                    object.locked = false;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.gamemode != null && message.hasOwnProperty("gamemode"))
                    object.gamemode = message.gamemode;
                if (message.curUsers != null && message.hasOwnProperty("curUsers"))
                    object.curUsers = message.curUsers;
                if (message.maxUsers != null && message.hasOwnProperty("maxUsers"))
                    object.maxUsers = message.maxUsers;
                if (message["protected"] != null && message.hasOwnProperty("protected"))
                    object["protected"] = message["protected"];
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = message.owner;
                if (message.locked != null && message.hasOwnProperty("locked"))
                    object.locked = message.locked;
                return object;
            };

            /**
             * Converts this Room to JSON.
             * @function toJSON
             * @memberof NT.ServerRoomAddToList.Room
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Room.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Room
             * @function getTypeUrl
             * @memberof NT.ServerRoomAddToList.Room
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Room.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/NT.ServerRoomAddToList.Room";
            };

            return Room;
        })();

        return ServerRoomAddToList;
    })();

    return NT;
})();

export { $root as default };
